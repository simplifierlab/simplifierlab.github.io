<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

       <style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14c826d9ecbb36d15e575c2522e1c3fca212d113240173457c0a42ea771762826a11ca949bc319518d0d1b18965e7e735ba4d77fc4a1f13de6a60de4e0aff7fed402900642e71e22a5e9a10935bee65190943a40e6b402df696d89bf3058ed73621500726197835a088d7f075f779e31d1fe115bd677988a2b8cd0b1d9909e4c686d16a44ea09350342e0957b1be83bf96059188d231ba1970c2ed41ba36917a51225a5c9c588b81c44f151d7c682ee582807c30324d5e32eaa2d016b4f835b58e989840864129a641079c75e04ed617449041aa45ebfbefbf045c8f561fdc5b16fc6441ea107f74db239837d6cf77aad80998acd1181b04f1a2075040d3d8d99aac2cbf891e9b9e2cf03f231da29d82d8cfd8fa262736c26c5956467f169d596e38332b1b2451ce62a88e969c8d5530b8ca51cb4fb946a168e5efc9b3066f47f8374e9c3907cb815ed498cf7fef295b19089a99d4a434855bd9b5811219f9c4ecc9e5b6e13a167c5ada497ac78ebbf7d2ba3db15ec3b4bc50ebb16ee06ba076afc761adf1310d347f2855eafd00d9d68b6e23ad1128ba67ef7d317c69d98741390c688c1c397acfb65d99fd441f23017112bbb539f74623ef63c814ab96691f84b46a1a49197a3771a22b34611d45b3dc4eef00b8f06ca674910aad278a6bb33630506f63f1bb041e40cbd59725beb70efd1de228bbe8beb0df072d7b02d877127c91975dbdc9863a810140a8b51a3249d077663ae2f2c32d3a0c16d7995ca1c31a0fbb9ac88c43abceb216a77107526386c6f605f8440259e4f616a3410a7a9b1efb985b94f1a0d5e20f8fa7db98809530f50f37df93bea077b56f479057143b78db491ce99e09314c7ddd46986209883070e82f3eab2295fa62011b37fedcfdd55527021f8193707d38733e5981274deebb12fe954765c735d4b48b68377523190652d12246f828d07591dd6c6e4cf8fbb2ce890398ecc7c345964940a8bb9095164d5800b82935fd45b4c5a46620145f1c31f35525c41e59a031b0b7f9ac9626616401af3191e5fe3d3bc7549b60dfa3dfbee8950a643e3e9bf295c1c867ab8fdecea25c2ec9d513583766e1d0deacffc7c7dd4c07533f5f850d529f7def63bcf8fc777f1da71c409f434e4cd92a1f0fb1145d38c6e9be48026b0b84faddb1e6c391554940d60cfdd77e657a0232a1f1d9a2bc0f56e1f1da6669de7804492d292fb02226bd55011c7fa3ed89a61197b88f4e0aba82abbbb9ce0635e9d0b99b8a7bd68758ba54c257ad7c9933ad25d9e1933760da9576739fb6028be127c0a5946ae4090e84468c6864f6f4e5d2017be1d453ba40627813076b4b0d3648725e0c17d1508534af497c600779ca7abd5f9db59382cc762eba882c506079275b92d5af05d0422047dc2bd7e074412d9a242e1cdf8087dddc62e3adcad3f6fc947649f22772282784e2d4ba67631495dae2a2b6a562ea964b6557a2a54d98743146f435fa191094ad15ccaf17c9fffe6a876d4a28e0f312875b29c632afdcd93bda19f5c8cea2f242bb731e0b22147c6f77c74a7ca9cc12970b413460cd9f8875ab7e83ea0c87e3b4e8c3fc4ec79dea42f865e764e82a453ed3384328c920f87c966dc265c084fa415aa9cc13b69d186dd349428387aefccb2726d380fefd9fab3b055cef1ceb8e182a387a73a211b44cb4501008ac5ee78b50a5b9b85b65af99d090f1368e8256d174dde56f5f9a92cae6f1c030e110e57f2915fe8cfb00fb57a4907937e1a847b7a321cea440b76d37c2495d0b5668c1b020024583256b03bbeb270028aeffba1eb365130a8c6a83beca6b5401b5388676c1596b7d6e467ed06e72a43f3f5ebd263acc65dea2d3ac80b79e9584f78c02a5c9a76969925b017cc039388ebeadfede1d65c033d1ceb3b73ba0d11fe29c85216f6cd60f4fd3befb075d1152b1375efe6a2986446a58ac73d05ed06ae6e98a9d95eddd70e3dbf163408a594a50da970ce69ee802aabe666e24663300ebc72a8c3ba0bb8c766b0de03819806062ba6fd66300151b5fec0a208236a8df8c8491408044e065294a5f5f11c42ab4d55343235cddedf368bb002afe22385c7c5b13f2d0dd5ee2bd4dc23ff15077e920617cbae393af8a67e6d3b762965be71fef7c2f44750e98e87391133bba18949ad0799a446aad032724947535f58854cfd6cec58c2cd40eaa5cec26b2946e5a93ae827d626655b8a63f14c20cc3bc9a1c5a3f50ff538f4a712630488fcf12d807d44c9f3868215c2ce927ad7acfa59dbb891ca359f4faee108611052fc6268208cb5066363c119b775503dc621eece627359263c9bf77f784a88d05e8ef708934b3f6dde96e6c1540af29f4cc3bf4dea5930e5eedd0b0f7bc16e922abdd1fde384dd26abb7bb94ce736d98670e5de316d5ce941a0df7f31cf47345fcfb77e49ac6d217d4fe5399009c24494a77ee5f50efbcfc47b3a36dd9ecb3437663b94157777097f8102f4e0128617f0e8938d04d44f05730d35ca2a1804359c386c8183ae617eb09d36be0de90ebb7980a3532e2fa5aae81e16fb1eb022433d7d127c9e13682c580bd13730c338f6398f758edcbee629ff010949576e3a35179a66550f9f728bd57c8f6bcc8c80a36c22681cd6e7f6775252accf7ecb5a98fde845550f5452f7dd27f79a1e22b8691b1bbee5c4b217896afb634a5c461d14c042fe3b898e649bccd3ab831fca38839a642baf116f74a0b34adbd1c640f967dac246507ef70b3b8826ddbb010f2805fcf405d93f60c06b30357c44084ac18e59d6363449316a53de64b4f40612fe1bbba30c2a3bda33b776f6a7aad438d1e7da04852b58dafaee64f989a4736e6a1a176b8ecbd20512140b511236ef1f976c2759c3f483f0360f49b94537c7a1798de79c6c1999a14beaf947e5f891a36ba0a17562b8ca4c5b4ee8b83ff68bcdbefa50d3ebf40a561e1535e7ef1ab45699c9b0be1b14147be9f7340549d8d9fe084ecca6deab650df0be9733b21f1ca718563b71b84a65d38eaa2b0545f2c6112a47c1d0ccf1e6061a116e9d0183312e841422833074837db074298aa6b640b0cc8177184479fd0ef43b75445a0937dbc4ce4509b75c2543a8197307ccdda09cef597af999b1f639a7421d3b6ea1c77b9976d544a45be8ba6ed9465c88b012632c0f91749d289d03f4578c152620c5533b509fa75d4e21005deec82aa233f0b0a0558afba48e9d8e255d358d6a313051391a7a02ac18c941e24e5ba93dcdb3347a95aa6d6a702bc9454e04773fac17a3def1c8016fc3b187a7ca36c447b4a122b85ea31b1a2558e99af346738136b882a7329947be8c9bf075512d6b337436fe6873e000937cc1b7a9e12ecfdd7522cac2dfa9b177d464a228c4f2f0e38dd461e058626e07c50ecf88d5f23b9ba01d04a99923f65721beb33c5e1cb816f5f109e17ebd595d45bf0f298640ac4060909e60a3a29f1c96bcf35f31127b0a3a6f39fc8344151a91b64e1f976fe3a9244488c69098438d596da5413360c2404215a6d2267db62e540df0e46e784e2d97ced512b3599cb3d31e94a89fa5d87e9d1e58f5c730084e2cbb70b361699b171f0c4b1ba5cd3aef7828e4bdb8473031d1b945a79b9cd369ead603feccd15f657c70d0e3adffc3cd53e7aea979299417cb7996583541aa57b9bad4f3a9456e2712b96c5e9d831797f0e5e7b78c704ee90b5c051aefd1de94b87698f54851a60ee24fabd6dabe48b154b57e924c2ee1b2e6304cd986e3b9bd05da25547218b13ae2b634167d7a09ec9b6ef328324f5388d2fa12a2a31f55bfd66c3e7460ff1a668bcf649ded02747154f49b648ebad9c6493d7062baf66353755ddac53b3c9e357127c5c3ad75036b478c1f9fb4c224c1ad8b03e41d6c70d1c9a407b49d80a68600af094ee625da0f465fcbec8096904da8f06a26dc23c3172057beda836401b94372d2a45b6f2d047cb285d6a4acd7036b3e7b697698bf5111083a08a42abfdd52cb044d10d7de0ac8c717d59ebbd100e87f9fdd3dd557d5f0c04b82bc6023bac3a41e21fba5b61f2b4cf2771f3bd6b5099bdd7a44193542e51f51f820a607f4760f70909ddcda977a863e7a9b9520e6b172594213f82a712de84ec0a6a3180a1c641d9e855cb5dc240974f4e946709e437ae6159bc50158434e7e8a123bfdcf3a0e3e10614b69fc0f2868f9a0aeed4f5e74da9cbe9b41aeb72f53d7178302cdcce8734e24b0f3391749a8832acc15bc864e73ad606d1079f8f939e59b600417b2051d5aa446086a4874150a5189221fae5e92454cf22bf41e03961cfe6aca9d96e64033cc1656862ca82c8430599a1e75ca39be9b9c7ff1a1050e707e6b775f006dcf4e64d888dc43895e9ba663e82ef1b7fdc0cf5985f87464fb3ee0a99b9db202e0d933a3f335c3bbdebea9ae4ff83bc09a075567cac934d581ec9e48e5d53d5c89924900d5ef604fbe0d5cfd2e4bd14bc4e06d2d4a04b5e736c906b89dd2e38df7c4d9393c910ab74c6bdc3833b896b733d5a86e445bad01d434b1c598ba66239956a2356b216fec516b79d0ff458fbb35c71cfbb9011c8b6185ceae12aef48a6513b4206a65054ac1cac8b8c616cc40ca1c99a6f9f5f985cb42bd52cde9a174ec30f4bfd0595d08d72b494451860dc9f6e9cc4ce91f943383f422b305a5c0b141030494b87cbae68335632bc96e05a44f66aceaa8906661a96b6c5d40d8eb4b99ae8f2b9d4efba18aed189101b1bf9b1992af175e794b86e626160c15d5dce0d0e120eb85490cc2e95250fbcdd3483bcf9ca52c3ffff184cc7e01da27038c36bbaa411789b378f69f518a0687f6b87799d93fdd59bdb2c1f9668a26f56696ce732eb0bac60e99789209b8cbdc406f3618432201b19ffc431507c3fe885f1dcd5d09529323782a393ff9cc7f65c3b1a80c433d6ce8dcf696019969948a5bdff5c4f2bfbc3f773bb389e28a13852037cb904d15545dbe20a1e9dbd6f29d4427292df36243766e60bd7b8f1ebbd719469a119c3f371e5ea7a16854077f6789d3ed44bcb8c940dc193b576d67315bbb3a453acd97ee29f3fe011215bff8c8aa9a07e91dfb906cc7d13271c1e5c0cde663c927b3d5c59d68f2d1f95e43ce72cddbedfb263264e017b2b66d788ea0fa951b86733c653f377bc7f36f2a90714c915023492108480865522d826faf973056ca23fb11f55aa6800d4ab703eac2e32570d4c241d4e0ea4a3c2401bd2af7c48561ae763016cb387fb1ea19800502c5a9f5757fc0e47dd67c9f790bd99acdf522e76b0d30aa51821ce66574560e5a435cd0bdb1300ed53d918746828ba94ef58e3ce476e338886328b40f08b5de59c466902644f69d8fd024869fa4008f32475195d2a7622d778184fc99cbd8501befc46933489524b5a68eeb7961e3760d1eb1f3a413aff94b86cf1ff2f39adcc761e436c6c3fd01ba1fb48baae6f520d625239429b21987c6e30dc85997cb4712ca7874fa9e30098ba2d48fa56cc9d01f4fbeca5a0a5c3b530fabe2d5e6ce9f5e7fdba9e107d4a90c6a4e75d824701ed525bc17f47b23333811148689061d6b8d161516f8e01d2d7540bab26ce1d22ac99b477ba873fe4fdefb9458a55c2df0f5d1d6e531b839b8a88fa0583397a65a9850f1692f514a0bbfcdc6d657e26b7b600581076dc7a7a0e74632f2cf3a1052471cd27af13814da432bc5c7103aa94cec08f4b7855b013cd4fb190433165f3a57a21e505b3b070a5b07b7a464e6e6f07f0fa53d33193ff8d8ba34a58765e375bc141b6704cbc44d233e197c2d59dca74abb7b788dc7f242eb125e06c25b86d022e7b645085feb50f3395263740bb1f1058eb8eee5ac25d05a5d9e69343bd5cc2780d6160a8175da55d103ace73ad8ecdc6e1421fab6706ff99ef21beb1dee1aea13eb2dfe189f76d76463fcac47e009bdc1a055f1a7b9f8e993b78219aca18c0769acff4058ddad1062ad1c08ff8b278fef89636995385cc17909e86e55968c31e24f14d62ceb2dfd1ca777aacc0be5ba50d6fa4f7f9eaa1c16a5e80f30af0f333bdd09b176b8bbb1acf8149a76e20ff7b16c7b3a5138506e49d201de88aa83086678e81764b582b8014ba2e68f76be3b7c601a973dca4e015bd1fdc19aa355466525e3f7a8a5c84436dd006d38c4cc3a959de68aadd25d0178993209938fd680f106bfbef3dda7d229a6ad434eb2b455deab03901fa69e6bdc10538a5fae14f68d73401c58ebcf06fae54e23381570f0c6893636c21d5910b38f72d420802322dae32089cfb9316bb27ddbdd38e0fd881f241fd2f7556f7bfb15358e6ed0d3bc2a53ca4768f0c31c014f5808ff3dead05fdda5f96da51812eb85758c3754645106a04420fc28286498c804221deb60ea1421aef7f150e12779000c0193edb5d62c397e28b9590ce5222375c7f140c21ebc1f5799d87652739ebb0d867c8faef06da77cc2699f0c01982475401edc25a34c489c6dbf9ad414acff4ff7f31a220875934fd074380cff2182a0b5424a4d3a200227d3381e7d1816ba099e8b0ab68e5a5b3874fd6743e3ade5b69aae4a3b6f1365cb959769a0eb2528165d39fa5503f3583859899f21b79200e74225558558fc36dfa1a927bbdbdd197a37962bba5fa8540a30419beadc1f73313ef649d7de6087b6c90ec637329d60703c9d40cd987409725c1a9be8d1f673e296feabf71935174a446460282fe3e202a6126a33c1e92b86e36f396551706278b74ef9867abada757ffb737407e13561be29bceb8548fefeccd0b6a866acacb1083a85cfca7447708bb7a0cdd0762d279743ddfd9f4ac46dd73950cf7bce745649e1fbdf311cf1139ffb4daafe0fe47573171edc2f7aed9bc84f560ce0732cbe508eab32b078b51f06c8b4001ed429035893fd88c9893bbdeb61fd99c8a2c6e3dffc21ec15946187b8d8864fc9a1ee662a2a31603d6609f5336edff0c081a39fb20ffb47f65af71c52eac351e96ec084de7994009f9165c2b433fc51ab6c81874606597dd5675ffd051de439ffdb3fcc1eb25b9e996ef386347a48beb6592fc0b26b373d433dbe648a947af90a0e30c12f08a80c9a1ba74dff8b3dbbdcdab876098c101af1b65021f8144703c61295a17c04ee2fb538781a2cd263c21632d39cf00b9d1721a17976e122c12e3f1ac7c963afb61948649eb881b89c27dd38485794ca03169b50db9a93809a3fb8eb0934ce559f55eb2121bc75c59692ecdfe6fd4733ea57e1c5dae318a94e7bb41da4641537c4619e70d0088323a0f77a64e495bcb2e0134d445981961de9c551c981bb9a74eec087b1b406f67ce1988679f06ef649ab305bda6a26bbdb9bb00a0d65443e345f4bb519dcac8f8597233c2ebbb3f38da0adadd860bc6065f13b2fa1d42305791c9e200febb97ee3825a89a19f17bc9ec1635a498c0362ef54df7fb1854196357cf4930fbe6aae812f1170779d7553d51c9baee0356ab023c09cb26f8b4c2ae73f4598e7fbda9b4afe6abbc682f332b5a6457d5b45c55f4275b6bae537e1223f17e85d5f53eb88c0be9c025051d019118bf63f281605ceeef1f826bd3608d6220d4244ea816162352fd3eb451bfc6cce3f72d4823a004d43b386c004082de039a751f57d48f6c775f8061f9b3db8d73aafe653fd0b24c9cd536b012dd7aaed680aa3860ff4030433bde82ea6b19e58d801e3fff4e9b083c4a8f1c9668f68dbccb4dc0d66593eb76041518f80cc9ddcb655b1165608b560767bf1b6296110720f68109d89fe76194ce041c6cad1019ade82cf62a2f8ff60761e4f6f04858277a6509b8b7486e9444021fa2848be4f56abe263a47c128ce8f60cff43bde4903c3aa9ccfdd692381520d31677e686ddb15f9da0c7570d8389125034286fb74d68b12033a3d465a38073066b0163d7d8b370f2082641848662bb7ce5691c446efbc82dcd7b01bd968f1ad750702e6561d1c8dde2000b0edfe6bea26651906132f2b70c2240b5d82f99d10f3d08ff4389838dcd99ab6439db4a81d30b873c966d0db13614270b9bd0dcfb6e620f0d4cc3e318a34c6c767063cf275861c5934135deccfea9f5cfe556f9f8239afaf7ce7854ce0819e17ae6be341de9a51d3bc3230043837f31c5a7d3681920ec401c159a16c0aa13542662e96de010354757deb05279be377e94d4f676b79cc08db4e58f78f20a1e2a6583371301055fa7dd8d6804f1d7b0cee5ffb8b33261ded52d0744687e9848be72fb55a8846dea7ea2b28ab7f842a34e9e26195e99d26ac75e9ae8a1105fcccf985edc536b48b119c20289d33c7f53404ff0477c9ea8d414aa6c6fd481ffcc63d76741311927cb31342e52f43e15b9c611912cec8320a8f4982e7c7def212d49dab009f568ae6edeb6d4d37bd07c76e25ff02afca9eaf6120405354622e4ca0c03772e7ea0ec65e0300bbbd0c4c293494af8eb513f04c811d5a38fb0d46dd4be0a1dc542d5b8d29966d474b4f1f4689fbf82ad0d222fb96f00227b7521f3af1548986930b77a5b0ca0e76abae8fefae8b7bbdde1ad36cef10fb61c67b0691bdd922be44362db70af4cb945abb74d5749f0482234581375cb09c211756d9f26b99a1e5af063dc8db5f8c0758f77c6b2c07ef34a34e8c86423c546c0e12e4d0e57089c5eb354feda1e73148a0b3bc67e7074242a48761f3c9d4a6a654f59a69bd7cf28e657148499e0566c388980d2cc8dc848e0717682d42188117f1ea29318bda2ce5a012b12c97e72249325ea6aec65c66e6f002f9bcef71adb1cd0b7886f270c121546502bf244370b77bf989760870574d91d4864023d49288cb04a4aa519c685d53e83dc943a827bf51a3a5ac070189689decedf4e24a699e44aaae1a31ca9e4d968cfd3f83049beab37ecfb68f656dda359159adeb5854171d99d490a59236b3a506f9e196f4bf3142099898aceb0e20e4396de37e3c9af7cc7e60bfb0549ffd0d93bf7f196b6efdf72f1c83b45c55649e9c9d2a46bca046dc15249f6f114e5d6690008e2e286c4c029be8de39a9a39157d9cb6ae50fb0359d0554b56348df37bddab2edf314d8349f89eab581cf9e097487df3dff04831fe7764b2b1e5f21d7081ebf9dfd1c6973fa3dd8f2365bc3dc2e40f7853d842b0bc42f6f46d6fbaeba1fe43deb9c083eb33d3f55d2bdf13ffbfd707d4fa60a201ad07b8092afa2571b7c23dc127d16b11b303154f2b0dd69704c5805743b46052245129ef124698db991292e8879296ae9c3892d00034674c1298aaa346504592a41a747b94e64e0627ef22f40823bd71a1d968c59c0786c6db186ff0fae613c62639e3b1901dcd56eae5d6a383ff195ec7957846751440ca28ca5416ba8157f069be17fb1f93578238e15c5cf6b464bcf6ab4af4802f64f61b0923baa360b04aff1e9e6938483b5b4675e4055214a8efd412efc9792b60176d29272cb8b8d2d52de16e7ea47c7b4b22f218753e32b5ca86ad86fc359db21df07f94badecd4aac23e89c37e61161709d42f41af0a4f5430a83166de03aff307b317c8c6f89bfef89400406d65314a520cd10cebe63a33fad0e91a95bb6d98050b3576fd2a35191ce5b7cdc2c74cf4f6802df49adc53f35b50430fc62c7ec14f5c12fe3fff5f2db4163e5ac34c9760e0c51e30f94bffe020b2b05391b839f4c90dd90b471026989282586033198f80d1b65a694a4d7c80ea45f6e9f8698f63fa35e3611d885a292e2412ab8b8dfea65cb737b042f3b639e9a02f9cff816bd3c95614d01102dae36f30340a96ba3814a0b3b8aaed895f872243a567a55f37db8d603a18c5117449366e487e1d24cd3055f30481c0cd9fbe25312fa1189cd4ba7290d365663336269e16c6fdf72e2f4b78036ae441a87c00125f17eec65f9b8d7b4cdf55dad2b0650dd9512aa4249a1866d900f1036bb7c5ef98fd35da0c684c08cdb46f106028a9f966352726dbe22af77daa07d27ab1e57467fdae2e809624cf44929985ddbdc7723aaa0ffaa85884ce60d8a3775194ddee353481504cfc71f3fc4d0f86956dcc5fd32bb604361578366ae4702d4cfe3f8d5ff653bf061318c241d9d94db0c9db340a40ba94a409d7fb94790ebb5511c6d46b768a84d786fab67b3e394573f16288cf3e20510aa7d207725600a7f291cee975acf74ef3fc75eec92b4fd727d65c287e1d05b00d1bce7496d166f2dc2147221043fc8817a73867f32524e8ec28919e2f5399c39e8b6a52831ad700ea252a5bfc97c5e1d4293369edffec61b03d98c1dfd8df534a56cc75c91640daf16b23943b7420a7b7612d2764d9affdc2c3801b09f01acfefa58650711ca0034ced876f04621fd952406b2d4ee6f1ec201b4eb78e84cbc2be1d84575737536cec9ed8e162ed3332be5a6a9dc189045a32457c29d441af236351a2c284d37ae87e02510a0f936a82300731d225ab9995bfc805c20e8f00befd7c67387fd80697a9c388b546d3e0d1a6bf6033e1350ffb0e7e4bb7f0c885e43497afb4304b052a3a7f0b9df5f15e7cc1ccc01c8ac283100d75d6746adf89916cb6cf8540a65a695a171276cefc55f5401b0d0feb045055270534041fcc3352bbf1615ef5ef737f3192fc350cab4b080bdb8eb8191326b1f9fa5e8d9d930ff88b2d4a1519312ed98adac86099902daf1eaba492fe717a8c668b5de975b4bc6beec3259d7c5a027d6c01dce2b9f1a58f8ccfa08eec10d271bb93a7878287278c1cd56dd7b30c4017828d39af66a22d6841311180a909f9d69766483584feb48f8cb52562df2b83efed43ecd618010b02954b4de87b3b2e69bdf1ec0ef614ebfc0d8e5b607ba60ab7ed2fc7329c7dc79cf09502e30903a971ffb5138b0408194fc89a3b3ce2053842d89e30576cd3327cdfbb2a02f73d78de813ab6f04e7804410d52b2d4433ad508937255bd10d2a55450eeb4fd1ea0c7ccd17a09398b135e3c0398a11b005bd83e12108fbed58ffdcc82e3811ba3e2b129b23a9ff73c3c7e794893095cd4cf4765f1cee3592ae49facf7bc6a7316aebb8cf0e3ad177362697b755d42e7e88e3ac3df9edec65c1d854ea22864aee28e3e53a154ba4878bdc6db8554a3eeb37fd64595c8149e23377de9bcdbf3923ba228a36674545c5d6c9012f1bdb4113c3363f506c3fec49ce6b4d985b19d7ac496143e3f6204c30b7caf7bbf66e66f7beac1ac67ce76ae3d22491fbeb1462d7efde024313dc5833616d317542aa494861abe9fcbdf44efb5be9e5a5528b9e38d9cd5415f2368fca7346c27e0aa59e5ebafe8569fd43b7c74aa4a582001676ca54ba2a84610ffd9e679ebf74e8ba3bdde5f7f7526b77923b0ad82034aeb215f90bb8c1bab61795d325671d6822d3b0ef09730bbbd7d809405a52dc09a7fa19e453f766a0da4ba8d33934ef5438ad7bb51f56980773306e8454d15d8582face482c1ad394ca901a97ca263c6270f02bfcf25d1270b648b9c68f8a31d9ec1c04497e990c7ae0af0ada81275fc7ce5f50fd10d4c79ac6b35ec083ac4068fac923f7b3c5f344f8af49b12046bc40fa94a9c94cc1ad6c371a25324ad3e2200e1b473beaa0768ee458d9dc54e31bdcfc0b3eda26417b5b50349581ee7522041acedba9eb61e85efc22013542f7879a60ebb1ab8d2f162198bdd30ff42c34502ad15d13a21ce447cd4aa6693bf58c8d9f0cf8126d2dd8fd11072c52b89244d3f224fa2048913c121dc6141145778b3133529bf5c01872a8f6f3b11632e2b9c8963ab1e9bfc0f8a5e2a1a24d8b4fa985e2cabecd69a262af2f1b1fd6313a4233e3c0f7fda8c95fd19f7bec54bcb830ec89ce29dda7424e379e5711de5e305f9e36d4e0e68c09b49f1953c7f21f9fb0f46f9b019b45f97ed9bf622a65d3acb3ef23e802d03ef68f3391365734b4b2bb4c181e0ac75f5842f3d8db5eb0f66bd6e8d94b89e7880e3664e3363e946d996e7e3503de07077d977237adb4f8ad1ee6b7f5894fe399b59f443fb4fe636b96d783ee13dd0df123be9002393b0f32776e61a917393c6c84cf1b3692572ab0b3b85be13f067f45e2a8fa54e38b6b60b825825486a9cf58515ea627e8e0a591ff1d21d2d2865c5fc0c5373683163c796c1c3d8397d3b136b9f798ffd1480cbda388d861d79e032a67f80fe018bd19c926e856b0662e86c8625ed81d2f8c38a457322247bf064714403a368e55d83038de9e04e5973110cfb3ab5511b9df2d5f75050c271667b89ae5e8bda2720deb317f88fa995287821d486b411dd8d7b43ccb45a5c81fc1058135e9de05ca2a7f549e11904a6a148548e5bd15886a97bb740336fadbaa7d4e3d8c10dddc200f0180eea0464c4ce9e0ab4151b9daf6787ccb1dca926b6acdd9d0a6a16dde5f6c506fc8ac5a03e6b29bc28915dd477d22d60370cce4dcaf6aedf157951fd16bf168d8e5a09d2ef66b1ecd0a56d2e9bc7ea7efb8058dba2c805b97e16592d9c5ae59d2a0643eba4273f9e1dd66c98526b453be8a6f558b363ba7b2af791649b5331523b877072d750f97553906a8256b1b3c45a97288f269b4604f837c940ca46ecb55fcc6c94bc1f93348ecfed6e716da900967e2e257a7c4d60e807fe032573ecc5e110b54da4be2e5b0393644b2a34f2f79fead1f4473c9b676d32b4c2e4b0de47e422c40ca9ecd523484e6f0cf2d5bba6c752a343ceff58e370205dfa5b6ddd012dcf45e19bbcbd69b2c2f2f09ad5c93f3d4ff62b939302ed20f69162efcf3e768628b6fb9351b4679f1bd7106dfd950b0430b9048ee93a96083aaddd0a6d41ac727acd012869fd5d3cd351968ba42b3261b929e1028f5e1acc07cd2cdb271f60d4f0e65789e5a9f41d879ff80d357072392529c3a039ad581d057d20370088ac274042badd85de216cd774bd3f547b471439e9db7c072b56dfd9b23273ba863248fbe853f3f1ab8cabef9bf15415c2b59ce1d9fff58219d551932444460a0316935f77057e95b00ed5fb5e69cfa80647305da62dd5ced2f9c57b4f1bccfde8334472153b376c806c7f3253b4496a1dd449604bbd40d3ee72fee1ab462806cda6f7618f19e579d3545dd740b737424bcc6797e7e0274cd4c6c011f80af2ab942c969138b4103f70ad027818d89b289bcb90e9bea1a8a0b89e9323305589c9a483c971db88cf24396c3e345451254b41ae4999ff4e367a2404c33a1e0f7641822e930b8a4aadf42fe88a2c4d4852f80c782deed5bae61b6716de58c4658d025032bfb7525249b96bec30cb838e56364cb25d9dd919976604a1ac561dfe6565c7d3cbeec9f47b14130ecda2c8f8b1e0445a0b6f93432062727c86149dc9adbb34f4ba403987cde3e5bd9cbab6d081dfe15e0f8f4d56c33b6aaab94b725a65cd25410196ea7e5f3a0498488f92652fb31c5a09ccf76f6d8055ac5facb56605e23010e0fca06f2e64d6b386bbb36c11852475487cf8413d5283cdbe7877f4f823b460b2290edc155a68bdc22207c2b99094a568e70895131d8854ec0b26eb76c18186905b6f9f6856f46ff56ac1c118d1f4b4553a6fa8719c6d71becf2fbd879725d299131a99d4a5dc1f2f0a631dcc752296ee42badbd7f6c2299354642e396eec71b42de5ed5e1b4ceac4b8106981ab338a9250589d379383892d865379da2951690f274efc9d7455dfee3ba7b49a4b541d06a0b9b65c04fdbe8b2327b70275b5d76dd89871ad74b9c9fb8defc948b5a113f8062165ae310b2ad61f39591fedd7b936eac6e69e741205089e6b6cfc845209e0a475d0612e80186a95065cd2c4bc58aa512f86e1e919b15b296c1883e3cf6cb6c5216872006031716aff060c1a0da9d593789b4e3e1a6449d074b050f350aae566116917167b2e25f40f48a4703d62c7acc91b4d04f0496bbc273d957e5e7b04f962635886f48e1e0fcd1c30af71ed8a385b748477a008f57362ec3ef45b0f114af4eefb0010a7c667934e43d6d93e03f170a60688d0ae0c21e825428223b3de5896ead55207380af49373bc9a157bf848e8d131a05ea9edc11bbd0e0873adcf867a917fcbc16969f7596c0adf4b181a37a74a5fbe29f211908b697f8cab4971d5b4be502ada8d0357f002b2db766b64b3cf3a81e72761a18cad95b319e400436648c30fbeb737b0ed62bc0916f43e4dab44fb8ee869498683ae65b1de17a20c55ed2cce38340969244b657974dc9254a4bd84f8b2866d734057a336409dcdde640c61fa3ab886cfda359873004ec9e4987b2117617fb98e3d9a2867dda9f245338ce7d42577fabd0440de55c1eaf71989889887ec0c69b57dae103cc547c80db5b8ca2c110d7d20ec7a2d20aab6c01871465afdf17ed34597aed6fd0d0b7d8c881721a9ee756e2bd2598eb724415e7610f6f94864cc0888d7eafbe57f07f34eaba79aa3b5aada0e1ae47e58fa06d2816da41283db940ba6cbc78c2da2ec865eb75edc4368a4c407c153016fb1d483a602e635710513c62ce98551e29ca5ecd36a6f7d62663933be9ccbbf3adf2a2cab509130d1d763b381ad94cbfe84babb73cc791e3320d3865b20e2a5de7d54f77b2d8ef94e2897125ccafce3cd5323502d23d3c8d44b72ad8e5939a5f48bb4c16c5aebf562f4e921aaed2b74c03fac54403a50fd1b93ede1303a19a7fe93e6570875e698436101991952c9df1e7d7571fecec3bc6c297e2bcde399d9eb816c2e63791272782c53d4cb5e1f16a809e57d6b3289d3356dfec262369a79c044ffbcc7dc756c4e12b67f62b414ce5d1213e2cd264a45f1c1d9c67e9fa2431763be03cdb245eb9bd9cfa104d989857ce3477c0b003cab557d2b9e0dfcaa646ccdad13a556a71c93e2ee9bfc6e49c31894591bdff9d13a2d1584effbfdaf1944645e8f3195df8560b2f12b784b4c2782973dfa220164d992d0aec6978ca419cf7fac930fce493f8302dcf9e84178d485dfb5cb34abf61e18a90ce52ed54caf2f8ba84b4582ed10e80b7b475e538187899d3f453c29af71d2644d9c7dbe224b51a7c16efce4387bd47486395c133bab8ed2189cb3c96e6257def31db11706ccc3ddb486244ba823a5a48ddbb6d0f381e7808af1d4897e6234f35de114d28912f60fd3aa089b7a34863b7df61edc20e5ea0fff3fbe56d8a494094597de8462e55cb933976bcdcf908c16e5d9f1f2560bc2a5c6cac98cdf4d1d7233e407eec5f215f868bd20522dc3aad10b904375d1e02203243ca3c949bbf2edc5e8bec353f3d26a6ea4e4b4eb89c43ae164dfd5d9fcef567a72ae9731f463882ea333e54abf8e9376e83f89465b4e71262006ba860a75dd9e92755049fad338ab7bf057ed8a14a96ff9f3c6a6864e25941c39dc965f97130c096f51923b4701f1fc8f44332647557fcac412a123bdae037b28917b7af5d8cabdd95296f43a3992164aa3e2474c04ea8681f2e0ed5eddfa15dd7efe93bebf9ba9c05662db5a371ee51012bce22137812c6e463ba8c041eff4db0fb7e922be7fba2f687fa2fef7476a14c46431bd8d7908f8bad0935b14447f32a5a2d9ca08b7cd878b9f6c09462102e9e25439ea88edcedcef9406c25213f0730e13fdcf4da99f5df1581cf0d768fa0fd7ab575079b1db2fd1eaec4ce85c388edc76c8942070480a8186dac2727cdee76ecda72227cf333b93e91f083e8a26963e50093bc590e53d81b823b26a9c2db8cf51990ebcd9a8961ec603b62d114c5a4a6b983cd071c66922d0d8aa0153a9995c596a5c5dfdb28166fec6a4fa80fe9bef1ab2428a454908235aa46d55bfaea0bd393a48deb50b3dbb90ca1816af4f6c6c7bc98b2ca76e4eb6fcc63fb8058f2df885d2d7b7a52d38286c2325964c76449eaf05a1d792d43e236b4815b35dbf4ebe36218199e663486b1fd35c98b0707dde983f5fdd48dcf37d8fefae69e42a678e8ecd31b495c463661a2140e232f3619b73da43837542caac5c42a9e1742fab10030edb396bbed3600e1adf2eedb88c7584b96ad6aff29eced77877f85df0b1f5eeafc58af3592528349ea95209f275542fa83d6a453ebc2f80f7f3165c97c4436637630ab3694bc61f7d79bc60ad7e2f25b2ed4d44f95821dedbad75e85f367340ed6d372adebb939f0dc5645559e587aa387585976fad4a4bd7543e4b000e25872401353d5170eeeb0c70185980eaab8c54dbbfe8a9b547d7186ba0b4660d3a6e07b2ba0341d50a3b8579e029a5428c15c650206d3093e9a6e787fc11ab5e07ada6af628b3a916e7694200b81980676abd6c890e0e28aed812a8ae3a115b991cc98c1dae267d53bae35a6628d1d161e9ed76d9e72ccd7a2c4ad8990163ff46c56eb166857014161c9248415c40d4ff6e3d1cea6fd4d7343b148ee624245caf177d99d7bbf084555f06bd2027044ce0da405eab9001594cb4ef95cc12fccf45bffed9c2d829a7eda4304a8b035a202139475479d9841bfa9a42d2aadd7809ed707a5e90039bda1d97e7db6e06dd87f7117637ef28fa964064181e643f4dd678790809cc84b853048c525ab60e9817a7e4ad8d7fb880464ddc9c228df36c12eeddc3d518fde8518ca74095323574624086da486bc267606e20972a00a8e8807b8abbb44a32800b7aa5726dbfd2030613196570bec3e2fc329ca32377b1971c6c2139cf40abf91a9261dc2be7007e8d0b218b9649791b73e70b9754b09f91c5731666e2aff2aa04c71ad85ba663cc3aa7037ad883283ae2c9f85f5666bbccc52f6c6654bdd5cea37722d9cc6e5a232537811b2f4d67eeb60a177676416c5dd59c3a7a48c77fabc27220ada94f71062cab7f91b61bbabb4ad24d98332ac06122fa55b1ae1639a9d21efbce5aedda71d25b302824a24ddff1e609857848223ca2ea9df4416d53dc3932b462a92576d61d74e63033075ae318c9be512f7456c6f662ddc8e7f84fca1b3a29dd4920206fa850bf305945b4c7aa26891c44d5709752d7dcda2b22fc4b3634aea222f74288c6f1ee2d163b4e5915db881a698978aec6fe445c3b40be144ad25698f979a2b05e454b040463e8a9301f5ff0077445f9e70c04c43c7fea65c6710591ada98a86752716f4cca3715fca3f762481cbc0d75bfffa4c3ece76d3deb1b80f104b9707bfb862d768c5465ededa0fafb4697114f16e99bfe76ce39f2164aef2f175cc8768ff7c835394d0a840a13310cf6c414fd1409bb80e621f82c099d03e4aa0a9a15599da29da27f885a510b3e59935f2e04f97f16831edee6b464299edec2d80d348bd60804746a0d5a91090a37ba3010d35d9cdd72eecbc5f94736e6cb8c275489d6280e8d08d6468769461bd7eed5b0b1ab076995d28a56a35b7d326a1f739f9033a44717b3cdc52b518a778e1bebd4e0c47f17fe754c4fdcd68e5074a5000d4f816ad8aa2e2476988950068d0b8657a82d079379d383de9185a8e65b8ca795bde2ae4dff0668582043a7aed4afa823b1b35c94d92832531cf753dcc2dc9ff7c2633c4c2b859f55ca3355c8c42e7fbe95bf99306f723d3c5566809424d52c16e22b0586fa7d4312b7710ffeb54f2206e494fd2859872cb0b644bedb53d5d4fb0d61deaedb9eaacf54e4e2923645d7d1a46df3cc2930d9d8a9f3f24c63c548c0feb618240e512e151ede84a6442154d87b96ad0919ac1a1b2978c9c7c6298c352dbc1a619a97cda72cead93e41121dcaa1ca192bfc492760dc85b52f78929c2e27338479911eeec7df5873330f5235aba4eeddc01756078b7e49d320cddff4bb03f176e6761b421f13583f61f51b83534a364096d6ad17a860eaa9297e4b3c8e53d82fb310e95b09d89511e1713d40fd496c8a2e46032d336bc9b945c38a78a34425f0a93447d3b4b936eb03db74801803992766d0f60e84535c62d7e77da4af928b355caac0ff3bdf81864416ba0c2fb2a30c130dab77cdac89ef932f4483ee30721f8b874efa58e1b5bed75e394b19dda061f111ed51f7f37b8bf7601e9d9628133a987277c27032fd89ad48462ca69bbd8beb2ff1d844c693e2e965e231e60e72858f07247eb5c9febb69c6dbfeaab53eeca6d1b69d7995f53dc5be474bf29351bb180cff7f8990e168ec17facd33433aed5358d0d96ab86ef730f6e6d2d9b2676339bc76a1ad6cf4e5df504f6b094459eb7dc6cfdfce880520d588fff15bb656e66e24c640a37b6ac939b0b2609ca0a3ec0615d1ae94522f397c4e3f191b270a5222a03bfd478800207fc55b3c2fdd26a41713c5b8c55b73936bfe67a0187293368e1bd9ff0531d17845ecce6c55ce3b1a8ead429f37eb9b000136c301bb1fb1cd183243ff5b7a6c88d77fafe69f0969f7e1d56cdcca0183b43865b4a57c054de2ca2e40a9bc21d96ac0411bcf8fb7c66c2049433e21b6664c0f30bde6bc7fe226ecf00ff3d2f2bfb54d97aa09ec0a6d357bcaafcba32917d04bd19e2eef9ade04b4c7f44b7d7682e5879f5d527dc890fa121db77d9dd6316104dbf9b740d515bb09ad474b117ed663f529469c8ab009df9b97643c59c167a8280f76fa2de90fecbb80c9739e40c5d07bc1d3e1be247c573344985f5c77b95d00785d30b1f776065f1b4fdee07d84ca73f36a1119f7c0e4573bef253454b400a3536ae04b72910080a8470257f44f535a80ef6788e48e89175f85b99348f9d3919b794c2e3c91c859803413c2d8fa7369a3cf9543f281b617e448e5c52fa14b68f29770d2791de66a1cbbef88a09d2fb0c7e7d25a1a57be51e6592c91c6a1e49197bd9efc1ae7ead802881493763df6f9f67d85e92705acfcd69588e66653ffd692f0b632a5d853bcd2ea9335aa73c27709a7d3c008478cce629ceb152a0011b2a6884c0777dde96b2d32105dd1aadc744974bcb9337022abca34ac3de8696f71db4bc13fad096115ce93ecfb5a0c9994d2f912d7f8394cf73af8940ab718a21de2afda0a4193fb6cf58d74155bccceff6b4eb6b2c5b7e228f504331e4a6ffebf7986a2a57d17ac3bf506525ca0d5aec2130241db124075335907dc7de1f5e817fa37c683459fb2c9107d8481c659ac3b1c2d13e9337bda93b167b17584c6e1f02e83079f575085c6b3256febdf5afa8b34245f54d1f719ae079481cdccca94a06d388a384a7b6e1f984cb6b8d577010bfe55b2d8f86c241a3609eb0994f23f7eb8706c6ab7bb8c37647f06362b2e2ff90b9a4977886a53c1e512391474f27a596358aced37ca25e1e05","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e82519663a5fa0042bb459c99fbafea2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
