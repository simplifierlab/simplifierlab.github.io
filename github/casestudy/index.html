<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
        
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8886655e4f913d593af49103c175e095392b3e6c5ae4ef269eb2f525223449259f38900bc4d9dffd49318faa4609e68339ef8e30919bf5c15f44567df09467dc1e240eb85ab6cd7aeb13237cf07b13fd4e003f3fd369a9c27e64c1bd08302642f49d3b7182f6df01b0e98488c7cb3fce8b31fd77ab35dd48c3d7358c1689322f9846db58c51e86abc5f1617d721867172ee0991b8c8ae1b09ecd4e25d232f99151a69121886b34ec32bc3f37c01983fd4b43fdbdb2098731688ecd95ad139f92e7a30c6bbeba7fe855158078c543d954b93d1b64f541e79c8375c20f53e8ec5a2ae0488c6d5c5874d07c153be25d1aa1598403e9946e76c0e6ac4307ad9fb55e21ad423f5db96066072265795c56c9fd594e4eacb63c4624582f3d6977b9be33c6d39fb9a91e4ff9b4fbb1c0b7a9f86f5011217d9e21796807d921548643b33f03ffc23fae5980023e85b5757cd34ac5f00873b1d9c184d5a277e7598423e68e25fb98317b6817277d8e0d0a2a4d5507613665c1ffc60498447f209aa9cf3ba48ab1b339d3ae7ea5fd1292a78d60cc2a9b71fb6812ebb4679d8614ab608b2232e45b7df379286ef0afe388df12c77dce56f386c1e6adc19fbca613e783cad7534422d6088e8d20beac8e97b763be88b81f6bd73ef73ae215cbf2f6a6ce43d217c62197f940c2700c28d8450b30da77c40c315325ca034bcf44a13c2fd28ff241f63e46ef49724a635e936ac2f23b5e4def8caf2f125c4fad00459e8602f6f49ff1c154a944c16833707ce66986e88217965913c9e75b77ac132bb80193abd36da51bd481d92a03295fdea948d4dc95ddf8f4ccf55907ef3f07d36fb3fd9577fd0c707cc5350378c308b5cad027ef43ac7e9265af8f10da6aa50132c825246549735bb7fc841163dc9f024911e4749fbd0c8d026f736d5784b5bf05092d0beda5dea243028638c4a97fe4e6b051960ad17aba58485970fb24d7274d079ff9f914fb547631be496e920fbacfa21ea267ce8667fed895ef33b25ce59b4e0f7ac84dd3bbe50999a237ba12a687bb86ed3e206d523f0ae209f9b0c9d4bd0bb9e68040abe9fb3c3c958053f3852cb95d7f40c9a3c78bba3fdb49318d742197d272a3c313a51cfe94c64a9a35ba3d5bfbd5032bb33eeba38c99e9cde35a56cd4fa18eaaf14183282f77ba0c71f62ee63fe3e58c3403e62630863c5702be8856316c3c92f2b777a7b048660ea78d9f342e5e5b7216a5256d12c3c556423341d209e2e6a77cb2b79abc19e55c52870a1b34b859de5dee9be5189700b44213dea6a28cff3a73014454890146e26378cf4fc0c648522a0461e44f29a4e27fb6c812548dea49218fa30fb1debd828d829efb0869e89431de455c61bf63df84d920d1540a468338fdd19c3573331c24feb02766fe230cc1c160d967cf5a48ec7069af64ae06a836fde7d9fae315c5e63f9d3d42cc5a082d16fc64ca5d9dbdb01c31680125fd1cfd5429ae028b958f849fdc1b41f7515f2b2f9bb81a049b4b1cf2cbf5d73cee308c7eb84d3baf52c6c336e8b7c272096a3833e3d013e0c4f352b9ad417a9fd1c3999bce560fd279ce7358d2b585d978a9993cf39af4518ec1cec206757518d2ea7edfbb83a43343c761b7f631670fd5c636a5e2b61cc50be051e0777aa276ed35c3d298f2ebb660475642915999518698f98cf343d0fb4de8a2f982046d15ed707f0f127c299325d7d646d720797d07bd6890747049de1bb6d87845b5f057e51dc0f6d850769fe332324c233d9d530f7bb5d06aed92fb633ce5a3cd206989694fe0431cfd0f2b5dcaa782a1d47958a79d0cbda0580cadeac63da132f5ae72491d556ab3e1b41bd384b8dbfaa522af1f785b3311f0316f9d539d5ccfe6843a23e8fd3f840daca326fd6fb8d2f17cd72656e8975b333e9d5720f8ddf80b1c37a409749eb7e2be1a930eb3738ceb0b28f8a49815a06d4c53ffc73444a2d48484a9046104e3758dac47a025f8900c88ba0013c3455a4feafe958b5a676443097d647fe510e191202593dc0b0601cada724e2d0652e27fb18f4b115961f075c2b1276110e9669641caca63650cb8d2970835e30aee668f8962c6e319ec3120869a111ceccef1deccb96f703b1a3f60c25c571ad980743a0553de94063ef4bb33fc6d88aee07da96b8a305b4655f01c3bb20d4399ac634978c039a9afb118bfd90147ad225b8d283f260308c701cbd418c942b24153a58b53d59e21fd0db883689f21e227db56c3a672adee1600912763724baa080a1ee6cf15972a8e25cb3a466d94c1f34e95d45f8e7e305d52f7ad2a9d13aeba031ea464728873f5dd178f9ec626eb5867c27920447edc5c81e25240320c4c052f883bcb7930e727cd428702e0b1fbf114509daaa36c10e6977abf3d3a15683387e08d20141c3fc204674aa5489159bf38869f412afc8ebf14e90edad58022acc9b64ec0698d7d5828616bb2f56b6237bbf3f28048432eb4e07052d79560e55e09ce9f57f3bb8da4a98bb78ded1461d34c6bc10d3a8818faa46222c8075a68fbf0074634818b61607f2481d529cbc2c5ff4810ce4304f51d20929e4ecf59dbec81b9d6fbf4047a0d8e7b28256b2472c5b9f8db3f2ee6e2881c10a8277325551768fca20ad724bafa399a840da44b9c68747624c95d20724c4c4cd7698cd515ce8392d0080d14c0bea0f14b1e15616702d67f45b732f500f2feb706959b7be3022f5fc9cb7e48482f3941ee0f7a9268e60dc1eefbf7fb4e3173e1707c8c35daea7f1d0225d09396ce99b1cbc0a101d5350b9a6414e0be1bb82254bbbbad6bfb9004c2a0e49bb4036040fd2f5f9da03deec8568c1f046c6d627d140c2a01c7923435e1df1fd8e276e7c0d18e4108406b5e077d974193f50c0acb95829146ef61718335708f3c2454a6b5d2f3b23bf8416757c5ca64a1c0382c4628a1e8e796b7f1d891a41c3dc4fd8d1d1b6c94bc9e7c5bab6a06241a86fbd6191a314616ec49acb849645e458deeb9b46848569ea657abe14da9d377a8af211fcb9c074b7f93cd120655c0034c6449cd5387cd461ea81c6a977a17dac8fc05cd8dce7ef5524866403a765244c5cb8c3246ad49927d28d3d9cb9551ea1efba62eb189141f04a4842bfa4aacf7dc3287cc95d5198e7526e1ded43a4b0bd9b92c0ea1392b3c4a1ee3fdb7f23a25b0fc52e94a92ecff8c5266db0e194af30ac3a2ff947996076f290f102192baf0a2205332c9727815cbb8fcf13d591f6f90bf6d6390e7f6f7e76982f5bddc9e7746601b5b84a7275e55f9850794ace64c21018b8812fdbf136a964f964500106a515498b82b7b4f81c42a1d14a3240b8d5aab6d4bd0654972895d619accea2a37d7dd6012a80f937a6316d1912bbb800bdc5fbf0e527f2a961832f3cb5d7f652fc13e10483ec41b354fce69b927485a2aa9cd6f1079a29ee071ed9b8b2b15cd5e9ed53d15e6ce5a181becbf05a55c8de5b8c104f1c35e18400a8942fb75b6c4384d596642a5aa91d224f69e9e416a7406e5081777a34cee5378a5e80cef2ab19476142cf8088abf0bdf01c0c51fab9c1214ce79af4d9721cb9d7160ac830680f69278d32b2b3d1334b9bbc6493e2f4e5200d15b93b3d1a0954d02d8ec517206ccadad7ff998013734a03b5dca2699e5dba6859d1bc7b72690edc2726e45bcf660dce9e8487ebf611ffbe2f26483c6fbb1fb0f315d4eedda5cab62d13264f1fa503ce09924b59689e781450cde6f970930d0152aaebca780c7e1cea585217a67af78c625313e0fbf873d1a6c709a9fa288024cc4f84085d7dcfef74b8844c36f48d32643ba18063fb31f91bc31c83e5ad5b0d8f0ef2bf5c526f9b671892b84ca1c585d3e687f7635d9322a0744769478fa98158ddee6633e792d99b8e053df2b9d5b00904b7ee6ae38ca2734ebdc7b236bc8831461ce0b5405ad0be1e9c83a265ac13bf9ffdd5a9397c18c0f6ff7e4cb41c37476ffc83a21fc35ab2ee7586919c02602ffa25b5c838f04914dd81df8a55018451c27743d3c00291ac6e4a4841a810227417490a1008c3a2b08f6cf972bfb8f6a754bfd3a5d4cb61217bc96318646636a118d872f5d2bd46d6025bd00c9b342ec9e9bcc4660173f53cbab5290de790a1fd0797552d7af939391720c644e8c3b0c4020be26dc4b43e1c9cd4a35f32a902611e2d0f1ba5f626cb7a443820450376865221c2b73a92bdb42151e8f49b8ff91bc69f245ae9259407373d09ee5f935d4eb00f83580a354a7f62639dfffbf4b18fd379f0e8dd1fd2a4f4908a3fc1b255eb15414f684d68d7734b845ca160757b703791afde307d0fd4955a7aebf298cd014ebbd0cf0cda20f570b49e7a07a76780a3d737b47b4f51a39b2681fa0d96ceaca8ef4d7df966e27b628b31fbbc876c936d3b3bf950ed6822239e668998f43073c8dde5b7608e5cb6edb4ebf4930fbe465de0e29595abda51b1bb1c80f8e1bb5dc63eef4c58344f1c5f90a5e8ee2db2c6388358b310ad273c318e477c298f1acf687f2720a8051b9bac089b759a3c1c07be78fc03a36604f1f2fc70a331e7d468c912521951ab8d4373a21b7d0f9603ab07725c85ce9f1ca3d96506055e737f3b8e4d1181ef4892facd2861a0d677d7ac6edb6fa8ccebbb2029cda3c08bee6d6b5030d6ade29b5e3f285ae4f0005dd962d8d8d5571021d44ada61b980aa07b3f5e4ef3e8b8593e18a74b7aed4ea102ffc077ddf1de8d18f8de46aac1ab25fef214c2367259db99a4973a425d624976ddf7a1dab4c8713e7108c748b8dca6256193863356185705b3c2544e193a8f96862059f89f8dbfe8b1046c7ab0827686082742af9bd0e097dc172318fc5b3a7b53981a929341d7f76ffc14763237260934d6a9c016da017eb3483a037a0a15a1db0e8f36ea824716561a46bd5a0268e4dd0a8ca5723a697e12ad273f578f1a5d587808de95ace160ec7a259505fde32d50454a7a8e5e5bfc355fbeeaf1ec3c0e174971155d5e2e159169257ec7ebdc2945b0a88495bd8ff651a390700f5b0ce0bfaff6ad9f9370b84a114b53a9c76fce0ab676d5b70cbcfc2138afeda94effd2b570e273f3b6e5b4647c78877d6e9ca166b9420a9dba392316f1882dfa3df2ebef941ef11ba269d227feaa3f61fd8429201e119d4cfa847aabb0cce78b530daa1bd4450a4cf24288d0f89414dcb739044667e6b09366d8bda8239bb06ff692ee8ce75d0dba9c90be2574909a51895cb15e6087a6a5984cbb5d9de8b7fa58d1730d74970ee9572ce89f138165d7be8b701b7923d2c3d96c3be5bc0675e119addc5c6cdd86d5f5d86d13e3441dcc66d051809f94aa9dfb65d5c781f3be26547c4de526588d4e5788f25eab08769107bf8e85bc080ecbfe3c6f6d0c8f02f7d835636c070586287068db715e4b1df215f2822ca4a8b9aca90111d20062eeaeef1d28a27f56259f78f5034f7e07e6fc7f47dc388a6a53cf5b8175ff85675471e7a9a4a535251a7c2d20c137c7fcec6114e33cb2cb6a9ec11a5bcd4f0ac19ddd90383afda98aaea1bb53d6f2e8a8977c9418ccdf88b2b9f3804ead18b0ce11b8908eba1f5738d03a3744c197613bb1b6645c0a6f30d284fab5de4c1576f47317552ea3e58372fbb3383624b4f21ba624d051825f0db3868665c777a1c716a701d174ecdb69890f4f330203f22512c9ee7712247f7df03704b957c21be29d34823d650743e5d7a923caf46d710c0fc2277e6b52093723ac7e845dee174e138a0d59a24238fd258081a959cfb781ba1a2c79a6407095afbc854ccc8eea45b83a7ede7f1abd470efd84a79e1ef8a7e4b91c2b5a700b3e0c9476e6146c09999dcf6c5b6a6b2edcbb03169de53f6b8f124cd385f41fd7bdb8d29a9c082eb2c66464fd94e417ac33edfae22a134ad73b6dc2a3880a6a29b821fd106932dcdef32f1703e78f55b805ac9ff4840a55fa10d4a7ef071cb3d2b219577507177e7a2870c236d1d58b95e116b5b783cf1b59216a582991438a4cb713c829a494070ac34280916dd5645913dae9fac203570a53f9c7c9ee03288ba01873388e7411a86bc2820b1ce7630684fd2b801fa0948b7c83651bb5ac762a9027236593cf2ff8e836d858ec9f5d606475c2e84a5e7cb5c89f05e97f21ac40806732910467d8b1ae36ce538208cf6ebc9b797c3c4f0913c325ee94c30d9fbd8f325359163b4b3d641632f17f97fd22916c16c15fac49e589dac7123c41029fc7061c0a10013efebc3d0d4bac4c604c228a855c4a36da338bce378ddd9b70dddc3bd47ec0d9c60dc718893c934a3a4deb7d6eb4feb410f7c6781b46f77ea45d3329554af7d010f2e3dd4b474b1032bc5ade58716aebd8ad751a4aa0cf67b072fdca558a5c84d9464e94c7b36a31b4d030fe2872e649d7d54ac7a202604e0b7f56fad74fdbfc67bf259095ecf1f4e9b22e37bf3a67ff5df7bb881fbc3a6a896dcafc1090d0308b651eee6c920c25ff7fb0efe60bc2707c69f1deecaa82d40b53d9d386286ad3ada5da1e91c6eeaa290cf270250976f4b7f9f32e12e581a5eb91c7b52adafaf15a51c18f9a6f2877a41c3ff25cf49092b81dde7f41198bdeebf064238dc409b17c31811ea1fa55701b5714bec2a58a35447be9f95290e49143f0a13e261408d6420bb3ec80d7ed88cee8396066ef35a386ee6c884695306cfa9a0a17d1e8bd84e94797b563a25704bcd5fdaa4453065145fa9228c6394311b17bf75d4c2bc4193490f66772a051bdbabb5b40e251eedbbf608f4d10bb2a4cd19c6fa745de3079ff1154d58645ac28c42edef7bfe7fc257f48a6dabded46c9bb82e3404790869b80c438e46dc2ed904e299d444a1df68f1d1958c76f1ec63f6be99747b32442ebdfaf6352fa881a46441a4e087419de9566494f6ffa979a4295300a9c6d0034cc570510d373b5ac589511e87e2db897e681000063ed17440a6d8826bd506a42ef9e0269e2d55303cadc4ad79b5b8277b077d99e36023829eb5e1fa0bbe4993cb8b7fab4a453d68ac806be00331470be73af91385e54917d3e6314375ca678bbc5543af1ac2bd2e4c8d923148e069ed9f7030de4fe1540a509ea272c8e60ef2625f705b66abb5aa3ee625fed25c15676f549cc30e08524b31d6d334e19921cae8b59f488060a2ed2d7ee963e22b66660c8b4bf998431ab245c2cc1302cbe41a73d04b97694086833e913bf3104cc6e05be3a5bde5e59283d3e11a092a84e0a9baa6a1cc3b7d154ee63967235cb7c60b313a97c82ece58f772f27179ea14fab61fc7351598f8dbf05c83934269e353847759e3d2ab46a31a38f64c558d1f651766986cbaacf0feda747b0a8e1119432459bc2b1d615eee1203d2df62aa45e67484304b0c5d7376f46cdad4f1a3bc84f2696c40cbebc8327d7386ceb2d91ab4591a1904b8fe794d295df92265a4de43980992505ca882021807c70a1b21610723a4179dc4db84d8d634cd646561afb863f1eb5163412ba95cf1dab3a012e3dc2f31c1ff922316a2b839b17ae5593f5ff2b42e8dc78fc4e347bd41eb19f7c975be4086979dfde5f34fb6d3f0c6d781148c40e3467683e4be91170ba5278615aa439fe9ee249d24d7278db3cc1b4874d5a54dc8617540db31408f524930f728bf906d2a18f020b6af89f2fc814a77bc3ccab34af1638401a8decaf4955267073767f66544436ab0b2c83f658ef21229433cb666b5ca4a7d5d03b3bd049c6c3d61ff6253c5ed4e48f90a672a1e8745517c8fdaf931dd149e33c01dfae5205cddc146d1259114d289c6d5288eb937f0e7a34739b41083a0416b839c3b808b5b89c1f14cbbf1c221ca674b7cdabbc5f5f46c1dbbc2f8f243f5ba5a207a61716918bb829a28c90411e358c7648205a8426767f4f1930dd084f5280199be708157a2fca4b4bb9f2e0d1835f943a6c27c45447cee96b08d97046659b19fc7dfedf8a234b8b7b9ad8c19e341b2e36d2fa0996c63d23978cf499d9dcf39a904c4a0e679b8647ca450504f95676379fb8101ce96d31c376b2d5ed5134fb01978d5d43a8875995a2bd9e1e4cd343435a8c44a29233954bb0b0e649e335367c9d79f5fa30f63abdf4fc0346ee0c9b0fab6bf3e25d4d223bcc8f5daa53282dacea5f3d674bc2937882d5c91fb5acef00233ff6ff70213f59a327493486965984f4fd749c0dd886ed0aae4e9471aae9d0634bf55210d226cb8955ac70d360d2fae10b75778ea100e5a623ba85aeaa163b3f21d0a1a75fabd538b64c20cb1e340caee30247bc68858260ceafe13a6fe5bdd050a06712bc21482b8206456417b9664a12b468f998e4343968a1e7a58f8a4ad514003f99a4b45b2fae448ff19fc2b29671b2ef1a0d1ab27708a90814c68ece85e943e1875fbd0006f7784439ef23020c6e1ebe05252a46017532f5a527e31cdf1cddbc98e103aa39df871565a6d8d76e0715a7aba83781f1ce07e5d063c825449cd813476a2e963678889bc733277b2637c761ef9cd456dbd9d9956de0e769bed4e21de6a6946b2f071f7018620f994f22a6d486732d28652ece2e144b585fdf74110c961a3297ed7c6c0a9072caf2585d9fe3ca7676b93100a0bf4ab2dcb65233a36b7b8306d7447dfdc2652c58fbdfd21cfd4fc6777236a9bf279b343a2d96ad08ff369b6a136283b46ab40fb635e74c7f18dc371bafcf84357d236fc8f46f57ff6b3665b8eda6871eb12e3a6d3477b60dc043843fe6370157ab2ffaef9da18316984bbb6722e3a2b304eac9e89e77878d3f1b4dfef887202eb0908488c14f238a46634c4557efe80d7edebc8b403d567c86436c4b4a690c090b6d94104986ee529a1c082a26e3ca8e44e25f8a4a282910dfbe345c267e511d1ccb274c2c5db0f3a41403ca73012022a97c1aa656604d95e12872c3ac222c9c71423061c74c7eb5888f3c84ff9d401ee2cbc8b325fd3fa7643c1f17b4d60bcc3a40759d02b87945e939e03004cd2f8186f9db5e554047a0af5d38641ed1c4594f4c7d9529dd2517d981537d5029e7ae2b2b8a7a6399f652e45a32a5e238c7381c0d773fddd565ec7e3f8960124c03179bb6f059fe94b9b60fc02608822a47c65b9e42d281cd85222d6b4ef70b84d444a70f2a7a2b63be684daa40cd61f134f193532eabd05a057920ff2a41a7938cb4d1a70a9f8dbfb1db3fc7b5643b810affa162fc33521a8dbf29ca85b7097bdc50eb1e643972d0387bfc1964fc3980a910c5973dd6bb823b2e603c1eff06153da3cad99b9022ba8551ab475dbed627d3f705be328cc7683dc9a6f60f75bb137e9dcfec17d03749484e35693df0c4eff1b362deff3e476ccb09b9c892dffaf5b0a1004170bc8c1c3252fc341352f962c662c5691fc57167d3b8cf115e45c3ef9b0aa13801bd6ff6fd6c63e8d7d3cb399831d4a53ae35637bf8575a4339f6418006e89891bdfe899e619d6d2d57f6cbde2774b882396a34c7dbb033c0c821ac29d73d835d2c9bbda121decfc4e10dfe5196e43c39a3962f32f434d46569d9c1b71e1d228446f759ee44421ddac62c781bcf9f4b50f0c98d22f4203b814ef07d24a90ee52f072d7d80558db8e827c2cbffeae6e97f0175b3a1846fd151a16cf279c95eee4f2e0b67c3bb045bca66f6c822399f5cea244a00fe07fadbe6f20ed4d16c509adb83512387ceb8a13ca71b75f6b65e4c3e444341a66511dc6c21c539bcd1287d302979cfbecb4570056b97eeaee6cdd220b661c3989840d64447c415f5ba6044d6b18fbf4ce7770578bbe6913ac886264b06aef8633ce7e29227b516e92f362fadd62c509c73bae8200a5d79c6eb125527ccb20ea473878ce02578b612431bb1712a184dccaf986bf5ea5b89c9959ca67d5cd158d68829fd8efba3bae7a64f6ea6348f5e5f9af4c1738253c635c97a675621b267000c8a01d59b86b962b27bc1f12b858ffe15d2ce6309c0201fcabccca6290d058257d276c67bf3f95a23b35ed1a985cbcb95c3ed13f78a26399482133b7d3a1a81153c149b038814701a657ab599156e0a5beb1a8d764dde7920768fd4a27d75cdf2f5c4d98510f9394e1ad7e86d0c66b502b09748686b813f160ec351e3203360b8538435f0a5242ca70f3fa5ea4b69d589cece7c18412e8da08250dcdb0a7cc25c4a9fd745590d1cc5cea151d87bea42d1de0f568377ad613dea8aa64a54c2ede96a30335640e0486d1b84c6c6f154c5bbd8d4348126fc92cbde0ceff5316f43948083fa3fd5531f739a7e5a0f73b169afc6d21ba4611d7b42c0a0293e61ef9b6c1417a18d484171c56a448bcac61d7705a42660ba1a95f325d8120fafdc6025ce7e0f541f45b425637a40d1dff49454d6053145993a822df51b82b0646d4d9f07f32e2fcc1c2dd278b122c0f06f526f72618c81da45e59bec7bbc9ac46846ba8969e8417c23817a6ee493097924fafe752331e59d4e0f523e3ff0137780ce280f5681599129c9bd55eaf3dda56204cde25211512f6e34301eb1e5c9cc0d0549536cb7797515d1c3537c346dab8c4eb0aa968991d1272e9673c9cefab61a9503dba176626aad11c8bcd924d1e5750459632e76ae14d3bf79dfa4cc24fe1467a44a0a7939ce74aac4b6be1033b63938876b06b6b798502402455f40f466ef8b5704ed0eca6b067c32d52bf81189f537c783c62de60366b633867133e181088326fc124a2dbbe16e873112ee0cece12cf529658a415dc8294bba353d8251d8ada250e5cbbcc8c2e25c0949148585850dce5e81a3ab77a67e7831b0fca44ab8a3f9ce34e900bc7dd2fb67862f0d89246e5ec72597a945a44013ef8885fbdc997d49325329862d778b95eef85569aac461ad59effbd9b287733eab41b4bc2f00281c2ed73cbf4eb4da4808172c3a97ef62aa8e24ef5f83ec7b6dbdec230d989f60ebceaf61d9e4aa36997d5d8b171e2534b38467539b0d51c90ae00c6395938b287589a5543b0921164e50dc0faf83f810c49847429705cdf54962416d98a726a55a97a2a00a21bb6c8288343b9e961b27a83334d44040dbff4be79312fe05e525513597cf2304311a1891acdce60397fd50d5b0a28a911145f260da4adcda402a454d0df8260fcbb4e0b88251caf1d538de7253f9f6b81510cf147ede4da2d694f556bc98a9efeaa5ae57ab8cb042d61fc185975a14978148fdd020b4b3a7559ebc048a7ade431abaa35ee38d6130b45aa96270e9722ec51d6bb9df2d3776e9eff93902d9bdfe32cbe1bdd1eae10a3d35777d38c6ccdfe6af2504edf0e75114316a08ad68aaf2d56ad6cc9a40fbc2d8ca873d376c39a9840ed3a997aceca0156fac26a2eaab0ae5a7503f0e89e3635f859de4ca3a837d1d7007a3cfd0387241460aeb4b814e77c214385496cbe63a2c8c46844db996e2a032788170db6de3bd2f90892a4dcc79dbb35da7ef5972c3c8ff27368ce85439f36df74bb76deae6ecc5d5a0ac0ea67e1a026c30f010273a3245338484b9bc37ff273a0c830070c31c9254857b5ed6b27d496a016437becea96c88bc413be6f17b5e57fef3284c992eb96bb58b9652210b30e83beedee24c419daf477b790b6ab4ee71e388317d7b2f1a295bc5b6335f62986531df3ec1b5ee21a657c73e73f0966cd842c001d668c4c7f47903188f087a8c1d3645d72a6c0e374cb1273f42cc3e3e9170af376ab1f451d39cd127cf77645c4196c689b10287b649966d5c08be8322b845a5710678d6c11ace71c8922ce7806ee1cbe8ef6e00163bb04ad2e5fcfa9ecf5128b474941f374c1620a0f2b17da2c8937fd3896e31f13a1009c5be198e4736b4c42e0c3e2be522d9f17f068d702a9afbbfbed3a6897a9f3468a21174ed42895aafb6380901bd2db9f9d39c6b513b2b6e4236498f1100f5f4bbe1a6cc4e1483f4f5196fca90ee4eb3e0c89e6b49828d161ead510f3ecb7ef28d895409e46158936e9728cf4e178948dc059d295617c9ca60502d43a0897af694e950092a4bbe664f7544252f3e91fae8045982e17e305ca8542a4f9b020292ecfd52ff53493fc2a0b949d1a8c304c254e8bf60c123265541e59743d27b4d95945d9c6a70d9153e79bdc0adc5caf3a3e7e20a90f6c98dd0221715da29779584cfab669a5bfc5f51b714bd470cbd93f7bbd816598077f29b3a71f6770942f870f0a3c3bac1434bd1e45346dbc05d7054cc99610a11e89aa56cfe7037d1ab8fa5f6459bbb96ece0ce4210b4d557eceb5baedb57b466f7832a81325ecd5b108babe1234d7fe8ab662986e1a002dda506962ae9cd947b60586d3ec93af498c03c59c96cc40fa72ac8860e0a5635f2b6bae14979ff31847ab0b895cb2654a5a8904662da2fda054ae6b599d81ee466f7140409595e431188378116fc6f05bc60b31eaee14c6872026c0ea916aaf735c42da9dd686c5e35187c4a88396e619372f6151d1d0cf5a2a524cf307cacea2133e18e3fb503a35de98a6081fe21ae664d4de4b507da0e6dd92e0cd4767155910a04773151f5ff46e9249cdfb0d29a8f08fe9b04affd58b93de12fda84f20ae78ae315c0df5599dc00293ab25edc23aed11bed78d2b673318f3001dbb1edc33df7af571c5cbdc2810875f45738017012a28ec17437d551a4aa3e6d9f28dbbf10d6b59a450b13954783576b576ad81db4aa6b6236434ca0e5e20d20f1e2728743de45fbdf48ea9d1d251eed5cfd4065194e8cb95330f74fe98ab0855d8d05738829d007b87171ce09af4717542b492ae88a4a945d8c14cad918d6f6567cce49d67e42b41b5495362dd839d1cb9dd5610e9fc8eb232625ee7968bd999fc59ea8db2d333537f0e4bd4d91df6faff0af79575f1eeb008b7c9cc2585b45de3522e964cd55aca4800d4743da70133584691c3b5e9cbe1427be441a560c7065b5db899a8b83e99d8b2637c4d38c74c3edb1def364fa2d46de889606f5d837a381ff33f09682eb88a3a39670eb074c9ec38e2714985ede90b909dc76207c16cdcf3b247de16a4aaa5901b97fb556e0e559f3af7d9909968dc828224a84a6cea1aea6cc316e6c1e9fcef8c04018fd5dc3818a8ff47aff91e2be97cc7b7a2dc562ac5f04811ecf28cc942d42a8779f2aaa0014d309cd105210dac900c0786ac79b51c64ec2e34cee0f599ee0621ca729eeb02c277360423f4f1c8a7db09324a520c318a9910064b32e6363defe51815eefa4848973aa18b13c8751b59203fd3eca3a1ee4e1c6ac33e2a866073e42ba240bf955f587e99b4819389e95df191005438ef299b27023bd7d64add3a9c95456732186256cb4e6767424162237fc402a0286e822508cde3a2bfe70484e00eb992319f9c087324cd182e4f21a272ad529390b2ef3e2dd91f970e1fb1e80691d47a39b9a39bd7d19f162d40bc11d8cb57eb1f980b586786d1e54a0452ded200e74226d83c90c7cf97b62fd7a917270e60b392d8be926f34538e7f65f426ef3b9f63219d2d3f4d64db110b02aa26cba525142aac99e75830ca0746575966dd880eb23b93b3146d0fde5fcd6408bf68ead32a73de72ceadea9b25a23df378761780599efec0b0302363a4db411cf6916bd4c3e566667275c0ef287529aef97f32e8665e9c41aa943a095889f116edd49d9ade9376078567d62b1cecb3992b9b609dd9340371ecfa9f133583bb3689c20875aee1e174662e1cb5f5bb36fd8ec5c6d9a5862a461e25aa95a968d3ae3e9751b3277cf5a7630b2e64c5919e99ec29b372339b27496291fed121083c82bea030cddbc75c05d833462d2bc37f81919bbcb13a4f69e56823d9be890c67a05f571ef8093a61bc5d9261e9f15ced83358a687061ee8d46735693d060df3bd1f05ca64987bf5570d2b7da3eb1652b4efbe6db9703ca346ebc17541e99cde6aeccc13aa9ae16381d4fd0ea5707aead416626be0805c29ba58dbcd64fe863cee1d189ea01b7a0d592a65b53e9ac02eec061d218da582551703df005a4b4cfd44300c6eb0d6a673171369e87dfbf82e8b37944fad58357d7cbd929523f52634b54ca2835a7dbfadfd223796d610952a3a05a222b63d2a9947703846280579db223266dcefe8190e34eb331e70c6c7b4f4c0e6550074eee3942ab1a5ccc60d220e0b8404b2b881c868a13ef2522ceb96194a753d3677c67edb2791bd61c8b76740cf2ab7a805cecad78704cf03dc68e4d5844f8ba75db31a5f8afa7adf195ffaef93c423ce667a5ca7976bd04cc82d23a95d31c704d705095800ec022f987333203a993c3f5db69a61c009864858e487953e853178c9b2a8691d4bab49901a6fd2350a1c7765f2fc86739a07dd00bfffbda52392d74a02874368e019c10a5dc3a03956fc3c14b62ef39cf9ded9496b5239db37cf9c43f7e40410eee9cdd9d604475681fabd0b2598ee58325d7e5b6aa2f116f602f7393421273aa8a5d49d53a52b0b22dc2e9fcb2e15a2a61ae88487d337f838689d0f91fe4a6528c0760bff368e739e8c47962353d3bb0f2126b9b5ddca5e47646f6762ade7e6c96c3ee0a53a1b2d2168cb495d60c31c90731013f1faaa268e5c055bea6f7fe08262dd8b32b9d669a8605fdd0c9b9f50c7d4e458a6aa69c8288e7260d79b4d7ac2c3107b0088a4c842a5902b05f4db171fddaa5c10ef7e744b5e60312113b9b1c0298a298874dee056ae303b48943716ce008783cf6294efb70ab639c5d008444d831c880a0751d4a023d4311c2eae1cdb971ee31d8d38f0d6c770e17cb5324b1e0fa8625cce588071decdf7e4a396d70ea2b1b1d8cd6895ada8254e7b448b3f61eba69d27dae50627e51f55a742579955824f3b342dcb1ba4f686a442b3f4ceb877b403122085142d8053c53bbcacf4adc66e6900a0fec6c43da2be9aa69d562ba730f6f2aae96d8d46e4da5d2d20463bd8226a68db2bbdb46fb66ce634586fa4104ef4d938e08325f180ad9a054b20b09a3e0a191487870efd288cf6aa7a58aae9ea7c69e30af3990cf85b9e6c6f2fce8538d16dbdf39fe5cbb5c25f6deb468fe3183b61c6e33baa3a97aab6119635b1319d707fb96f060b26c89e4f3262795c4c6e3ed21af8e5e7b3e7c7ddd6257b81c2aa9ea66cbac6465f161f73d6ebfbba1a05d1c55dfce5bca6c8d6dfc2b74d5f488932e871e4b96cc60538a85addbd485cbeb8d68d633a7afe1b72043690cb68ff0d478c49d6c2f8cfadf53f7a82bca99ac95005b2e20daae2c784e7d8e9c926fdbeac168e10bc4798cf09fb7afcf8a4d2006fd230f7145eb951aa6882f6a1dcaee9703f3d5413e2ba3f4eb230f1e9624b5a42bb1920b29e2e96a545c7fe6b0e9e6cee60a3787d3aedea0c28635be0ad5b5a87c790a4479a37d5fce8d65b2b4549bf848549692800bc4e9639093832290770db1f6dfbdd996dc2b8ac35134e1db9c19964a8a04c480846c4de55b02429a62bec37449485d01cf462e93d48ed2bb3deb2826b95a91f0fd9fba21a6e1ca7df0ab80f54730e4c7223fa019e8dfa3f13b725d117d6b1b1db62835ac0d2dc678b65a267b642286d4efe477e521780f46d5debf01bbe58bc8e4707427e6d2459b3d9e83956a99101769be57facb8028d69bc7e4c23faf3540e295cfe93d8bb77d896dc3d456615dbb21f97472f0185270e510dd81b41e528bb492e2818aff03d67328871b532124dea7666530d0a41efac025e923521b41a7f0f3cc32963e621c2ea54eb633e543f181ddd4b96978b9305eb0d05585a75f627c5bfd4b8c21a57cfe8b8fc4dd9ca4d91833badff729a8ae39a96655a287a6cdd74d1614a7c17f94acafbc622dee5e7d58553ebb832b0970dc37364994e9f9e1a7656cab75384a9e4a9701d8ac9080e3b9e08232f6c393f87aec3be8d486fb094a194a51d73220c6607d64b5230397333202c2521cb268c5a2ab4faa423e9e0ee795aa6484af680f302b158ae7d6e1084c5342d300294383a5b08bb9e8a7218bf1b27c333ba6e8d316d7896f29988fc0c891bb0979147c72f4dd6ecbd21a6c3a017d603e484ba406939006c3d1eae673d8fcd052011ecccfc80d9a8c55bfe18b070afd4f80082470cf7060a05e6074e64c80662d51fa8be41c37f387e707db92e1cd51f66033508df1ddd279a8e8635781c6b9fb7ff216cac23d315926dd5df9c276370d4952acb01951c7f33e53f64296a41bb61c83afcd1ac4e576a7523fda103eab0d88b530eea98eb273dc725025ca717882a1dbc5b274325dd722c711a8626b28d198bc031ad35e81ecbe8b90e5e01ebe306b428d32514ce0bd05531c4c5c174c505505216bf5f1984787ad74a93cf842dbab83eca5d1499f22dc02ac322d130e44e001bda573755626c013ff0e7d847c5261880d9d631661aeb5e17d3dca4cf6273b79b0a86df7e9f03bb1214e50e1619fc1e772c51099fd7c82fa24eff9075273ebfb61001936b6ce8de389e2811f6142e7ccd34cd53b483e78844334024b3601fa26bc9d4abbdb46bb3db5da73f5ec5aa2818b3a5d91e0f58eca09e2c2c1f25a991d4a8397ba114d7fcf4ae4459aaee165b8aa00102b23eb94a425e4fa3326c7885342866948077e15b08161e05433b88e838fe8a9573be897a00c3ee8c0db0f64190130f5e8dfcf11c21ecfd0fa9a5b191f71b3c5a311ae5e206c7b0c032da450a974f9cc1d2c4b7d1922a4ccae5ce2463f71987818789cd266b5a3208e93ba1c3bbc7f0fe9639468ec15ecd7b6b2354995cf944114b44399cd499387c445aeb1ccc916c56fea97ee32b653650634da76c6a85f95ceba4e9f724aa7cd3412425cba3dc913602eb32ee5483aedfcd990e5b58b8e9c9d2e3964c5111424d205a6dad759da0cd87ffcd84e43141e0bd60b87a0d8f02ae88f9d88a09f9417b134f01d7777f77bd51eca845558d3db64cd53278e46179013da708284e8d482e450815ac0ba6a597f246096229f69037b2bd508c7c00e64f5919d282b6ce401a3ae249ee00caee14a08690537810514b80593b8ec8322de3800cc786c854e61b4aa5a834bb25f19843a73f25dd5ecb31aef60e3abd80eee16603029e06dfc042b2e8a9e8065b12f00f8e1a50cc21a222824c04c9befc2553b06834d40d5196bdf39d2f6f90326ec8cf2910c7d36d0942ed3b8cd492264044ebd0247f2a61ee679c8cfbb3795aaa606339f55ab7f7b26f1bc6d7c04aabe0245b9c291c222da87213fc90c4b484b6bf2b42074166f45b71b50d83b4ecdf75b8c623087f44fb415508d97894816887f3a5b7285bb6d8bfb4a73f14a7229f91f9a0ba1b3d5400ee6617373ab24ee39b1a69f5f72a1eb5e7963da6a46940a9f96f67a868e408fd5e9e3cb46feec1379e3634c195b384e85f266a6df2ce27445b6b1f99bece74c3b5e9256ae604f7fb7e332f6713ce0dfc14f99516cc91255d6d85c7fe75423e7f36615920f2853ae2126cf1074eaa44e977e85ced62484a7ccc8b5b0613dc19300c3a7cbcf30e9b6c958c40c53744ec33fe8a781be135bb1610766a1004a3fc7bbfcf3a39e80040a835772ec2c20f0dd9c28bbb30b2b61dd8ac46a8bd3b6fba90dd84de561033bacd0f17604cd3a94ac354c1cb9a3e0484995b4e88000cace5dddc644c03d95c5f591663a08721d52dff676748917eb3539e0ddf873b7f1c0d050d1b6ac8656e4b0fee51735e0b83c251f99d8e3264430f7c6cf801faa6b752b13e9dec4f0e32b1235656817b7592392b7974e7ec13b158d4af086713f2c60cec25d063f5a5d4edff118db88928b695a21ed085014dc4f29e8215a6a22e2934123a03264abb969567b9211ea40bcbe03387b548c48e2a7c4d160ce8d9e5271da67357ae8f120ff2e52058aac8b7142f77ea1af7e6265e48c3e725ff56bdcd841411c033f6d24e29dc84b2a5b3accf18c645c757bf98bab2da7145ca731600e470a8208a5b7a7df745730bea84a5ce3034c7657ae02aa7987b2ed4669c9684b89e249b80428b80547c92226ffbdfd2e6d02e44bcd230420b1e60c7b885be90ff196787f99077ec87e825da25f3949e64da218260b8972a1a66b575bc1b994b3787045ac934c920192cc2b7835114fae00cc3d138dff71946013997e0a3e14f2506a7bc5286d824bb869cc719ec00fa6cac4b873fa005d5496d629c50632fb703307e637f07a3848f426cf6f9cc3ac011c463f4005bff587f560da1f59b3b72f4a50eac7e7cf78f2cde795966eff5e2cc0341b54e932d412165d2873289505f7702542dff48630d7ebbe87e5a7ec808e0677b37f18208b28c99895fa4342656b9e5b5e639b611274d0a35afe9dbb4415e0eef1b40b07e2a49595ab2994798edacdab50ced41f2ee1ae23e559c5ca39fa7578f6f0d359bed85e20d0bfa8ff4807dda18c55b9163e63aa8ed5252c23ffb2cc26a461e2256007a9b9be9fff2087222c66baafc820f6a75ab737ad2f6df2f0220fc32e62ac2cddf1f96bfe6460287bfe4da17eef89dee444608284c83b8969efde84df7c584e8f5bbc64b626606c796e1e7a9f67cc76f3f8fce21c75376d19b7789bf38b92d8e93f1dd2d9f3eb604468a5e79b852b4133e4e67b02e5579fe69abf2fcbfd3a6c43787b25d6ba43b8a639baae5d0d82969064a1c218052f687a29ea7722f23de686592705d93b23a5ef8fcea90ebb033753150db874a24744edd708ce3ae636ac10e00382f49129679e45b0fac7b5f3f873790502435d8f4f475b69a795192dc9d6745197a388326c6c000d0a37ac17bb9cfd0370d9dad284376696a7713e9419c4ea63944e8f387ca090d049965c4894fd6e59e8837a48330ce1788ad0c1c1d68f66f8692530289a263c8922a9494c05075dbd39270760e3afdbd1c40425d2dca6068b2b38eaee79f825297386b7f8912edd07dcf6fa1d6ace5b98e55345e399621379116278ff5800eada685ff911a09c25792458722cc6e2c05592c7df5187cf30b485c50dc9a0b4911e63894ca4bdd564345a065546ebeceec10db05d","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"4cb900d8e97ea7c3adb15949cbb25162"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
