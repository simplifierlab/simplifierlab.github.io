<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

               <style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
        
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de3073e0783708be009569738586f4f1dbebc7ea230495cf6283deebd2d88dfdc51fb22e433f28461094f3054a05af98ab223f880429e2c8c74e0f222467b52f20bf0cc8e6a86bc03cbbd529e48b388a22000065f3523fba6246cb4e230d18163c465375cdf674b53b94a8d221c627cb8f883bd0dd566db5959360e8cfa81ad7ece0d6f8d7f5d49d0067acca7723e7f19e29149ce173fe7022785169ae6bd5deb5c55d389b3e25b1a94da9951abf6c0d5116dc331444a543c4ccc6ba34e920e49117135ebfc4421cd68c88a86169b606ac0434842cad5946e7222830c81b4421685257ee9a70485f096367565014184c5d8da8e1cb766713b441570f2b887bac07aef32a82943c339e6ce2b2a040a870c35cdc43348aab3d0bf7cdb936fe178abab3b1ab9662303c31432dd27a9e208f1514eaad887fea469dea5c8ce9ebaf3e556c28fe72eb9696daf72283e0f274040b73697b15adf69106703fc65227fb6c2e3a75bcbd305bcaf63085364a98e48a5dc25d8d17cad511b9103a7e265f2eb913080cdf2d154e5abe897d36ee95952afc80950f3f7cf8a46a97777abb86c5678231a148a28773ec9d38e824ef1768ba453642e9f9d73bf1adfbafa0b39b4a08b6b6cfd323dd8258bfa9210deb67476b5be7cc5d2f469708e6f0738b5a4f2d3f7b0bfaec583b931e0a6106f9c354805754990dafaf5769749b51fc2c610a718a82f773d76c025dc2545d94df944ffac0f0fbdc638def3f1f1a2480ddd22c99688e909c6230b5801b221207074054a0da965e7cde44291465f945ff6785e8ac0b38f3ca6adcaf5605a7ecaa66d45885b15f097c95ed9a7dfdd66e0c619f4ac8afdf05f0616a25cfe30052bf57c8855eb1d1d9fe418a477a1d0a0d19d683dac601a6baf750b27a604bb7d1e36d0f5181530b2979c98c4a62c6d5983ec247fc5764b8a7f31a9f86369cb745a88c524c3b390d2412f14101387c7a3c548f29d0f96459e72d076281b62144380299aa3ca48ead34b85f2c0d8b9f011107e47128886e9da9f83ca8dc1c356fcb223f0d58fee014d6c7794b9b9d15d8e3e232fc042bc26df89c8fb531e115bf336c5d04a784af709902a00a36adb27274b1dd189d5e8233d795153e110ee0335c296333d2f769a714782b6da1ab437bcca54bc1abb96a7cfb98aa4a46323fca3bc29eb52c195b7b93d82e70b44e3a752e7aeb4eeca74ecbbb0ecce5c47e0a912a0eaed37bd8e008404ae06709b5693e867e89b17e1a1454b8fd273f9b284bda08fa1ee67281c2ab7b09735507d61ea8633365e2cae6ac2aa1412c8322e23906c1c9b537e072f1c98bb179577700df6eeee31037050790af1774391dab875a546c8ca898d0fbb45d7f7c399bb05655d8a5b8c1f159915c5cd89a16dae6c54cc27d0d551186fbaa9603ea2a563e3aee75bbdb14763e6d3838e0ba849dad73486026ec5f2b258691140313ce26c26ce91850701261e28bc3c2d9b611a82c35d18ddefd5a0e0f572cb5dd444d838d861d8276b2ecfd9077d0fe994e7f44d2595960b33527105eda901bc216bd05e51e6459c65877e07b1deaca4a2965c80c951fa54386fc3d9e15dfe48b667ac9a30ecf947a7b8ba18cd87404a8d8e615e40637fe2a8c40a1ea26b2d247a98bd1455a03d44b5fa3b3176d97368af5b7ff5510a29cf86af519ab3948e432cb751b1bbe4723affdb59cfc43546bc74410ad5b24cfd48c89e6be3d20785e18d8c9533bbe128bd6ef18c935d7f7347c2ca391c8e4f6642f45b9b27fcfd2846e020b3c18421250187659ae40f09bdd7bd5389b4490527fcd4dbb92e221cc1c4dc8b3d2aad3bd71a93ca2359e149d8582b94d437dc0c2ddbc44ecab43e94edfbf342aaa14e0d5497014a05607627c6b89c8179a9321e9f61bcb3b9d7644ed59926a76754ae1adcb4a964d5ef68cd8070c983c5aeb3dfe0fa3cf833c97e1952e8b7b3d6f99bacc9ce145274e538520ab63ced9993d2b5e675bec2c1328ed85cf399a7f4b7606722cfae46a355b2a9b68d37a6bfb0a6c29f06d419c2562818b0b13a8d2e980b5268c9a757e588897768b1154e7ba80220b5e16c657d6aad61a8732e45a233b6ff138ecaabe2b0c9ef485a7e7e6fa479f6105b490a24a89a85c71f1d16b22b26453c6beebf2b154f27e8e336f8d897e8f1b72ec485f9804b598db373210123ccba8dc67627d77f1fa1fd7f2fbbe18c0aa9500dfdac3ba462d5202462a073c7d727ca6d813fab67046122989876c411dd60dbf2422c7af1fae8c800912d5d5c4444b9b2356bb003511e3233df88ef1f4880858cc1ee0f1510ed294cec5ff57c17ff3d601714beae7a4d32740cff5d50bce85ca9e7f2f60cc12a1db256b027d44b6dc70ad881a91c9b635c1482e82c687ce220eb1a94842389761e3d0a895298a944bdb523c9329fdf1c6d51edaba75dab68440f4e095ddb4a3b9b9694f0e95d1b666ef6fe80fd9fa7facb070be1712bf2ace70a4d6d298a1d9a63db2a2f76385edfc2d4430404e4f7bea34fb0299a82e1c28e14543ebc08fb79009e357b08b6ea1f0c955a71ca4252796d728fe3056dabfb64f0fcf1566cce724884c1cc6d871ab586b51d68515f5e16f5e10bb4c018ab78c60df734587cbc6af4d7560e4176ce1956765681eef46faea4b0998d1497cdd89aae692f377ee453b5d370ed2db01ab7fd7513a9afa8e2769344bd1e750084627b416a1fc54afa123774656d5154c3022ef3cda609ca2bbfd9d9c82d137a3ed32b442cc2048d37d8fe1cb2b790ccfbcba54e16089289e279ac0a9a28d2a328be28b77b7bd82638ce0a386320429548c622f2749416bff3d99b75f95464b32223a6bec4a7617be98161edc763120fa06bac01c4b8961ed4f59fddf8682d81a8bbbaeb0e8ec4ef8b71c9b4b3092d6dbf2e4f1501ae5982665d6370f4d43843a6a85ad13db74655e90f1cf95cfa346e496f58def0b79908b66f749dd0ea3788dc28acbdca0fc9019a8c8a06d5f1a75cc326caf16a39999319d0b1701d29a3d598039d05718519a365473d99e4dc4d4c7afac15b391dfa2c9bac1a7ff56fbb9942210f9388d9c50bd832ff4606e666f4e927f3852bbec0690ea5d3afa5845c9468b28b77970d2f08619f0b7f25f8ba58539026defb76594f6a97ef46b2f8e341fb25c4058562de42c32fecd01f44b39ee2cfab9e12cece42908a159ed45f8905eb8da8c39a779334fa4b70bce07a040ab60fc9c65365cde4df5a716ce4c2ac8267ce8e13fbba182b73d48f351a1e4eb9030941ca5233451b7fd15d5095d3f93b4fbdb85c40a44d6e47e5786d0a5a916dfef0e99544a395786ca21596550934ae5524e14c915ccca95b41fbfe64677359347318c9c435f9b3f2957ff41ef97772d8302415677ccb55e03b55749c22747375c82131fbedd0baff75bf99fa8a66aefd73c37ebd1fc02ff6b134136200b58d5b08d0b6415396e2ddb5002b29d1186243cd4a68cbbf676d565ea525a001212ac9063d487fb8966efa18466f12f0769b94779c5da2a67e3991da6a4fbbe4b259c61faae36e740c53049344a472c7650b07afde666b2357f5d34bdf1934f6c6fed3d7a30b7b7ea0fbe50cfc13b785bd0eb03a94041c66eb50f01c5771a7ae2f2c43b1164ed3d82f308352a9a0d1dd32e4129b6adf84cf946cd69ffa37dcd9c4c79db1393b2ac76ca36d0cad7d3500e07db7910456605bc1d6ade47846e2a220a98225244a6110bd489115b6b558886c8f2f4c9adb442370a52da76e2bfcafaf24ee804dc58c8300147e71bcc2834c77870bb6a6d1838980b7a38bceb920b49accaeb699fafa36b638ca487d12957d8d1b508a1a2dd42ac2dda30cfb721b969bdb33ae3ad1074e545d38ef1c709e9cd6806984d1c181e859a50f8592f68403aa9b4931221c1fad1d4ddb1dc648a0f7f8e42f41240beb81d87baa5d16ae530510f2d5780866a77e790a8574dbe5b7d5b72d916f15e215000e4a88362e8e5770912449e7ed0c8a6864713f9726073d8b971738214e1ed63c193fd52d96e39a13766a84b2f193dba5292e42ef5b6c7e8ef3ff02792e2dc9c28afdfa10adc754aa2ca3c4efd85d9f72a2f85fdda27d8e4e9e4e9c7991ccf71c5ce7ab04326fa8c9e9f1b70108e868c62cb02312bde9cb500d1d71d10d9c3f0a3d7836ff79aebf2b40aa3ce05ef46407111df9c453fe7d8534337ed3d55ac10fb10be69e9bf3b95f1a5a02337d59d090274f535d95222bc08b7aa036ce6fd0ec57ab2f45956027bc8f5d4331fcd7579fa01653505bb8aa15e9c26933f0880e0ebe7ac5cb377e24e1edad1fe3cbbe5dccf291358bd341c5f3a6f85aa80fceba28220334d70e537f64b9ec4ef54b049971008621de391882a9d098140cf34cc2fe3f4c0e75a81d10749ab577f9cdd04f4bba874f80ff018464fb2c378dcb835bf92100e8093e87e44d9ea7ac311f7b03813fad8b8f433f30a5332e43cdc4e604b563e7baae6f203c38d5f40c818af059ffc87ad8cb40ad2ca4c5d2583dd630d4d2b99b2cf436e73eb8364ba57e0320f5bc71b9dad663da6d6ba53222cb157c91dc454ce2c202d58b0eb8088236f1a14f666457c2eb1306cad75767f2da774b99b15fdb1c10d7c96cd99cd88eaf97c49d6fe66e7a02123609e164ab017c9d4981d8c235995ca0e2634fcf4c519a7fc713ba814920c1407ad463e47c8f21f47bcaf535ba9e68e707c0d264e399e5ef52c2edef173b0cba7457b9bd0a10cb9d34f5b791c90f6c9cc9c33a78745f005f9205085c3aeb904820ee76a2c66eda29509e7b1f413cf6a179d0f28a5b30da2731f5693eb2af1545e7c0084995093e646c85f3a71436f9a7f2fc5b6ae7a3e7699b59901a2e92abd4250ad1e083e795b447b1c2e4c213ecb913acf95bb5b2354e2e9e4d9a60d6829af5a48408570a73a3ee9ea967747c1eac88cfff79ee1897f8a698a003426d840475b151f4e793b20e582713090477ca21bf6a573163cf3659954b89f7d964d3197f58ece1c0703fe0cf8853ccc105e428edfacee6dee405bc1a8ef5c498495672a6358995183df7f59af6a9e50c55c27fc205c0acb0c0824171da35e486950a17589223800b4f5d4ab23331f3acdaa3ced399926812d601ffe3ca9c0689b044c54aa87842af174abb4941cdad6c708e1bde5a7f04f2ccee9b57e96609d594909a9ff730f56e200a08381a4ad473fbb4c2cf186fe3fcc1fa3194bd2a07de07ef0b09ac427d973d9769f34a25ad86cc676268d3bfddeedb0beeeadf7edd60beb3c69572231c8476893f014a7f95df1b396346406e3a0fa2e5f7cdd9c6fc7241d95e2ffed5b1958bb8f7d617ef0572275aa10fcf0cd47b84a52b078b2b5dfcb336139138ac7d18bf9d077c3791f47cb04697bcecb340af28f6b073c859d46a1c356ee8f756eeb0532db12d1e30c32f04ef128adeef2bb0c5ba346163d63219de54a0e6e73c0405332ddb24df11bdd84f07755abdf99d333c931083fc02e6aabaaf5532de4f684173b6f799714e45869dcfaca2f2f7aa3bae40ffdeee39593239b09da2fbd385a9a9b6deecf9d96b4129b40254e11a73db92f4454e35a1ee0dd119bec3cc37cc0df6f5d14e295497e59978f8e261cb7147ca16471588436863ae321b03a5a9ba529956e7dae0234e5929fe7791bf88a19de2b72999046be8e656dd5f3062f2f6b83d1cfebb9eb610172eb844b8a68458ff159be1f2b216e531cfc993e5fbe687e070685b1911299cbb0122c419131b558c0e21f8c643eea0089da28443ed262fbdbf2525a85c5a73b698aa0b97ac4bc5bfdd6121fd244b0bf22c7cd28b57b55d80521a805bf1613b109526d4ce66288c6f2183a5ab96441940d596f0533dca1736105ae4e6aef8bea9354acc76d21ac7f521893f4e0dd654e24d0ec9b8c0cc07789c58758abd3f8277db8dfbb59e343d2ae23697b6bc1f5d7e53971c7fcf2dce290542bba22796cc555eba80943461f45186603c3dcfb3c2b5cf00463959c58a76eaff976db08ff4c9a4020996520266a79c97be64a401615521c04bbf374bacf3352e284abb00b23aa5b9c3036e058eb4950472f20b609c2e3235e3233b9907c6bebcbf0ef1ace268eb07b4847ef95e1372d0d3d9342e0678d000f4d071c682107d1e0ad70b2b719a604b906028ebabe867e425e7751ead7ed5327f037ffc14d53dbb9a335e01dcde8d6c0b58d6be0efdc39509172ac8f8852fccc4cb0aeba4587544149d7a7d316fb680a9d4b7e7349ae3ea0b73a9263c25f348f89e1351e50647134cdc1bc6a88a302966287283342fa6889525f548038841b5b16bcfc0ef1fa9f85e3eab66dd57df04aef5b5b2e1032f68e1db5909400c35af8447b4dbb81c62aefd797e32882eb6fc9c11d1fee68fa2b8f9b494aa49ad318fc2e7b90f0d966f27ec7f51ee14ed9b0cebc0d737a3f2c1849ac0a7c9cab536a2a2b66a1f1b38705456a4c0a144b92afa4c86a8d9914b60e6765f61ee775f65d79794a4476b71ad9f9a98e62d1a07d3c4ad90c0fe9f480a9a7c7d8681361cae9d9ab5c2f278e917042a1b72e2be8e142a4dce56f2010c82cdcdd5e35439c48239752706dda5326d7aac8cebeebd4c1c338c86adcddec04eacdb7747fff641823a09635aa53e235336816b8cd4ee40e44a74f7e82cf54f8610ad374db810107cf4d98d6255a73fae27702a7edb1669c92c13955e1aa2294ec5be424ec0fd22c4dad1c3d4ffe9be6a3f11599a4905b46bc948d958a012f113e87399c901a2c0726617d576345f087f1503f9446dc6d6dc1a111e3496d21a7d3e407d8fcc4673f8235dc366ac1b760dfd846fc715b831458682fe4fcf94ab5fb5428a50f4ee59870c60745751011379dbe2d9c4895294ef6b1b651f0380da8fe2d51e56c5a1ffc708daa4588da8f4e63c2afa4c15736635cdde3a4d69f5f49ec00c607ca375ea8d633b78fee510f7ebf09a8588fe26bfd026dc41b78e48e703aee0e426cb3b6bced07c16015f11484b4e0a166a689e33601b23db66683e6b16522ffb0c6310bb9d2bb1fc75b934cac85de9781011ded979d6da8f1240491a36a15ed28c49b8aaece64388b93ab25696eb7cfed7324d90ec8f3e5e7a401af395197d94828dd58016129ae98bb5b2952111fbdb64669affe7c236aed47380f0697de1e39a39d05e9fc42b125e82f9e3e9cd0039e38ff3f36e205eb51d267e5d3e59aaa4f1fb3215bc687007cbe87c62a707a2244419a6758006503a5662476abbc2aeca5e07331049c2cff02d84537224dd7a78288f2c6e7930c6833a71e00d360a71f953868e1bec43f3f51e4127c725decfa3e44863e2ae28a012bc6f82e78efeac8135d334dc9559ebffc18e5d690744c77a01ddc2c963e8709e5dc643416e8ed306a7af6eafe81e6fd8698214c73a65407bdd4dc608a73f56c251aa2773c58a544320a9ba9b6419d905e928b5851103ecc2869c8bb926cd9f6fa06e46130373fc7cca376ee3a08599aaacf41b0096838d140bd4d43034c21e8a021797a21a7d46899d9bff22901aee06751e786de19a65fdb0fa719b82d3bf3ecfe2deff81572005783227438b277d5f2ca5ee15671533ba505d2f959f9511e366f35a2a703e825777fb3896257216e377b74190ebfd53dad81af99043c341f848bf91fe22cb5c1e3a042377ec693c4ecfc5e78783c4dda5f6e146ce9bc595a3acde44cad865d3f1bb798e43bd4228276aa778c5ddfc1bbe40ee21ad5a85694fe54dc0330e67d4b3ba6a82dcb245d1e6d6eed40c70600fb8d42869005c33e8270f62f03a35402f88436f0da23cd00dd84fc21800e24dc359c40c64cb7951289d2546b26b6d97093ac38446dd1368ed98e4707d5970827332ce0af8f0762eb6c3c3855e1f2caf0d6278996716df769f7e21a76a0c42bed72afbbb8389130fd068754f8c3dafcd1d60e41c0160c4074f536023ded5fdc3eca773aee2fb2b26fdd45b5cb606109a9a0f1af9c9c07d30621561d4ca92ad85f29ef46d544f71f5c03fd6d223f10532b801b8792e20ef7c6901833d23a22ae25534d0894bb56e571aa9c48e775c96301e69afaafecdbbbbe8ff04148ae293f96b0ab257f353488c32b241ee19ba0ddbde84f7f6f47f605118e5fb293b3852c0875a9c9d59e3cff2b5d4ad1a16fcdf6ec2fa12c6feca05409f0f7a348259fc3ae66c1e325c51fa35983c7a2c4c61df1601e84fae8fefe25024884bd7fc60049b19e553b0997b61da108961406d1ed3ae3fad4c988191649d168635fcd2a583c6003a77f1c37abd5646769beaa056d51adb783e4649214519cc1839d97c47a290fbe740bf080c2662cb65dab19e0e03e2a8468dc1a2807c7d680dd99769dadd6550fd6b4352c24a390dd6648f3ca83e4f13d099c59ebcf7781319627c11b3c50d2abf94d69614c692819e49b6607fd5de0d85b3a33aedfee1377014b2e50fd115f5728b86895e5727e6bd3e67633e7add267ec1998b8d623b7ad41459aabe777280951df12ee38269d386133d324952d98d1cfd0439f65dabeb909abf27d250985e12bfcff5662f4a060a068bc69eb525e423cedd1e680f431d10eb33bf5a704791d70fbc06b9b3b9694a08eacb01de1a7d4500a2d2f03492e39c98a89ecd3aee7f5b4cc62cb8adf5f84df6c4dd92533740e11c0efef90982200f7559037e6a7792716c2fe47cf739b446890b6047eb74fd50f1e694dece2781db835f064d5c0c3d1c97041f10d88f9dd8ccd47aa60a35118d0d9e40cdfb4846487a5bf6b16616979bdd9a9436a243263f9ff50f921c7e8d14dd995653d1384766b8b6ac3c33ab77fb69d5ea3b9313691ea222237adb485fa804d5f5e328e989a511e983bc059f8850027e086174ea0879152bb656074c89a1e6142e0bc2ecba5e5b7b02bc25b4b2e64dd6816202baeff369b9479225312ff2bbe95fd4475beee6177b5e28b5f75a39ebc108d77e6d225d326f80dcd89688c947c7cf1af4801edd619a818277d7df56e5f96df99dd5bcc9dc45ced633e0783dd72c032f920e961b9bd2e4f4aebd84a5548291fcaac0ee768fca7f982aa6867c277927e5a86d99fe3b53ed7d2a8b326450115881384fea4f2452ee2811b21af6e274bb84c35a4f533df4d4bea78bc48dfd3b6d5482a73f52cb64f51dc9807f4a25c8584b6c5f2d17599d53ac3d3b34619dac570ad8483f96a48a5c051988bda8ec075ccd50da25f005caf19dcede1c9abc2d8ead7499faf6a3a1e388b1f0091424f754e6ddf0639f30703c73dd486bd0505f7a138b53027cb998257314487f99631c2f6f4a608cfd206526af89d4ac27505a70ca7bcf7aa49afe29b21ccb0cd33b3903806054cc08c71d3503804a60d0dc63abd2d3b33207604666a7c108a26eacfbd0fe14d83bbd728309d0fa12c00e6b47a074d67eeb917bc7da549fb5b9e0cdcf22be7230129dc2e362ab000fac0600ba7b7ab99f2ed5d86e9d49a0788da0608c7bdfbfd219cee45815c8f839411eba1a73d843dd41d57d6494594aee91dc0eb637f1a0895f86a1ebd9b23222209a9e340ca9eb1766a689a43618c3f7ee9586db64654eb6b03653463df3e693b7e386e187b45044c71240375aad5eb9173ece3ca6521d4baad500ed7c78c3c82cd6822c4a943fdca4cd5b5ce12d66db27624033e11c2f99790fa6e42809cc6e8991d4381b69b2083a0371b90a8bd23317b26c3a749f48746927508162246fc881079c0f6f67ae0518994d14631fce1ceb30ad4ce62e70cf8b83974dbbbbffa20cf3f8cd39b476826a12089cba1dce7fc3a19d36419f4ea54f2f370f41a82f45a95d945778905a41f09acabec9e0e0fed744416bebfa7bd0d2cbb6d4c08eca4b9ea1ccabc1bc041d3b5c4fcb52e4299aff87106fea04cc07dd9a7295948d527f1872a9e6ae2645401eaefdbc57c0513e1834ecb6106ac0e34e554b872aa2ead9a48bb7fa0f82b4a7b8efb31af895e0299ae050e4233998b08223ac1872a2a694a78b3345152c86c7c28fb689a6fd4c5570e2d267379b934c28e25046090786717871e40df8a3d6b09ac52eb82b2ab2b14ada4e5189aecc497d9ffe52ada5ffea9317ba2d49eeb789511b3df6a6817d40a8ab68f4c05d06f404d74023d61b5333145d4ba3ceff96b671d419e67e8f8dd2881c826d432ad9dcd52f861288bc097f6d6aeed5ec56d4a2038a180eb39535301028d74959e7aeb11877a84025d7a80522e4ea27ccf937d17b200ec232c23c5eb6a76660e13e1fd183009b5b462357208fecb2b430e2da0c04e70df789cc5e09bffecb6274cc46f60bbe0b41f5ae1670fb57dc703f8010ce33482436636f32047f1a4ddd2f56139bd8e0b247843bd2730734ffb4f9243cae90a365c6f75338e358b6f94e05d2b54e5c361b2d6f31403ae7da26c45ac358b5969ec60e2819cbfc71c091571593eada44c72b521ea148766dfed94669c46285d46132811702cde07ce29aa15ed0a6e4ffefcc3c1d38bd2473b9fa3803b417d130ed60a937b9b6bb5da770cd314160bbf72772059a7d36bfac02b1cc7b21f8ff28f90798e8685238dc49fe23c56e25843e25555412c4d59342546d140557b595c0f5bad4c9145b6db5f72bdd5909f97f8ee14ed85338a1f5f4b2b659b89085c838da3f671de9f5a876b34e97ba43ba2c584de5d618dbbf436a5cf9cfd760620ec3f83cd7208803256aa5ba7650f414eaf31742b5f981cdde9107519a3ac584c194a51ef71810bf5337546ac79f1e3b31c63414266ade4bf8e0ffa5c9d749c24798cd3e5f3ce591e79bf65e6b2f586943e321e0253c12965a8006e2e7f5aa74c57bcb4116bde39920df847270d82f835cdcf1a8ac2c81731cbd644c237ff14966a3db1077dad496f8fc16c1f1d0df69f93c95be5076eedee6f3739b9a957837734128f9448347c231cf1ff1411ff88f0d02598a86bc79b1c130a96e11387a01944328d7112c38c7825a30821ddd4f6dd58dc5c17fc31682f1e54948a38ffa807ab943f2f8e76d2bce1ca895344cd3dfd0fcad2ceeee7ebd4f41321fcd68a33e614ff3864535b2a64e36c6c90e1342a5aee2d45c684fb75a756bc97be651ac48567f4c0d086a150d8828ae84a8a0e3714d41779429b47c487228449cbc6115e9bcd60201407f127219cb5d5e591184f294c50a4dfe52a30b5cd40e51cf5597f50a78cd98e2028fb992dde214f449c3b3e96e973338c60ced60d4d214c7742839741930cfc1bb9c9269c4aab24de755c398f48f66f64d7da8c708401951ba1cf8434a4392b3c4d009351b17f1a11fa51b8e87acb9a21ad4cdf92ea895f5708c3be30c00325d5af4999e8915862f2ae39560ce7b0f760e1b6fa75372af9882e76b02e440e22a608e0190be0ebd41ed7818363a49356d5156f3e74a080a36a1cc86e4e0e5c608f1fd629f107d4255151286269135a2bda10f533f26c382e18754a0be5af0064cab1a54f61b4cb1799da2e0dd948c89117264740e41dd14590b953bfca8de1be1ea5733e4e02523c4366787954a49b61e52cab79f75bd77ec0c81e7cfc6a9d49c3fbb60552842fcfe1f22d18a89748289dfab855d3a924809c887f939c2f2bee848adb49da82ac782633b28b002e3e672be14cc1cbdc5ec8f097b2954cf439a4a7b9653fe4e0d7ff6473c72325601603020b248380cd247c3b5c80bc6a15f9f64bf5379472de10673f388023167992e40b052ef3a6f799e535e7846c1883e5ee2ce0a17a258f5a206e87e1301250e37b8caff09c7ed76b5031a375adfbbabb0a6563b552f821bbd02a54329a8e15e69beea6c85f50a9a0700adaa84975573a50676b42c29e0899bd3259e3480f93924e93ec8835be56fbab367cbbe046e2a74a262fd8ffb90f6554df89d4e247a90fc015cf3e48563fad4235c3adc882f37556f1bfb4cdb521c697b8d05a9810badd2ba064483f92c87dfb9848da9045e7f680bd0132b190611ae1f9016d0faed7a6480e6fac9d76f6209112f17fd4908f043dc7b41d3aef8fc24fba1c711ee9299be42310f1e60c8c44f14692dec39989adf7a9119779a7716b2f89baaf8ef27977ea07ad15d0a9a7b1cf1b7e67b9764cd96640ae107c87dc9d3b51334e2443a040e385f7eaa4c858fe598d96bede42bc2d6129f9e3d49183db87e549c3259e3ab4162c868f9d2550ab38d4919061f92e795031784bde76fea9074e55d089c7dba3ebbc86d17e6ce58df72b81e91d4deac69af51bc7a18de779812b66962a80becd0932b4b61e4f0a7ef59b1b685fff764b1b24105bf7104a6d5e0a2c521cf8c0805d50a75c952ca7b580de06a418377e1cc424475faac601f7264e1d126f6139a31a3427d5aa57135ba2a984dad3f18633e47f9e91bcf68d971c7d5bb0b9a43399449739bd713b06c9368dd6a770feb1d9793b3d8307d0b4eb97f2b7fb2d9440bed4605f68c13428d5465c9f9065ccbef988f7457466f59342196af60dfe2f6d2959e896c5be2fd5088909f04e0b10855195a53c04759e7feaf771c0679232765154a008db6edc0d610339705600f53bc216e80516659579a72aca8ea1103f6fdde7d31e2530dc10d22e90a8e26bb88b491f1c3241361353d96d1bb7f54f85006b0ba0627281e464433c0ad061741db6eba1669934c558f7bc81d6fe05c81f0cf326685f9cd4e2105c93a12dc6915eb31f5bb5729f422b858ba3fc860d5abf0893fbd1388523653614a810457cd343b9472200bdd8b368d796a6dea95d812560ff0598e64ec0a482595ecd860d0060056de8247affe9ae0953322636f51b1a0a797acd8c92e6b9be56bbbf90909219fdf13cd3f3462dec5826a10ce8e863d04f8f415545ac4790a8dbeedb75233c25731d95d91146f00e3a8384a21e1438d002971e94ec0b5652c5b6a789c1fee5f41f11abba6803f201c511aefae7cdfc84ee19083a62563eef48de25cccd8a73d7ab519dc2a24db6ef29ebaedee3691ea986ec61843a4805660732f346476dfff64780f84260dfde01cf30340bde53a2908d99c6009e0587618f856a16333aaa18298a96749b2faed9fc2587a7e62c95af5c9f0c650b1f2c30f83c315016f84b454b531a447851db18d71c3d715d3c42ff9d1eb58cceab1edad9ac62ae988ece022dd317d8c86a268eeadd896139b10bbbe035c86caa243265c5d7e4d2fc7f62d50676cad98b80bfb49fa063a235c605f38e845dbda11a0d2fb87afa582ca978a313e806e1a7d4a33e66b304f38c6ced098dec9f122ecab434611a5b6a175c2d7927311ff75087153c53d58f0820ff37fa14167fff59a55756dd8f72ff58529dd2b6404ccbfde7818bb5696a275653d86054d3f79827e0f4d33a592bf830bda01eaaad835cefc7870d27a360c4eef29a75c8e5de97c9c9bd36fb5a64fac21b272fb51f860066b6e2df8f77496970a14b8df2ada7b769dd3898379491619919004cffa141248dca7aca6ceb75532372e6d774d4e6c02c1d0fb0894badbfb9631401cac565119217cfe9e07505965931109f3753fb0ce2621a5cb54d9ce78cf698ce4c9ea0fa74769d1645b87d1302ffcb042bcb683ef030237d56768f9654a4784fc0bc70cc0c53011ddaebc0fb5a043849b54e8fff6f3d3ec2458f01535005c94e0e18a10726d4952958cb9ee0a917c8284ce9e35f5085137643f9c64b938f72566c684943053049adfb2f7403b660f31496d0a6badb91f1348dbe3372f7e0b2874d25dd0280cad435008f5a56338fbf668041e22ce1a949755aab526c3000f45b50ce5e675169094281d1580d52a1d3b9b4a655499b05789da626c26dc88d9c4a338615f5a7f5e0f6d51d26457d9af4911fe0a731abba5bc3d6cfcf9e10adc5e2da20d50c09e27fe0da99882ab8ef0eaaf1371eeb79fe64d47d71c62c9375307a6d3861f43f9c0b0b34b33cde37dddd1713c7374eb9d10bf16ce72b96dac17bcc7a02ada81e75be0dddd736602451387bc3439b0a1ff85e03f9e8c2797c71b615576c9f1b8a42895f002312cb8bed799fee60bc62204d30858dc35706d67ff9219950e8109cd874ee863bb1f688d92e92827d9b80d4372dfd170f85d583cf22fc67f04d63c111d517a3055589b7a4825e7d71edbe12753a143e8bdeb29993f930a3bfc85ca6c9aab6aa001208837d18fc05eddcf82e460c840381b8488034e370a517eda6d0af3952400b03e4ededa8cc58cc77e5c1609537d121a8796f62a0ae18ef862f0e3347cc4e041732d6ad7a8dd5926a1ed9779e4b4e7293675f46af3589a05692aa3fd38eae69b0ac838c8ef72c9c991b464425816cd6be4ba5d1d2137e321a3bb517533a3eb4ed3f4195b6b64cff997ce1ffa878eb664d535c6a4851f83a4cbe6aadc16ce93138d1058f156a51767cf8ee9cca8eafb0598b4d8afe5e1ef348d5e58563e8ef7e1b2bd4bb05dd93d9192625b6bed11ddcf8322d5b51177c78222087d394adabc4e3192fb0f89f5140b8add9acfea044486f9d7c44fafc6510996ecd1a6d13b28cb6ad62f0660b049c919d8a1ea443f4274e3b0095ac17801cd3ccc3877d26714a5eb0c305f453ff13e21f7879dcd8cf0f4af2c4bd6c034d4a5fb2b5e0e8612c11d265657b7b65379635d2dd56696d607ef327a3640d58603de23d196ae5a48af692544792c6f5c32e1fd17ebf98e76b36ddf8d9df9a77a74d716fd5115a84b897d4fa6a78948e9798a307b8479d7af2e4bbc7a1d3988500a7bd0ee9b46c6e330b8eeb7a964b887cac38734b48725d9f0bbabc9351b42f94aee78c2071b4754b471a41b946291361f19296c778c2765cb9a40a96e189e43c474262a47421dcd4a73b333bb702c09ef469a1f772ca212a6d0e1e3ecb9cc29109b5c4251db736af41b5869fdfa26af27ffb0a2b62dab515698514e3973057fe07c6ce67783da6cf253e3413150a51020bb4bddc337ea2e30c4c0b2ddff51a2c688d16e02b3cba626451e0a547d3a4c52b9675ddb3a51b1c262dfd9d086f0ad713f5c0cf119091bbbd9c286b1030e183ca188108975c543f0bd6cc63620b79645c3a500131c60e2d85bdd8c53bd54be2b02993839f0f126360eb7c2e2e5982074bebde752173cfac1f26554f94e0a80a24db0cba1d573fca921d41712e5fe54c9c49429a1d160dd86ec77b38d4348f98f6d7fc8470bc0d91c7dd940ea3748709970accfcd212872b648d9b22f6617e9794b08bb3d47370c06ed8b0e500f5a5bd23ffdbf74aecd44c871fe4ceda94af8360e4e79bd2d1487a622335189c91daead6436abb338c0715e2c6570420b88c25eae2929514d0d16185af719600e144e1d709279309a68ef5acb9dbcd2f2c644ac1006f27d9c8cbd673f6a69c9fc6831037fc4943e4046d13787a831f9180d47c5c6f1329d0b60f6fead3faa4ed30dcfb6a8c27e80ce066989e5b08e2342a226fd2014bc39b47781cfd90975de16a5a21d6dab7e92c275678805368b70e4b197747ef9fdc9fa4e8d7b682e0c6526966177bf4f707f6ad00ea8a4ced9096f4fa9f2ff54e5312eb5b3343388105fabca258b1386ee7d91d22d20d46d7026734acc998f48abb84278114d2aa7a20f0b67d7fa65d7ea739be4d3a245e3ad4effd14be36456082e1dc96252cda8ef3e7a836a384365638fa39e50ee83c719e4a4ee94c2a78c50d516bdb01f56b2f469207a99363d9ebfda573a17f49e2b5a13b2fcd70203265842d9262cae6c96e42d8330fb4ddde3cc29f8b1b7ec783b4093eabc3d47b089b70af120995c69108451b0b167275862e6d6393be86ac8de6b919e69ec03ea8a0becdff60caef6b44ef16b18a3ec4919cca7021c1acf9ffa45eabd24553664dfcbed88fafb1b3e7058bb2643705ca67b0738a2eea2d9f820c0873a4c56c0dbdd7a970b5ac77636072fe4fd80c0cbb8e7ed676f39107bd045ec6b52d686df1a895dc43fc206ddcf2741bacfcf26f55a4a4a7db0971706dccf9f145e6fbf26106e9069c1a1b2494f228657f48a8664ad980161f46622b7e7446abd900654d9ed714514e557b79670baac4b3b6ae90e263425b934165040a57aead41dd5118a72f670418851104dc070ce370964d554f4a6f62140bf7c25a9e52eabc32b4304f72ef25fe10ed773df0edc4d162d9041c8a18e607a81d8ea0529619a8ffb82858b3c24eb23f3a40cbfb05bcc26206143795e8700562fb75236c17dffd21b5b16e076f33f74d2cadc3beb4cd2f74e828f54d99258fd83235bc9767d409bb48313d726ef52b70c356d525b7d3ec859050b779cad61092c301a1c2735dba280f3fa5b697f707025320db4d7d1755aac3f13ff3e504615640266496b02ebad137e522b75c59fc43a598e964f7085ec039192fa3bc3d543a77081a3b03f9227d883c714e2219e2c8025c4d05d928d01a7087e5c6f12f72eb48a12b24c812cbe0858e438080a23d3c53be6da9f158113f641e699065136efa90602bac1d08ed345ed9485de559bc9fdb5552495f3943776a68ed79a58269e4e3573d8d938be841932fb89e693e09290a998156c9cf70a54f89a6a6b2c2140cac589783781c854c8f4d389c5ad3b96f671babad5000c80b87a726244728aa00b3ece0743d9219dd9cf18d8734414a56d5670dd2e60bfefb5740abc22e288e5381482f48e73fcb0ff5e538d3b56a2680de95580d9b9003fed62d8091b7fd0aab982950927607b1eb81a021179d736f6527e4247e19e386b04172052de1bba4f03efb8229d399bd8e46ef0c08071a72a5fcc008347bbf5d491e922cc4bbf4c67fd38b5c7a4169d19cb43aa328fc0192b5cbdf621406829de02994dded1fef6ebbccf35fc2528cb3305c1372736483ebdb539fb51275d520697d7a33f0d5185ea75bcc102f42bc70025a29b069d57b4ae32231f1a8c459118c98a0dccf0f78b6ac971258d762999ad63dd07b179d1ffdde5e5d3e1040ddfac696f342ecda9cbf5a58fcade359d0c024ed11a6dac6da94c8b2b39d0db42d0c0349623695e95e85cba523591e3efdf822f1e0bbacf6318384db759d642ec813c0455adbd560b31b8d7a41b1d31588c7577239bd907a5051f52cd62e62b95465c9688e3e98bd88ff59b2d06de5642cfc15933fc7cdfba8b8ed07c9d0ecaa44421c17da84bad198daef9d79b4e282302a05042e4ec0c025598b22a52c34884efca02d2ddb6b3913379a6531d74cc78c03017953abc8b57099ba0bb73740ca815042dd2742bebd8734e15e9c70c096e8b5acd516b3af7f47f507b7e1f936672ff3f1af7f06a887bcaad60fff6397629e3d45d4ef7c29a53996eb3d04ef261f06fe28f9f6d0591368604bba4f5d5aee97739a76163c6de454946257566159f728d4506f4e620e91000093cfe91993e6d2a5bf91272e9185c290930fbf1a774f4683fc0ae44937a06c25472af7881e5e5c333e709a4279a171724a8bf0f3964a4bfcea09c87fea928444cd3bc2e91637f8c83bf452ba779a8b7428212f76c92e270e22afea2c5a0a9a5defb0b7f6a082fe1f54e0fe221b6718e05a5fd7c4c0bcf5dbffa7e4fcbf448f10ddf389f42f269b1e71f835f726ad13e0f0f3e6f7b02115e734c4a129b4d3c7e59bc2d1ef23fc4218845b0344f5f803231b5492455a860d946d5e7790d20252da846b376f43b99c795f229ba9649cd26d7fa0e26306534f8cee62133740cca41800b6e2bd606d1e5bbc474a56c1aca6bb0a51eb817a9f2961e3a4ccac070fac0b933d61390df2fce1aacbdfb7a2825b75201af8157ce445b827ffebcaaa0100c3e67696021a48aa2f308b3ad40d4a94b24c5d61e18cb32a693a226f75a592c0f89f9fc40ab3987cc005ff1fd84b05aa287f9aa3f46a804312e0f90acfb73b124d551cf076f5630c577775fe0a6522beb2100fbcf2c5d83111f6e22409b36a35964d819b0f1bc3b5c4bea20666e893076b49f7fc7d929768abbf521530e8cbe0b672d1b53e165ee7ee8a77b9fdcfea378819422069f9fe3f5034c6536a7b0d97388d7108f75d5b1b1574fe4d0f1ccbc376658435c5cb895a869b80f5a82138ea8535176fd46fe71baf26691519ad5692ac7bd7880dbe7cd5ca83666aedfe8014cbc0162408037a50ac791236ab8bbdc2ead302da2edb5ada001fd3150d6b8de76bae69c904dbeb774814f1a7d1d7010f75181190e342d5aefd991d733522687ed0ba1fae03815203f537c8","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"c980e30dec67922ba6836a973565104f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
