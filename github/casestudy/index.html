<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
        
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0e69b7267f0bbf7a76757681cbd3da217f4205c78f8014568308ad4f1b826cf4159be1dac5fcfd8249b70d8c83de620df36bd5bdca787708848eceacdb930e49e40cee268bc9b30513bb3a4d7b913204e254e7e29737ccb930a77885e0e333cde6ba15f8df05145251ef14ceffe1155a44da807ed4e9d2b33c63b4e83ecafe09170e72d019713ede73e659d6c64cc4bd721c0735c2a5ea072192f801fe43c242d2db55d6bf0868cf3b386767a7be7600372550a577443677133b87bb8ba267b90172ec55d73978c68e68242096b0e2a631f279864eb29173116ff490a424f1a48ceb6b5885b21cc3c291c3fe2121240dd31a47a87c7f3d06a535ce859763eeb00aea7330c7fdb43d884178f8faa9463e61677c89cdf5da39e916452f5a0576578c0cbd343b6e0fcf906eb37d1dfedc8eb689d53bbd1973aebc880c9b47806af900f37a5c264e084b1c9387413b6d1b25035811985b0edcc18d02abc74f42518606acddb66e0c0b187850dcd77a371422b207218fea1dfa8e7212021cdd8604c0bfe0ea314656c383644d8e4ee08b9a3f147168122e6fd9a38ce9c4edcd888c54fb3e18a11fec414d1c1bfa9a866bf1e3ee4442dfe095a1ecc9de1380d8dfa6424c1044238a4e4b49921206c95f95907e23759de8ec152ab31ccd8593bdcc6d549606458740c6a216983c78bde0d0ec4ba5b5c0c582c6c292dfb73237972d8f08ee91b9229ec5023424493768c53dd4248896a43bd300cb5fcf24de472c26baed03fa0f0f347045518794d72a57b3f3c706e772680ff8c67c2d03431bedb2c7a3b84c7930c8c5bbfadd8439223e53c51eed9253d8a9dc63de5b82bd53dc33ebd87d66558736c55c4f99231eb4f38d98b8d7f28f2c547f8ebdab1288726c2fd03b6ec64bb4783557a78709b08a120bf770d27783c40f551c1d6d48ed479e1b59e9b33d8316327dd12bd91251cff569820681f7b5907722313399b7869833602165116ac22171d222ab5974e427d42db0c1ed94ddcd85ab670921f4c1b9f297ecdabd6fa153f793c03370daf48a4df6371801c2967d51a82d456c0298df5e449e92e3cd052e3e47d1529c2d29bbe5c09a402cb1b1f1059161de79ad9a779210e9c87daa4b5733008a08f287a089d9899fc6fe3783c454030acf330e0de2f3b6930cc768363a110cde8e2aee454356581cec0ac75f27474bd0e6ae556e6384f98c1ac5eed8d52e50b8c5971c4d9b0b2df239ad4c137ac8d584effab2d27e51812f6d3884aae4e0ce3fc4941c186ad8a8c35f87c713c09a8dc696a3f165c4f2f07b304d75f0a6ab07c29c4ab52ea246a0c876d68ca2de0ffc0656552a95c478f11d316b69d7383c573579dd5012e61d87255a649eff89edcae5a611136a3afe0ee649a8d5abe084053dcf987fffb9573e09aea1c944f4b0e22cbd57d273c268d20189431b0ece5ea3f0c7e690e147215cdd28b1312b0b85344fd2a26ce472e52a51d4529c88eabb7cdd16efaeccedc403e82f994bb2e3b18c401362bf9c56e7b95f9a1982c306c94c039d822397284c73de1eb21c166bcbb4b51b79dd78658829fc493ccee42343992e2f3e96a11f2ff2189e10b74658f9ca9a010e9867e1f96f1784e4d0e47e7d9dccaae56fb2524061c7464f3c2ded1eccef2d31c363ef3d62c757afc9377b25c5625b21966fd25bbc3f55b9692983ffc233247e48eec82c6b6810e17c9b7352338331a2d63ef2bfdc2c8503aebe00bbff0d6ab87de25752b6d6068c163a4edf5b146e6f48051bfb61d18ceab5df0dde7b42fbd8ad3673574826633b211a0d8e029f4c4cbe3159ae94fb962d5b6f25c72155868070624f2562b14123dbf321e8a1208df3d0990e7b8a67d698984fc778ea1bcd3298d3127e1f4a1d9fb6b908ffb1eaaae0dbc3066a7de0de57214b106864af723cab3c546671fa180c47d2c40e495d260c53a90ba1ae5e4af8a324dc44c2e7ca642ba5c763536e8699c465248cfbbdd42bff8096a28aa662869b3638b56f4b75d873b68f7faeb64713168b2b2f2ad6c10bb3fa15ed43eece018be5ce749fd6ba136d7be064ff93012222a5d04bbaca67856575f488d2ccbda5c0b5a8e321ddddce93f1fcba8a97af32dd75faffdabbc33a15a12dd63177604bb46a7319eba3b1a95a17a1ef17b1792a15894a503359a31053ef85d53dbbbdb7fcba9327494279c9885d9a87c64c902419af28de1af86078ac6f4e0b46e1cb186c5ce6f2f7e5c813f323e394fdb6f3d729184d83b9e67cda04b249a94b6ac3948f1a4ca93ce0c5bc243bb01e5954e1ef15ca72bb9d65041a1fb0000cb65facfb24b47255730b215c17daf78ab590793967d0b75c5a30cdcda74b4cf1f6cb28f6e228939b5a9e129d9a626ee69721bba3db4f37f4cf314890415ddbf2d3b5cb5a61943a2e570a20e79439c01dbb7aaf4bf859a2bc69bf4fcfa7cb8c7bf3f9f942b1cdd4fe9110a52741dd836060bd0d7a2b2943fc82497b4dc40b51706e9b87bbfac92d6728cb16e1979714ce2662e81637a31c9f20a8c6d76da096a45b7e9a5242ce731475fbed0378abfd17f9b351f2b85df4172e933d2b4903516c4bbec0f7be4e7aef5462de28e1e31df5c77c857e29b8374dbd2c82e742c3946c917bfd973d79bfa2620358bb1ecb0e5386b39fbba877b063192899f8961618f7fbe1912819e2d2b308e1a1596291151b3ccbb4754e8ae94cc5a9892af52c2fbeb74df0d8afe527b42407e90ac02ea2531e49c465a21a03a5cc0d6d4d811c42dd33dc1d3bd4e6a9b4af7eaf55929562636152002fe1801a4511b6ba3e5f895a6d44690f8c927f8ffa7a31cf06ff32be914909f61a295aa1288bb3c125252aa7d0934375a3b021e38ce3c35d643319a62cd3afa8213f09b80b7b5aa3da21823f219e99341b13b44ab143a16f953ae6e7484a772d62a389d32e267437ce6340a62ccc7de66fc1f542e4c321bf8aca6ac0e092d4288904099025af2a8c08385cd7e8acbd15d72149d31aa106eaeb4f1f9ca7e7890746d1e9fb3c7040583b26a4d1331cdde4366a8a13aeb795a2dea8976d3590d0ba7ecc2cde9c8ead58ef7657778ba43ba2b3ffde386b273138922fb51fb7da817e58d791f02cb885b32b923b6e102da6e3ead5b7e9dc26278334c0c367a572acb4207a9fa003f4acb9e21f24b307c8e41a1a7666df41e5aed5237f051c62a1118693e69262e695ec50fcc3b9197e9b72adf9e722c21a66ee3cb4cf4e412962768a4171682afff5887fd4720d7633696e60be53cbe5655f0e3659e7e78db0f49ebbfc6212efd0583043f9d7dab8c29f90b58da5344a09e2d436271acf7f3929e90747e54e3e0e4db30ffa0c79717e6041ff8a66c4d24aaf7a971ec488ec5ef6c8b2f545bb9a9926368f9b3b0e624cbe9169cc574402b053017cd78a70457d1abebc60077724eae798910fe9d9528a03df65c736a61ab2cd92158ab35c39976113f637bb6dc45f52436e18a60a28e90ddb07e628b9f5fe7ddbf0d8f98ccbeb92bef92d62202789f9c68fdff77107d7e221f740f9f59d4a5ce5e6a50786fe81dd06aa303373150167a28f79c53cdf181b60f37f571856ffc6822496d4629c32d02a9911d50ba05fdfaa9210d0b2b6a736cc5c3345b9db810e76c3805e955b7c498b89de0189560f66f13ca7f7708f676d182c7431a4c7e0c187cb490a842806d2c708b9f4e6ac57958266dc0d1aca2eb3a29aabaf556cccc54c201894c5b031dd770cadad8f1e70a75afdbafff3e98609723e83407a6036382d0ee098d052380d0ae2f2bded55b54468546390d81c2a079e91988879623b94f303e72ff73a70aca4fe3d9a9ed43319725489cd1ae7f7a617a7ebae8b12d36f6cf89677fa78454858488e0ab3119a4ae388b9932e69f976b4eb4aee266c6c0bc5bf3f0683ad572302307f7aca428f3f339fd3efa3ceb7f11acbe607608849d3afc0b295d916fe03fc9da4d34b6fe85aa026312fc138ff0fb9bbe599ceeca2d482954547cf7e340adbe4170eebff9d1cec3348cb46a84a7b53908bf17dbdae4884b2c0aeb9923b4db264ba88b4e5013e623e3c63c79909062570d794a6b4d4fe7ee8b136815f9979a254020598dd2413bc72bc512c45c2ea8e012049d474443954713befe119cdc523cde61348837608c54b0d33e5ec5a247eff414fc8740ff1218670f7f535ea8599bd7971a55b197c622d8d7408d3f1b84ceade63f7a53df9619bfd00e7394d0cd26fc1cbfe1647d0bb8f3d029432461af68bd210c34b631b9bc1deb08644437e4e56fd8ab006eefe1fb897d66b613c6fb3332a1a7da46d0613a69d8e4bfda6b3c7748da79e8320af61c24c137c730c07461edf00f88892a060e9bc88aaa3e175b76fbd3ad8aee411ce38b38d8ab287b5666cf467fc133c86a985187ae79ef0c709ce9c94cfbfb17f38e42dab6050334d4f64d7696792be976527187e4a9a92b87d3cd2a77d5dcc6091652b3cf20f08434b72799c430d464c8a454391d5b0f2e76dd81e37a9de7aca640f8e57304976e03b7bdaa1cd9e3f5078fec53ee1c5d450c7a1d860046f29e3434b6678cf69eb14f6f4cbe77a9695190c16363e300f5f8661133fb5f34d46ddf78d5feea15c983702677869ae95df41c31938deb85596ef12b1d33b26c8e4b0692e4c0dd80dc566f5dadf4130f166cf68a5339013404f774fed2c890ee95a59452a0e56a71c931e7062a49987d84823caef44083e53989bf3b7ae6a97702000095e1f9adbe6587071a0a46d58857277e94dedcff4fb86a87a2bd190c95a6a36997cf8217a93029a0b00986c149df2091871b5cdbe7d33efcf3e58f5a77d767a5191a7500ddc1b899e8457ec07f11284ded14653e90a0b65af11202f7f6533f1b01418e2b3ca106d24d4f082dabc458df41ce2725f1368d40e356928b96d59b17c87f9d691711bfe6f24b7c1b32f6969aa049be15b1102ce7ce1be9aab359a533085322bbc7d45e54d16b7b40c458588bbeacff5ad63d441ec871bcfdb8b19f32845546f6d085adf16ac38e82db0934778c0da034890b849fe85ffd3c4375554327cdf29928a0bd5bed98c36a1e6708191bf28d63b63a7078a670f0852b09e868f9eae8b1845da9570cb4691d0d34b9333c0e52a560ffd59421825007e1559f42b8b64e912ab71fcc17294f1b6e479a83f9248aa4583f23b12f892bc74de2b55351ce58ec10b117bcf147e33d01774cfcfc0bb50f2003494de43d70ad80ae8a711e60aa094f7fa3c4340a0c65118e4dc3600531f43a2bb4160f9e0354002ec54f689cec0f59a8a597ccf19074aed6c1ba7ff5359d166fc551c0abe8f4962c6b4ac149b4870229c58f64e5ff6bd3071006a27a8f5a6585c5e2c444647311dd6ef0b78dac43a5a0cf4a85665bc7c922da5a2c966d8923ab95fb86d58a2d61bc03f73e13293229e98f1f5fc7a1f8877076095a693ca94a7423ad7527919f81ddf51dfc1c74b49307f90813c037b3d8243b31d5ffe737d3d7b765da585ff80bc7241e5a5f2ec34ad65ce43674ebc5f7fa1b6f1853394585b7ace17a4163dba4cd79e0e90303e42a6eca0b2486b4bf974a7acfdf770558493d0b34a0aa175baa992d17cb6a4d5e63ad06d16ae72ee1b3dad3223f469e1d2f42db6773abb5dedd2d3613f7585c357fcaeb99550dfc4369a3403c01207d91ba25fc0cc6253fcd559a082aa44dc73de8985c736b7bec27726787f23676414857d154b9d0b2356bac072993b1d7740cbdc66de7a3181bea79b22e91a3c87c0913320e79b656f83600c5cf3e882b38778954d4936e800c054700997fae100c64c5743e94f7839179ad39c5ce20bd07e2c4669d0936dccd1f1c7f082822fff0fde2c3a3eb9194f5474e151d2a0c0d6c7194fdeb0e8026f1ec1f0c70864ae4333277871c5681da857dac453a866a4cf8a0c697d69879a13288f73c38291eee10bb26b43e402be5b40ccd0c4a7a8286c36424e808b4f1b3dbca41ed0e5fce7d013f6a7d4c3c58d82488e29b5106a1458e66a458383c45cd6137d6a9c185b71fd846c340505ead92beb62274f335c4a9f1b8422c45bf77883b28177979c2409b18ec90962ec70f642a7e1289a607fa73f11937e764552b88c2a963f7b69b1900bdb0a37d95517ee4aedac2464df22565ec5ebf5484632de5c3b8c5a27174201e12fdcb061e632adbf924582a145c57c537e385e73ebf868098c5bad5d23070a7ac03459d7d1ecf01cb3933f3f4165151362ce7d289a19c256ced435560718be13f9f6dff7bb436b76e99b407be064aae758d003fe8ed422b54d54cc7664324202e4a0f1dbcf7aa0a8b0a7e326d43f4a10a2da1dd83ad6b1dc65cf36e16e533cf41da02689bcd23061ab1d2a7faa3e6f71a9fa4a50867e0e93de92de1686ff712b975d7d34e820d7b3d44915a5440aacfd319aad3d8bf5ffcd67e6ce9f86de8eca568f6b40d5e813ddf95ec22969d6a24f6d954eceebe6d4b9f8effa0d590e64c413cef687d91bc698308fa10f4cdeab558cd5d2acf69f6502545881eb7a09d8c613273366f3ed81680588e15121bfa979ec3a593ce5c065629be17860bc3ef1827eaba3c3bd0d1d7ea22c4353574f4acbad0761afcae50d2d473a3a23b1046c392c28e063e078e735ae6d21c200947d523570f6b94af33040facadc374512296970de6667ba22b607a6b9b17d225019e9f4499636bdc3a5379f3a795a2c4a03047d3ee9ad550929e4748f7cc0d68aca8ae9115652c57ecd03e7090ad39e92b7987754b070c29161357436a2093da99f240bd8c81d6b0c68b9e7bf8a2d401a9f600275ce00c0b7c30f2513a0b75f8f63619d655364e4a57f2c91b9fbd08ace8109f502c99629bea92a83857efe85f9f43380e0093c462d60ab284519d45d74c73d6d521d916ae15fd90599aadfd3a746bce6700026e82a48176b181ca82e2ed2cae055b4ae7e28177787d3e89735eac5b6d4aef82933a549880582edc64b99131929002cefafeb759fdbf01eadb53420096dbb7eeb95597b20501bdbabf78d2afb727cf693efc19063d7c0f8165ae7e385897bb397f5be3b1e4e9a4484da219c5b9ae9a96d0bb0684cbc5d28e2e1bf8bf053c8dcd80b24a6d86b2e0cb941b05122cb421fcda3d1aaaa9c85a6e95dbcda20d42025ff3b4895bf3e74e51a2b513c1dc371f3246fc4945bcc6c1d75a054f5b0395ca7fbf69ce793fc3179ffe2bedc95067881a9c813645b648e6629117ac7411e10ac5eef626bc3896e07fca6c99966b36123e33e2a6de9b5694191f776dd0483c567a7800cce31a88e7e90f8f829826e8408827d75ef41b97b01faec44ad637d4c0c8854346899c7fcb9a27d8fdc44d166b0653aa1c064f535b35e8bab09191f350459e88426ed84507037d5e89f0b441f8ac0a1a031fa551f0dabd8e5d1683330bff5b2df15970ba7aab62e12574e34fca6edc2edbefd0c763d4cc0be8bb993b9638f21dd84fedaaf650618afbdb8b2f70aabb9f0b79d4fa7b2532cbf3e27927d1e82e6b68f0ef865d89e7bb823b9ccc0cd680be2c76a288192d05ea41c170decd5aea93f71ae0e32d4db55bfb32f9b716e1ad32be5c14e498501798b377b95399efe1771ad6d416887c61117c88e1b757ddf29c79722455a3a6ed5a7e7a622f71e0746d4845ce8f199018137096d353729843b495c28778c9a0c7b6076227761d3c407a5e2b4012d09f3f4ce37d3e23a41fe16593fe145fa68dede283d6fa439ffb8d363f22e19897b185ae109444179144f82deffa372d9dd45785ec98e09273b72fddb7ac1bb51082bd87a9fb05110c34997c77664ec7c5e7a5995cf82d8446988731e8072347087d4b20e84caa91153162e08c69704b5ca3c3eca962962cc27e7c06df74eb2ef6743d0bdd047de9835bc66f21fd58b8f69ea7a0892e2d4457f13f83191fb7e0e4221aacb6e7c48a82d233390c25b199cf7fd2d932e62b194e0f3447d7359ded6950451ced59282bb10e487756dbd8dfcdfd2683700b8fbabd7c71aa1019fae9892af1816917883f2b92475fc772f8b6605284ee335b255202ce3fa390dc9011d2362b32e35ccfa37dc74365fbfe46646744be3622ef559aea3620fb8fcfbf1e88394f063e141f2f24776fbbb321b70748952f988c96973d9b02a0e66dc68bfda0f7ad80b78b83c4d8952ad398d106649239f047a7babce90c98118a7b141cf6e32dd0dc856fee237766fe63010dcdb5304d562f760f607cfd91ce044a5910bf35e23590bf119fbec9ea5afeea2f6f8f138ffb7480084727f87e45a3a455992239f675d6bf6df32b3e4a5421e7658242b12289bced6210be2fbe54f3a5f12c5352758a02e68ac795a0143e91e099a770a84632f39a146de00d4b4381a56140f14e8d78a7daf4252776ad872e2e95f2ea38bfa31b44924c64f15cf966f1a6bb3cc7365eda37ff5ee70929e58191a6160eee78482c49a906b2d97a112895054887cb8ab56022042ded786b02f2c37fb547eb6f3ae1a045ca67cf09df23379b2fb23164f320df6bc7330125c6ab660c68cdea3dc8565ea24b5e8a57e47c6c3bab4a2a83c474678f8c8ce0ae9840146e0ff69462e5cea10e300172c55842429f7684f7e2478d3ce2945e115c7bda333cc77be527da4dc777e1e6a33fabeb82bb8dd6a5c70f3e849999a892d0327166e3c92a7247cb8e5b05d09465e26e098b781bc4c60768c971e74e81976a3e1a24011babe8a51342e54369d60d734c21e99511b2a80826079f8a3aafe7ce04dba976e048c48acf7604c17dd4604c2677b6a7211f6745f6fb49fe4db11552918331bb921b75eddea1dadb2cb61f741026283a5abd30665054c435b85a842100517b5d93d229212fea42efb8a66af2da65c3669360bb9ae2bd550fa4192b25eaa588db11ea818976f483b422b51db9b65fd82bdc3e49ba03c2a7565a0238b9248d3be796af3aa7d603015b6bf228b513c9057ab1457aae8ee313aef9e447a0e935ac82962f556c0bc6e995492713670ddd115fa90c1a5c823802fafdf636f281e2ff7ecb3a79a9f071e882afcf654f5417248fa32742bf39af1ae43a3b35dd12d7a880b726cde7fe67fb0be3dcc31b6e7d737b5d3419bd68fba009c5ccb423a535e1bf2b24726b32f6b88403a2aba420978a1abf28e25dc68edb35df3720b8ec824bf115009d02bf32f5b67a768a6e49e883c98785400abf49c9f0cacd7254277e4523fc6d86fe97ff49f25b0ff57ef3863bb1ae578ee27740e1870e1de86432f970d5307bf328db8659f610000c58f9f38bae98042e126f90bd0ed20cb5c79482ebdd9b750b373718a207448a939d318d306d2277c43c8191b32f3fe2176e02270197f2149018313e65d61d804ddf46a8894cd36cb1ebf3ab1de41ecb1442364c4dd87c621ff25a5101974834286623483514bb5b78c343fb0b14971f3eb62ec59cc239228e04c5ba02096ff38c5b752b317a130e1a5e381e34bcca8632dd8df4f39406157f6008f4753e563e9346775999379e21c6b4c9e4c35c9932072f6cd86282438ffdc8e4c587344716913a9fc7aecfbe6a636808b82702366ac6621369b225411427175c16f8935ab2169bc98d7478955fc8e67df7a37b4ebe31fc1f7456f81a46243f8aaf6b1efee7ed4585f32004686d1fc29db75b3aaba6274d1df38efa540303b89b6913a17529bd7381b7732878bea174e67369d9bbf26a8c59ecd4b11664cc41afa73430c55316e9a74732fe231de40197b1f51263b9a2d8d2824401514fc73d55c66673a057839c95e2b12bba6738858f06704b8ea2fc5003e61a65e282dff61bc56ad2b3a94600dbdfb1b24759eee1df0cdd5cbe409d7699fa7905fd01b9c8037e26d14e112ae86cf95f0b4ec381c66d1adb81a6b7375a9b7a021a4390581e36765c6f74fec9fb2b9c2d1972bef4a280bd8f766326e73723200376229eb47365ee797a972703f143f5fa89a9844477437b362b7f96bb2feeb8cb2fdf65de65c6f55fddf370435e45099fbf841a929dd499fe5f6b7508847af51a4bb434cc790678d52fc109d505d9e58989f48bab113666f9eac110fd7bbc8bc5c3e83dc0065838f3691b7e6e53a7cf4eb03ab4e285d02498ed00d33758ac5e547b934a772c6e94d157a1faec51db0447bad913d8796639c7963766ff0ae9fc56a38ff1118206188fcd781b48f8b4a90db837d5b9ea3c8587ba2dfc12f19897d4356bdb461fcc0b34b54b5210116f47e0d10f48823294072fdd85ec5fc75d390004a7fe5925d1be3f58880b8f3c24e34ee3ffbd6e2fc8f2c7b11d12e986ac5300d8f5e08773c258b484ccc2006505064f282e75f647a9326578d6870b36e6a7e6f79111e8a606eaafdb119168facf1341ed7a8fedffe9d30b16492582ac42d01a9ddff368596d5ad47f2c075e878a427a11f6ba8cc94c2a81d46c2eca3bf72f362eab7ba53290a1ecdb78d6d73b64c45a51f869cd873eb2facfa2187e868828487fa77e9831049133588aa34d5cbaa3df89133e9749240db47fbd76cb46f3ec752918263df85358020b514fc02ed0788d130d8e3070865354c6fe043c559d09502ff3ad96bed5355fd2670026ce7fa19eef65abb42839286aaf2e3777b5d583dbb86e3717e412e780dda14647d023ff7764d82f220ef474a98b276626887f8f176be329c96800e4ba6c9300a5b90a23799ea9adc387f0843508f48c6d133ca668daef8ab687ccc9215409ec3c4b80b7e4de7549d0b6f510afa9d3310296c902a16f64d539849befa44533e82b2be342ab65851ff07ed83de16f91bb562463d52f9554f268850b5d75bbb52ccbd2dca490b2b3adb8fe51d4ecf002658bac1acd9fd5a7e2ec0bb1a1d1c5bafb07ed89f337e06c192b737c792c9053172d3a5d2ac9ea0d9c01737b4e13f5ebfaaa6ce04ffb133e37db0cf8ba35304440ba16ec229d6ea43faca4da42d4d3ace76cee5892c2a62517f4af1d3ceaefe7fce6e6ad7ebb2e120f2b06b4413b085ed3ebb6dbe3b07aaacb978570c63170acb40be80a5b899cdfa4106309b7c41599a45e128b461459a04aa4fb00bdcc40c3e5b51d84111498e75c84002c7bfb66ecc9b5290526f559185553419c85e51847f3d305a72dd35376d9252611bb45b1250fac3951fef6a68126ef2be8714558af753b75f9121adb8c3d79c570e8ca2a51d0804568115ff69201066ce1e2c6f0fa07e8527f107dd05680c89fcc804160ea77d78738df5e23fdb3a199f315646769dd3aab1a45c180c087c163267403c3ad2ed5bf0a8c9bd367cf0529915f97ef51b6f80252805ae71179ad951fa7f3d039c28ed26087d14d8443003983a0bd089d05408c1cb0e1500ec27e34ba6d49b34364297c5d92c561149437dc0ca96405aacfa17568dfeb72f9e3a193eb7cdb3a7463d6c70c275e9bbffbcea62f98291b9055806d1ff384022c47619ea4d5c1e6281ff97e382b5dca593bf04f48c14a8161887ba2f38e686c7472cdbdf613ce3c1d04190c31004233844bb2da762b2dcc14c50b1753f1e7313c781933bbe3fcf4c8fd3ce00071dcf8d2e32c0a5e4c666690a7e48a780ae4e83827fb1876202529c6c45efd1efa7b232eb3aad89fa12b7c09ddce4c43a357e79dbb718ffc8d1c87c2ef3bb14bd484ce968f6659fd386ca0b0c357249fc4777fb0903f078963f501327dd6bc15fc695dd1f14c5e932e960d24c735478916b4f5256c4e00f4ad1e603b5e3d0faa02b48033878ce300c63a9ee0e9959c68f1bc8bbfcc9de220f596bc5000ead150fc53c9d6d6a22ea8e547c8c691782c1f7e52835bf3e264c8ba06b2fbe8ab148551ac9c04c5227f7ce5a2767665932654fa031f4ed092d20538b1b4b8ae162a0f01605e3be164e1f7553d813454bd3846294bc58ceae8b7b506967beb6c4bfd88cbf9a4ef35fafadf191feda23c76827bc815e36b26cc68ae485749b0a70faae251fc825df40f2d4d308b9fc19e49a7bb54f8cb682440d16dd4d352e2be716abe320a4a6d065c76bf7e4d7f5246fcea095c09be0868825cdf5c94043215728cad3ce4a43c2048e03f878c65cec0580ead82c3f8130e762fdd883d2b47778de73cdf1a32ff12b724d37ca443fe73ff35a6670dca7dcb6ca1a15c3944a70820b73015256148d25f8763e0d97fbe5c9deefcc09a10bc0604aef0c012c0e0ed53cb4c64d80400832b9257f54f93866ef5b9c77c27f7139c9323e6ffd5a0131af1ac938952d4e039ce759586328627bb46bedf10ae89bef16bd4b12ddf26018d2d277ef23e259aa960fcaaa3a004b27b5e8b391e5308739dfb53f38038e5086cbfb2eee892cc8560d5f9952404943f4d96f522f1ed518f6d9e433f97166210de2108fbe3223f3e3663d47875b343648ac3f09ddc1430180adca55b422e2990d15bb390dacd096df81ac4511ca1f056528cdaaa23bb323af472c0b57e283bf4fc44667e4260c3b9f497cd16c65b4a1b71c7dd3ead6e0dfd580c2b7276d1855c91d3af18623cc80074e0b315c0b900569e295f325efc5cf1165c1b2a702955601fc1f0aab4bbd4558f2af0e9d27e2906bc88c0e0833b9941e01114e295817146405cae013bf4820800d45878ab4834e5e5b3d5d5384b9953e76c832048831450851ec7f3f5aae0512647d86cb75daabb76b72defdf99b9b654ff8b7a5573bbe4686844c468404282aef3538a3184f2aac3beb1c192db9b184ac45613feeb9c58a9f5008926227ce40758656f0124be5ff4a57cc0ad9de6dc4210d7a0c41988e44f418aad28380df946ade49d7804aea853422850b99fabd40fa45f656a9845a5370e1155d64de7c919154fabbe67c952221f4012da2d5372d37a40baa102e7be2a94baf20f59c869cbf5bfed2ca486cc98d3bda540031082c81e8c8a49e61dfb495024e6e01194ae115f34fcad78fcb977ae5cf24c0a46edf43711deb2ccae9fab70eaeac3ba856cc9bc0804dfe0ce0266a2fdf8ecce3350bed213b6eeb742c132071475fbcbf5248119cc06bf2b57de171c01ec99ee501c270d62b069a2ebf54aa28c844314f13e40e53f68de57e8b50e71ffb2cd74820623bfa7410734979c92744d44d9e9545cae5b8c85ca870587348b0e684aec1319cf30b8602bd701116ee67a1be085e73788ee88dcf03addb2e55e19f98820cba8f5d87bdd7877370111dbbe9d1dfafdb7d50ddf492170f4460a1cfb9d70282f087653ee4956c6e6b7d1b1a953b423a3fc0a7231378765246f4982af34de1b1620ba1bf631bc439816c33d9fba7421b71edbcd12f1a6aa36dd38125017fcfebf08dd9d459cf8d9c5385eb54f961d63298ee701ea06c20f6da817c66806d3fc2918a332311fe96ce4086f34f8b38222a3b3723dbe1bbad54c67c64f3e50d9b4395ac86b0c42cacf5e8d6910a6a49e0a0e42cdf306006e79f3df0e6044cdca4231fdf95a7e2c6d162c08b6a232460d5037ce1b4fe3df603b45a8a344294bc8fb9ba5ff6fe28128c7589674cfbe85874f0a02e6361755678d226ed0277a13c7eadf7c2f7ed5c3dc8c05fa7da48b17ab233546c930a5160b571e8c43bc2b868f8deebeccf3d5e15f8920c3ba95d83af92e1d728af5900b3344ca97e59a1510599107ca767d145de421008b2510bcd669ce92bee269631355a911249ba2655fca8db703bb931fe30c24938c46748c3af94580a8292a2c87d882c063110e63adbcc9648d890e48e291b79ec12501ee3187174ef3a42324d281357acbd9ce3eb1847c84a85f61d718396ec6e2b3285aaf290c36e33b4fb47a7c24fdda92524c86cde7692db467b81f23d1f7ac6e47b314d2b64be4cfbe1e728cb05f556dbbb28762c79b4585ae17af0147b9954b840436f05a59843c296b26e7a6a0db4766b9fa7b4d335c8e1b31185cd2e390b5f38fe936e1662d480bee1585052a261b6a89a6c5bc7531c71ce448f434c4c805801e251a5f07bff9932ddd2e61be08b881de7973770d856d2cd60afaa848b01fed91096516371ebc9c6bb22e774c85b03c7720539860d5a6096ef75afdd2daceb7d4a622d68842cee421432f1c9cb5bcd9d7699e67913e993f49efb4d7648705a4525897a093cf3827445b22410f7d85890f7fc92100a80eaaf90be60839fa932d001039a3d333369485bb1cbc13c565f1b2f04cbeabae350d96ad5ebb2729d815be5343268e623c35817c3c1cbc1856d92f95d8bed376ae0837a80cb1986fcf57d378a298df98ef00bffa8d2a12bfc6e6bdafe68cf959fd67353d5c1eedde9dafedee4c6e2ce089ca41d95b09a99005a84704058e4d43a38f3ea2b3b035409ac4da4bd0399386dacba17805ed598cd70a32cbf0ab702c6f41d0a7717fcce4dcb5ace3228ba015f726b7c498bdc879c06f5779983b2528785b262115fe6b9a5b794ebf0705550c011bc92f406366614585b6a570c4156b9e90b9dfb12cbeead7975c251c1cd0760c49499fdfeb46297fd25b054dbe78c3aeeb0d4f0590841ca6a9da44de80ed8ec1c8cd27df9759ffda19759c3dc780f21ecff45e1ad1a6cacfcdf2eb5bcfe4b5b9d48008343eb3234d4d52b2c7622bf9b10d651d14a0da5f2ed01e707d6ed2e988d627bfe1e85da6d70c8c5bdd679d913c2f91152318040fa524f628219f6ac0bff70bfcdde65ccb9b11229daa6d2c41ebf6a5926512421b2242f0f82bb7eabe70fbf3c0fc90df674cfad8c64edaad41319f23e24ddb7524256e11b26e6ae9e860ad5110ef64404170f46ba6887b088100e5f93927968159e7165ce5b392314516272c1d46edfe5aa85a3b3f8d314645953654852c9f799100c58f1ba5fddde91cd29871e8e09c2581d1e9412025da8aad1bc609e1ce101383e3d32a66097d2df6c0252db9379329b377e37f89c383a7534acffa1a3e99eebb6468612930b79a8b5d84a3d39ebcc840d58751eef986c7b671f59552f20637ef1835fac06b0583a011b9b70f5e09aa29bb36d2b5bb4b4c77065b8c7e9f024aa7b233f9c907a1ac39a94c969ba88094f81960018c4e14596591ed8caf7944f8c4cd8a4abf2108fb4f3a9a9e929c7b1dbca1e90ccb7f54953e5597aa56df1db86f14df7eb5d2a11b0518db981254da1ea834bb7cf222ee978fed74fb9e6bbe1dbe978b8b546e235d93aa4cbf3d9eb12442bbc2a18e4d67ea2965f7227a4e571a0dd1b03dd5c8d66307df01c6c1b2e9b97232a6e1c70b0382b216b5a999d3d9edc721e7f0eaf97453afd137acdd398767c132b18ea14e9f250971f1cf7e33209086ec58da82aeacea098cf6f2f6c35a80780289e0e388234fc0db652f724ebf0389f0ad91e906e79880250c9364b0b091ecb23bf9056724418f608d3b9f7c9f506c49c16cd43f58156a4359c05a7eef1e354579af0ad067533a03a6556cb85a550cf74e1723dbabd5fe82386b8ad82e13b189122c8569ebfe9de3b22236014fe1f1704cf1346fc960acb5fc7a77031e50a9fc8300ea4c3041a54a6fb0c9b101e879e63469d67f243257519d85a2e3b795901d1cc29919db48445ee5062ad6d000133c8a4ad98a24d6f0058171ab75f19ba7d85d88e10081115794844eb586ecf55e3b244c29cf0fd292845b932674ae66c3f7ca9f04dc9b222eef76f4f427e679bf51b142797ad4ee3ac1d76e4920a7efe7752f0c2d24a35f35d66edf55d75b84e75e50cd3f29b55fae35816a15efe8ba56e6129ec5b700f857a0662747ed568879e165a664c06f51d1c15fcf0e3d4484fc1f672943874f7c9085d6ce523d306d096b9ef70fa020b67203621fdf467ff251074f8edf581ec052aaa03107ae493c7b5f9e93b29e0232b1ebdc67cc72d100a0a9b2351eae489dafaa6eb5dfc6d4efbd41b002368935699b5de0f9ff94a532c8f0729b07761fa6da71be6a3c5ce4f5c3c295d3071b5887ff1eed5e1e475df747b74382cba547d57b432b3aa4a5832c0ac0bf15af6142df1cd95dccf297a5718029c007fb28806b09eef7c57572d1e9410d60ba102c5604520c94ece70fb49f5499a4ba2b4ad4f4e9712e24736099c9a642babf98f0f88d16dec6a646ece1c67fc80ab75ad43954f12d7a594cec0ed7d7fac61cb4a9a842f770f01414c0cc7e49363c120afd9f0813b1459225c2f484588eb5a6be47a5eb56b2b2424f5284d58d19255e0634e332ec8d0970305e675cf1943fe390b32261de1d715e37fb1357aef6a75a6f6d336d8c6db05c1a3782391752643587711009575d26a737a49ffd5e987f70d41a58dd68bf526fd7f7b000880e5cd5bf4ebdd73ea5aeffd2afa200e3dbb386fdff974ab277e84b8a695e119145c7577924f2dd22b4f36f4527e5185193322dd2513b0393453669d0d1e319d80d5456578ef3bf3aa29e13d544b4c56e8b911b9bbbeef07d10807a3c8abd7adc3bc199811a50a4a15ae764c5ebd0d420d4a35bd3a7a86ef028597ea675871df64b9e5af54a61aaf1cabea3bce372c4eb9eac31839645c123869165d1d4362c07653ba5682015ad35599c561b6a70bbf929f44ace41f0df5918827dc8c2108677c538a7b501c5899c3b9001ab87015cce3c611d002d7aa0355e10f3ca1bf97c518bd5d447c4bb1999d9ee0b387afd91bb64e5131356c884ef726a243dbdb4b37778bc869cf649e8bdcffa164ac9df54841a50075a0be33723768eeeff54a58fdb7120b2549cac8e14d460526f5621e2d0f367cea2cc46d43ab51f9065bff75f889be58a0f5b674330a077ae0dacd755ca9b12e5c5a676ec860c2c89558faa38be4cbf61fa3bbc8feeb3dee1c948adaf52dd7e55ebd643b9ea4bb8863ce7ebde2097c8f0f9209c3cf51ea63b9937693d2e4682de05ec0d90e4e5602732985f852a4bd8310a7e2121b6409cf876143ab3c56ca072e474904ca72093d8d876a86312d30150d0f8c0e83f38f968d0b86ce8ad5fe8f7bee536b541e695de8956dcf34b6c11064f50ccf3f03485b91add20827cb9f00c485538f6b11acfae0624fbf06d643c1e17cca42ba494ac172be6d6d713ee5528621eb866ae72b55ea500d3afaf6571741df06dae28f416814fdac76e93bbdc8ea17dc2fe844e4277610e8f06b63825c8456579af3b46de9938cc0baae6f401e02f9c4092f9a8a76e24a3f334e11a86155f40e7b124d24120bf77695b3dcf5621026fbaf854ba968817a8fd9e19225ed6801cade6f74eddb5803150f7c43c7fdfe6885d33c28dacf0822ec019908b29a4793c87c4c6fa8cb6e81562b16fcbd25d708680c0f7dc61c076d133a313778247f1feffbed5f28737126c45667beffea0a576eb3001e202a1916aa360ea39acd14077d35fdaa4804a0bb4884c15fe49197f88f18fd4c08245e65f5f76c084d6d9dcdc0020b628b873427065c907fb7dec362a55fe69f88b9a3ca28c2c769b8d7f2ed811541c59706e8c3601d29a5aee72d2298c7e52db6edd333694c251cf5655c3a7ddac04ae72645db3b6862af6f8f67e467fca1233ce8e17904791a459067ab1acaa369f50ee525fe8dcf06399dae7cdf62405107182672a06221e746c673b37025e900f0f98ad6e536e74fdf17f4e8b949c089cb6ccb2c9830ba30467d2f22e2deb39fa995d7818621b586039d0aea32df877c75e17195fedf7f3833a21831c67e5c1f4f0e5734bf5a04975d71de3aeaf3fc2491b4b8d61619649542d94021fdaea448cbd92c198d61beb05ca35a3ef65ead525905e881ec6a2d9f18c354401bcdb23461ea9dfed30c356c1f04fc62f4a93bb9be1dc876ed5b2c1ad4d27c33e6c84d48dec49d6cbcf009c5ec1fc7d00a8937c6e4ef89b878ad87889e84284f7db4c7cf887e4cbad2595a791d8442ae8db962fd53e90fd2d09506af3b9b34e65dab118c7721a8d891acd3436f571a2aef26040d09c348bdaa06f56ebdec53c974bb6958899fa57d8776e31104c54efeced13144f4a8fa647ef0429f82df60a07b3802f8cdffbbbd7ba252205eaa2e4feb799032000b14d61e8572e5cd9c9f89d7170ecbbccda871ad5f10ba9babcb4e4016fd3ed88ddacaa3ac0d8ac5f91de807d66f95f442d76f244cbee8ecd23bd8d39610a2290df12005530e9a3177b238fbb2f504b7e1d47d3d7be04429dc088d5f03d9c2b4e254bbfe23dc17c45896c452c4d40db978ae1d54abeffdfebe6490f6b5472e0455ed0ccd0aae36ae1b5a767f6113ff9d04843a52b965ceeb99315264a0017979d7f1bd91d71ba52435c479591ab2f375e79c9a37fed9d45cff669dc75460d5ab2011c964f8e563f15670ded2ce08f4f9ce8da92db8e6e86a67e70ed7855cc0fd0df8bda41514362c9c5011e28578b8cc9284efd4a40be4ce8707ff19e60af9cbc736ae5c6c40e85486a48823d9e19697b29630385e41ac30200739a2d2a20aa32ec412b57d4be2f90249a18025fcdf02aa1e0e5aa54b51a9fb27e2802fa4f2f8df0cc7e945023eb4dd93bf852521dfa5cec98dccff6785db61034d3f4c10a160424b4e0a3a444d4f802b9ea446ee27a29e2a3bb79b8f335989bc7687fede6d52d6bd7292fadc11a6574879e749cf17ce34374ba2948e071d214cbb537823af9f3cb83c31dc1858d48fde164a81906c40e23fc42f34e3052d49e27326b5d2b45d82b9c3631e2ad5fcd0339ffdcaf27b0f4d987e1e581921b0d9fca7794","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"9fcc68754324b200cdbe07a30948901a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
