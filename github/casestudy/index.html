<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
        
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5358c99eac155a6c331cad471b001f7f61af69ee2cb8b85b8b7fa5087f4b7a8b206bd6ea335015e244ba13177db4f62fa00cf5bc89b3a17f5c06d916da6d39cc0137e04a65166653935db07861832da618d35966229b0ad2b47469379e82e11646a9dd7f3b4d6b069c01f275f81fc9e1305216cd7510bcb6bf93b10351c43e7103aef4da6d37411e12ba0c5f8ad0ac734241bce3c6641e4bf0f10b1420a7c95c5a1fe12a7bcbb814edebc542b550361a549d24d9f05dd8aaf992fa02d5e79440bea66082999d24ea726981bcb73384f226ba1bf7c7be874a5a2176972ff6759aa2ce0fa97a60204b38c619f0bf9e1a4bad6881f6009a18d5c846b76be21f3c5ecc70d39334e8ebd621a5fa1dedea4c630d01496c9fd774e90af4c905ef816ab4e3a24d79c875f52c706918fffad207165cd6c2bcbb9e59a34763c9338ea8baed9125059862dc0c4deee427663fa07a4fd6edfd091694d22bea15d8c3e85c348e937dfd5fc10c26ce91d745f4a8c29010449241b78dacea10f323e020196e6563c6c9e126fd6246cf387dcffceb9b213974437c0c5fd582ea2c828c22f84a420687c7b0e67f058df18c8e630fea130e9b664f2937b3c56ed62cd96d7586a9f59a7eb6b50ccfd70a9d3f1cdecc08e121936c4f184fac9759392a2b02200c7d89c91e00c67b9f4af12be2dfedcc335dc4c6c12fc6f5477b7be88f65f51987d2a52fec0e00b756142139eb82d4090acc5ea099fdc5ac2620d415b464b0f42509482f809c6dc43699251a45f984b16ab0991624c4a87b84eada591ff8a9b37f0063734dcd8a757c95632ca15d070497fd9061c9e894a465e468de32a318d44c9e65674c35aea213a670a3216f1ae45db0696168cd8b6351f785dbf6ebc50d307dce70d1522a01c399323b67d77a3777943e7ee1673c4357e1a7c40d271dbc1c3eea2b4591caecc13cea8397d55fb41d6149abff975999156fef02563f5394c173e74d6fea793c5ed86c52f0adf9d3e6e6d863bf4b39cfd9fba2da3e02ecdeaf653892985a0f9b7d638bcef074a307858bfbede93d21a8cc5a6904ad5a276c307a64ed5bfc62a78e5d3726b6458208f2c46f2e069f90084493c3a2ed79df1e2cb154275b2aaa9686cc3601b6b0f81e95500895a9c50db3b7af8aefcd13a0b4092d9be966de33a86f3d812417eefaaf3d5af13563e47bc20322b77295ba5042d6cb48a1dfc4f5752fdfdfd3e494f699289c2ec1e79f273d024ed0c12d0b5e8674566fb00bdfd53f3edf48a5b6e0fcea630a55839e9d24c00bb9e77a17b81bc8c487cdca9a9814f34e3b6a0ba8ddb7622e62f4aa90d05a4cdbb7e1496194fe224dda00694be084dd26c87d70e2f0f0d348b606ec7558e4f2a30e8f17758faed1aa88678eb9c25702cee1a259a5a4ee1ce519ff46a294de8e43c0fd04b563d918c3d0e0e3d14f9e1ae325fee17d66006b9c88317d9152b78af897a798e98e0356b3257e2e623ed5127849bf484117f128c09beb1eb1dfcb365c3d67feb0e5dde576509598ac32b3cdf6c2262c2c28744f6a8101b465c6262689d48e47a8e759a6942d04d4363dce4ab75ec1b28dda6714718ad8572f6ed4b4d47c04a0634522eabf17f51675d471d637d98694b33a4890c929a0b693ede53d4882ca70b458d812da241a0f99a6cf5a1a6d8f5822146db33f08113bc6a3bad407ea12b70d3573196427be7b3d44cb519663b373d96d92b0cbb0ce479a1c4f070b1f93bb72a51c5e8ef2c0cbf0dde09dd2502ab8196e3e57da53b189991d1344c06796bb4a72091a8531d434686671e85e6bfc7b54d6ec8a286319d7c445773a3fea73cf63fbb42588eba566e109b363e836c8eaa283115a4914aeff4b13b04124e36a8ee273c498ff83ee1b2dd8667625410443993a370c35c4c905c4c4a9fb6e2e6affd343d8e54b99fd04437b4243a7abc5f5f351e9fca6cad4884df0871e42d0167bc053ba9cbf6e758d8935d2754dd1ea9dda28d0f6bff9b35bf799076936c9d7fd94e9c20d8aa069526206d324fca71f64eb59e7466039f0a971daafdb24900e017731430df9ba1be470502b9a4623c451c110b87dd9bf09e22ccbac1b9b97955a64173098dc95f806a683ada0aa325a9e78a312eaa06462d64e0a1149a1c37052f262393921d6daa50dfa923bbc8edc60b7f8b69148191bc5e8047c216a997f84b3eddbd1956c100e1c5e32bbd6839b6f40b84775a32fe19cbeb903a97472ce821dd0e18868af728408e6c87e8f223a7952f7183723c7c2397584639b112043143d52f85b91d6b928ff030285a729bfadb757da52bc5d8c6017a0db5ae0c62d6a9d5aae14bdab5d4c329117e9ff392099f261df98a096b43cb7f4110a1f8669947e5f8e004889e061a16d6c9bb851829fb062c621263e6ab76b6456123bc323b7d52f5bc4ea1095224bc026f3765ea6b0801957a490c1f2fc9efd0afa9ae2e36ab637d6ab2ab5a39b342e0d7901deead0d65bf1bcb6dc97e3e745c8b92b82f5e6dea94df9292cd7de8b9c802534ebc73c67cfe9e8f947960aa881abb7febc166713573669d2ff873b44d8aa6f3397189961cb29c2bd0a7238fbb280b49f16f622d65354aee4743ee6122ab1a533dc88d47ce32de8198715769fc44b1a6e6fe3419a93ee391c760731e0c37ac3c4006c398b27e587832b6e2ecba81629a0109b18d9b6d75b8e89e862cba8913e0c60af2f5278b7a2b674b190a0045395218fc6759c8ab8b08db8589e327c2cd71afeeb9c05e9b675155b0927f9a4cb7d44a6eba51b48d99c4836730f581cd77075987e9ae472a61e6fab34fd63eafacd2020870480aaf92e617b91a30dbc9079b9b3ed0e565e9555f63eb4f25541363a9c9dfad8678423482ba71306c737c8eef03c0739bcc68d0ad80453e32d74750cef43d3216ebb74dd61984168ee30c81e72b57a9649bc53d72d795b6fd37f6327d6462a719797067a17f761c074e34873c0c36bcfe37c33b0122bbf49b6884594d26b1f94f254d08397040ad4fde53041983af86f2c978e2c5f61f093483e129b18bc24b7fd1835a7cef0959869e738222e159f222bcb3bc919c32beef0b190451574040ed9302e174f45ac2d8a1cc4f3b6df53a6382fcf2e874f6c44c92281f5fca334efcdd26b2ca8c8cd0b820ef54a3a4a6d20b545646ca50c14933bf463f6f9bf368ebdc8b12efba191d94dd0475cf90dbab35a73874b7b028c0066a16f83a8770d3c24dffc00d0216215f02c921e8f47b4c8936f6131af6d17c6640e1a49691f1190f18e042c34467ef004f696917ab0a519dcbc88c9276ac2cbe00354258d3763b973604c1790a7bc7ed7a5cde37ac711b89c3f0c91c072e01c8ef0afe03ef6c8321392665043f30e4dbfa6e60d718830e0fb2381f39805e8eee8e1ce3d1fc5102def201b8f398f50f3b96f4183644769d30f6cef3dd134a3780ee50058affe18a9c71dc8452603a8245faf732ba756061db3cd98a6110774085bac68061dcf1aa066d5e587a748b24084297804526cf2635d04528dbc4ba48a169da4eb47df627b5e288b214b2f37c976c9fac908c8f9a89eba2bd9f321f11a2f556928166196a18b9f7f0a602610eb69f62a0b07129f1ccd8fd9a0d5c67d9085823a85191701136b9fafd8a7f0b6043ad39c98a099a5316baa0d923bef7f816edb62422ede740e0614fbabc952acc9655d60c2e787378c7d4d2ae00f212662169b7950f90c069f25cdbef43c9526d6922bc31ce7c54921d6e161cacff614dbe459e6fe01ab51b3149888c4de7935352de541d0e0ab4596f52312e49495a81088705a5cecab33e1cc9bd3fdb4de3b83f4f2659699cb6dcc695ec89ab946fc7d2137571c9b4310298b85657befa9d2a6d8d38d940648903cbf9587943e517992a28371728eb4040d4affd0c4a262cfcd162c507f34aca6214e20bd7664f341e819986680a4d72809415fe2bc406acfc3a6d0c968de664ad4a13164c46e0db793f03cfec0501aa7d6304142f9d1787ca9266278b2f913db1bdcb41b0762aabda383880962e9d0aa5518100b23238728f0543d0da56c282edd047d24420bbb0aef4f64357760eebb7777ffa9eff5189c1f67ba2b44f52e2f73507e3cf66c3b0d8c75a2ff27ce330315a611b8cb4d6747695c3feb85056dfd992c3c1115b9cb7d0321b1da88e5b077fa576cd496cc3e126213aeaba99e134218d9742d58516d0a3a51bb6435dd7047b2dbc6523334151fab7481e66588f2a027299c1e3ebfb8318790e0ed364106e7181a7addce334947a5e2d9198e0fa5fcfd8841dc3d09491af3d4c74eaeea2e72f06c8ce786a35d3bb97025e26eabc8c0fb07bb85d4aa0864153703b8346860f4e7d93a2ca1c720e65b8002df1568f1632e601737a3953c4684554c7944eb0cdc3cea0681391952c670748a6a18f6b3ce2361132da00d76b30c32be8d5753efcbdaa40bb3b7a44ab6f9c7c920691fd2345d4bdb6c69c5e28e5c5904dd68a85432893bf5e99d7f276f20435cfb051eb866a0fb2c53e7f17913636f4a05a84421bdad163629406de000100f01b08d4b8d6970f443709ff1880adbba2147f23362f16ecc312d75ac034d007d1bd541fdbc30f15fb94ef92dd5add1b76a144537f6f06debb5c5f206be015a27989888c130b990dee51eb90bf5fce82c42f4c2f7e10d7e49ed03ed635c1b5b6bdbb850fc4165345fb7bfd6228fb2b0338d512e1e653e3130959ad072ab2cc6dc008007cb46c4843d778783a06b4469ecb0d5b21a404e8a2aecd4e35596bfb853726bcdb5a2d8e903207fc5fb0a94b0cbdd5d72759bc67966bc4b30baf89f5a75e3526b12466a39c56e40a82bcc1704b6fe024e22f321715fe08225ad577d9bf581dd7f20d0d7272b0569467488d665ae852753ed1cf82c4141ea6bc0b97503a22537fe63bd3e1a65699aa6d864de75aa97d7ed6129994624ecf122c1915aaec74795c175531e3cbde6c54ee0af76fed7c26ba6344df55d350e346a8270fe06a32fcaf7195bbc9d6685932239f6026d0d8f259c5ebeab2b5b049d904909fc45ea48c220b96e3abbb3226fc9375e1b84c96b493076a7db9a2e5313596b2963222e7f7305b0692ac7589bd5c670ed11210b32c4557d25daea67dc872c095bd38d8a1079f163b6575e20fc9235b2cc3bf312cb4864d4b132cd5f2be4556e36265fca0c7572a92e2d9063d6e14d20f7c8681d23ff7b8a65d83f90b2211a45b0fdfa17185b00785b3bc90de4f3d576e9d84d1110e98c008a751e117e7834e17f38bf82aaa390a86dc96a6746b6991ce3cfcd6c9bda383e6727dd13819e1c9bcb3e78a40dee362584bbb66239d9b41da77a50fcc9019c789246c8f73dff7cabda26c3cfc4101ca8d346fad7fdf3a52d7478176c6aabb26b6cecb25283ed15ce25047d28d288e89e2c404975f1b0c7570917b10f8b786a8ce91541e0deca75c03d46c72bfdc9c59ea10b2f02835a0dd8716d5e2342b4f3031c94e7cd7b01cb888735623616519840362efdf6f074511321185b7b88fcaf961ff71de90c736d8701defde0e10c26249b1a79cee4d022cb2e06248839c907608056fc838f2d4ad34b321a1d05e0b9e63dfc9f1a1f39f4fe1bdb30368245e0ef9a6d1406dcc4390ed774b90dd2af1b1d39a032952a3c3a18958528a7882d1877bd88a19779efb71f951397bf01eb43aff246537ef3207aafef9656107d93fabaa3df315c5d279403ba8618ad118a0db134fd9b38fbb88e255fb24e580119092ef00170f66f6f61541ab88b07cf234e6bdb5f6f6027aa6d7fe940daa5da2d4d96311127f7340497f36bffaab8aa962f414dad8279913bf1a0f207265362206c33ef4c0c66246f165a28da3c5a282422dd27b733b33c30995e1b90c8d1290af816b5d7af738f835bfd3212d1bb6fbe30355e5c375bfd583c0f5aff5377fc15c022f2b61575d67cf58ef532dccf701484dc1a57bc59ca3a2f1126bdf9766c3731fedea7893862c9df8763651014ff038708e4db87b234f812581d45f6a5f25157ae1c3126f304ee7241f42c1dc7e4c06c2be80fbce8f85976259cc63817c2f41bb2151dccf939a2b8797c81f5154e58eadeed1d65ee281d14f2af6441d8f9a06a200f90431b61eeaa8a35dbb86a1c5122e5f5f5b3405f9b72b20c1f8ec87192881a7726137a1d993c25b8f3921c5d7e20f4ce04fa63e2c4d176dcbad3a0c2bff5c75fd44c74c709b64d46b06bbf484ca1058ae3dfdba08ac443ab6600dc8b31890ca83330c44e1352c6a7dedb7112ed4cff8a7dde6bc4f3d23b3398990329f98d7cd5613726c0350669642caadb14d28ac2e592fb38e2afb67189429e25bb2f88833da552e18e84ca8789babcc4a5b183828a473864ba0f0652719bef80e0b609f724fa56d2745ee0ceac7f1332cdc621ddf110c95a980ce72b076b163def6e982f5af3b9f5580cf4392ecc8d29e4812fa92815261cc5fc29dedbee1a41d3877fed7b90aed422aa8ad1f081fd39ec4cd9715069a5790595e12900a4d291d4ced9a0c2a3d5c1b82aca22ad5d151e7f8a8890ba7db44da9558cdb952bd0dd8e2427ceee41871447151e46858acaa76fba6fe076fd945a21f47c006f2637473756bfe52505bf90305815dd6ccc53405f7e39f25d82f19516574487587e2a3562df78be4a03601521017a6435098bc847ba390d008d0517d6002b532725be61ee8f1319ffaa3b6a187413cad9b01c71d0a91d928f96d77b49e30df8663e2f81bbd058df138adc32ec3e087a5825d854f281427d28b9865d3023b82779d63700a0edad54591d98f05c1c35ee965da01d5b2cbe9fc431ab8aa5c21042e44e7cad84866718b6aff6c8035d5cc5df952d4360c0164c95499fd6e83eb2961ab138056209537108aa932aeb452c1e8100cffd9e2feb9452fc7c8bc08444234d257c48ebea837a6928e895ddb4a89a5bb10aec614630141c91d0ba139e9e1ad7341d2b2b2d90cd995c1fdf3c8ca1995826335af6b823b3849c697ec67b3ade9c0a4dd494626370fbae33ca753f63cb06bccd2efe302e57cd3cb92b28cdb35704b03d872b0fe9aab0fd6d51fa7ab819c330dd7c39c45550ef88812dd303471d6b4b026b58c3f23343be7e5c2ced927df390256bc625f9bf017fa955feb03ee79d8bc82f0e9ff7fe8c74cf36138185b4abe69e1634d44cd8a0d976bcae32fb9aa1c0aefc05bcb22a4a0dce9a1311e8d9845e60d60ae57622d3dc1356b06e8c8cf26197beb9bc912c0f2b15f2cab29d55e5c36694b9acecb45ca4388f80ba158f9f7abdb1774eee0f92ce64634d8d5ce61fb40469d9123868f860fcb37a2900788e5d7e79e9162aa673562b0719fb897fbc6e5818ab9e194c4ae1e65e578f04991c257e55589fe7f9acb398cb538d707b2245321d251fcafe2782f1d3fc0bac30c239a5a629b8154ed68deccb024d068282957e5e18a519bbac41005fb06812a203fc6bd57945d332f7c5d5d6810851ff621a36e6ee27963db20a190b7e75e254194a4d5be742e938a3c4f9bad4848dbce006fd054c1d09cc91ae877af38944008529875a3b899f9366153c317e188ba449181b473302a40619cd9ceea66f968f7ccf178a09c869a4799b05caa9fff9b116523f4edd035166c61da80458434bf54a60ed50aa142d3fe0c4e7235784277feb81a8c1adb84b82428cfbbc172ff4d38935a6d58b350aa58ad614278628bbe5a475a7ef5fb8ca08713a5685676a4a4ab37dc7cab1556707edc97b3d5b49d7e6ce8872d4f20cc0abd55bc4da25d76265ec3b464c1133d8179bb03aa259c8c0bc24542d4b54c83a66fbe0f7c1563f9d898473bf860a6277d68eec8788463d69b6f96fcf04c96acc140ccfd031c53c49ba3060a4ecad2ceaa05e6c14a9c9ec8603eb76b64a9248707f4e662daa3f0faf292be228bb01f7ecd447aa5e53a41da788865c5b683ccf1027c0a991b73adc88b00d87a112757f7be161582047d3ea8dfeca1aefbe84e67f4bdd110133a6d9874f45deb6f559619613d5b519ea57d5dd108cc65ae503d8c3eb6e6a66f0963990d211528ad2239ab80e873916e72356d32831a2cffe51c78d61dd830da20038102cecfd9cd06eb6498819c1a8deb4ba1cf39ea21fcbdb4d25ded7aedbfd9369c9f56e64c9147b1ca7ff9eccfb48bbdc37eaaecb467a214ecaf36ab6fde32c4b46ee4a08eaf4b8bcb70d2d3c00009dce8f3cff58865f235d403ceb6f2110f782b4d942a3d373486486aae0537546fd3a1f6a0d4f68419fe5487fa101243deebbf8beed17be5db4e7c47276a6f7013687cefc899d44d24004d78a1b758294d702c4f49ac0cfcf43eef7d37123cc75b0d661b449e1b83cbe1e0891b34caeafa45ab1b6842cdf59a2b7781a4bfdba7af9353e8148d16cb50b4fc2dc9f565751d23b1efafb607c981255e8c01e186da3e415505b6cc94857e3af7eedad4c3270080f600926376c524ed8cadc54e9be0f9138ef2f273b10fe944f125112dc4abd8936767d98a6b1a54be0fa59e6dc62d9fe1fc1597ff814c7dd650416ed1b4cd84d1004afd1815e6d67739a48faa33377807b5fde6f168bf76b4f2f80edee38ee5e555c473b37e9516c789e1d0cfc928a373668a9317d480ac9f6aa54ffddadf446f13f209d603bbf134ae7dfdd92f75cda22f23606d9e6203a968a62d8eebb65343673514e7dfdec3a9a7f51e920f5bdcf9ae392b6b914a60d76d0174826ac85fcfac57a413c7a4fdf8afb02e0c532aa6d6256fecef6b09eeeb0d0158e2f71d4aa860b322f7b2e7bae7fbb5b9ebcd0bda95c06713115fb0ab31ad47f2d961af5f28b361f39919f081d7f39d599a916b533a1f91a297303624c32b2ed669f5a60a3db650c28785c49cdd919acc782939ec3d93d75b174b0029d1a1e6fffcd1436f12397822a28d5e8c7dd3f6d5df094da936719c825d1bfcbc1b29b5f5cf198cb9039a7b51751291ba22841df0eff277ba1125df6c161caec7a19af55c6cc3463b0d1dbe26d1f52449d9a02edfc03819306c628712954d4ff084ee8adaa624ce650aa3673ee3799028e1636cce421ea1eb015d8691208f4be617f2470fc0c0615ee3faaa77e08c44d74d7f4f7a53777f50fd3d4c444c1a1cce744a5a1791ff091aac1899e3cd9937cb29ba30d6cb374374a7e08454d284a8e29a136353c5bc7d48be6234f993d1ef2e1a57c62eb6ee43b8f3eab2ccba40e43999ea157c64a6a3a755c58614743d513418dc87c961489cd125f803e685d410edd67f9787f2536eeec9df35de25b76e6f97a00bf63d5a69604381ba6a8cbf69f42949d6f762e3dc6862e578f41ae0b5fd8cb43a45826ce28f0b426ca911ffd68e4105d71d0cf73dce70d1c2f4e5fc71618c524286ff0b1c53779850c8b92624765b9b8b493f8a36cac247874c85c28c1cafff09384ee1815a6bf199742d65ff4bb6997ec9cbb4c98b218adf6f573e0b5b0363d20d33ff0233fc6038ab0ee97b23e77691ffe4fff30339687a951f6b0a33428d010f89c87acda59e584b437b6105b3f69934500061e6f2ac3a20e5cc93a3776cc8709a55d78c113c44958eeb2495c2d6f89759d7d4aeca821cacc1d27495598d0792cee1193efd33978e6155565abd11261b49e02d8e12800c9c21133406df9f0a0c86cb05021f2b16cc3b2741bf2897392165bac7355e68b4dc942295f7b87357658e91cd039f1ba9f1116bc567bb7f69d9632054e00614fc306a12181088ecf32e160dc4941b03807bfb14ecffd081bfa9363844fd41d6f38e508c64bcde748bd42ea1dc3ee39f4bbe1243b3459d1845a1a94189cd6bd0541ef41e5137322602390839cd2f2f8b002712994e245b27787f4ac4786caa3569a006468d5770774efa11fb2726ed837854653b1ae81d10b290b51c45b0236cf28a6357d6e9f041dc5492468d7dc4b02973c6cf47bbe8d169142f3cccab2ec6bc32729642e5068c0a38ae9fa0fe8eb3ecc71c85dd386201d127004d390ff589ced68dc3fb3b6cffb4beea57877884d0af0517ab826054e59d0535bc42e120200cdf2603ec720c1219ad93d9cf937f1eaa32852383299f759d3c03d534a1a2ac3668cf442a667a03eb26712fc39f6052df28abb41a2944146f81cbb22b0ab9a222e576cdd61c665b69f220c2eb8f1940c566a470bf90504fd942c110fd5c7bc089e5a4ae78ca8391a6c9a505284ea3b0eeaafe82c76d92b1eadc184486cd9aa458677101e7264729633d6dad0204ec28d9982cfbc53240d5ef3157c2050ff91794d5e48219196ec808c19f22f4aa5e37ef16dda53de1f9317ada18ee039b3a8ceea8d434398a7812ab5928969aa0d2ea50e8f373893f42f648d1ba558c3597aa51b1e9a594b7eda485a30b4e0496cff398e641acc466874e4facd898503f6692c22ec2d72d576b3d4e1c65e41b0db1eb9db9faf529bb7471d3806b956585c737aa2788b29b00f0711928c73da688c649823da001a4c5c15c7db1beb26bb5f1da31fd6203eb8028282e59ed007241a241c0bd48ee4f8615c7026ea9e9585b47239d46d764c62c52e61bdd49d8a0a2d8fbc00c8412ea59a2885c9f3e35ec8f0382e6b18b15b673f17f3121d4aa2cc977fc6a7304fc60c7fb8ecf7f684bfed0face4dfc35aff08ee6f115884ba0b92ca2898d8a60631e06b205d95d44ed1d7370b07b3f88f1a0f35e95313424e44ada9e1673aa099cc2af1ff0e132bd14880189683d60ad9d1268b2654232a44b2cd884be64ea58d2a01cf3cfdbc26d5d0db13de155e2e9da064463cbb0a2a2a3f1a9038e68d7b18e616eb8ad1ddee849b2cb88925f45de6fe177a96a124c3936f0ba72f260dc7e29442fbc0f85cd1e1fdf17be78fdfe2fc2bad7c151b5ca610834e3beaa9279b2b44fcaca1e74275abbddeb5cf6714a903b4b6358739c014ee6287b034a101695a1b1357e0ba3a805496d139e7396668b40068af95710d5e301fee0a9302f62b857bd5a0d6a309f8d346562bd349d96acd18ab8e7db9345853cbdd65aa9c4c6c8ca69ff79264582d8728d6ff30d935137b952b6e3b0f1406c71a0b477010fd97c76a512696b9ddccd2d6deae82d58affc03716daa7e97e4d0ab80bf4b253391047cb2e081ee4d757e35a11745ddafd83113c7c457936051eac1493cc75ef9e09a05dfd5f50b3b19d42be4d96276dcadeabf70c3025e244672c95df260d2b4d7f85314cfa53bb33a2e8d49ee6040a00a8940db762debf2bf4a5d56c97f6ea527f96eee9e4b43f4b4407ce69f9ebf6667e45e6c784bfac862006070b853ee8843688c72239927a0faa7459955aec57569159cf94acdf65da64f75b0ebe7820d3233609fc393199cf67022f8f9431ac9f6f4de6da7a4daf19b1974cce1d396d4afb3bbe50d8bade7d6b8a1bf746ba008143ce54f0e7443589722fc9518e0fc50345caff613d087c6508d5cee097083fdf8315ff3a625dba2712b3beda55e47ef8c114841777d57d8a67dd749e72dcc0a53185cbc2024207d038dd92005ee7ebaae9b210990b6d07858f9393a839639d8e88e4375a403414578c80b81c31997fcc5feb73da6a0020d9b31bdf55507e358ba81922feb0d140b88823dc982efb4838716655918fb16b100ac1c79981d89ee588a450e95e9d9dd5ec992944b2269615c253b043be5e097257d567c376cfcc5dc0d5a25c01654831b1f0bc2539a330c27b747900b14c0621ee0aac7a54e832c159786ddd5c2c08001745188533a396a343de0c4e1038c9c3d6d666f000a7ac9c7d92581e5a9271577fc6a59e93e767b50829a2ede567339fa0efb53fc886f2de94f3f8dbd09dc56838ea13f6a00eeb6ce4a3de1740ad2f4e834cebdf7e6767cffdfe0a87bfb0241b33320e3de8b6004973e117c42020367b60ce937e82db7d6c466336560728cdf7c289a3df003f5e622d5d6652d1a514c5ebdc47764a69a14c547cbd2903d5ebbdd8f5f19894f2eb298c90043c14171aa74f1b8cfef9387555aa5a8330cabf19f2b4c4151877baa3e032267ac917ad4be802adb1cfbb4caf230741309ed1094360671f142bf444a395077ebf7ff2e130aaa30ae5c4edcfa56db42056ac19021be382fbdf7db44a23c91dea48fa10fac84c29593f45203cabf452338549db4e83dc479081ec4a575615a7bac09ad7bb6589a89224f0636c7cb33bac8cf0662d60a9da1dfedb83d94d36911b1f3d3d25859e6d3114c2b9f6bd9c07af8080cf6b6f4da236947e28657afa4af1cea428cb198993072022692d938a3b6bfd23b7e83b66a6aef63d896c54dc86f88b1583fd49dfae69dc41dffa8e8e2cea54a361151e2dd94ba169c0db49d28f57d7cf7418d829b1a84f0c9497ed64b0d4fbc2f53cc1fd8ba1d10e3bd3cfde3e4289c219b2eab8da268d38666614bc8ec1128bea6b8fc0e3d22f232f4fc5ef4797b0596c776d99a916a31b2377aae07d76a1bb524682a9962bcc0744f7325d9cc02c636d2b126a4d69f27703ffc4cb376d81f2bf9a56b9d9db9f768a483f6c22538cefdcdfd54539e10a1643b5878d5bc491ec4e3fed27fa9daf327769c23c45256f07dfb845e12bc2098928f33465d127e27399ad091274588b7d182bcb4d0369fbd9c0f97f619a082df125b5997b2808e9a6d3dc0b04d48fb63571d9f4aa258d43e9eec5a35d0bd7c96b4079cf705a239d42cbf2a7542169a4f29f2f5a27f56a76f12e876efb167d7bff42cf96e4539ca741a71f5f7c9a1c09206bc92b9399eb59913a179bf0e5fbdbaa52041ce30e0bdc3f90f632b652aa64773d2e41a39d188ef5c620f52972fe55de3c0ac0b2ef1ac8da29abd5fe46ff03158337fc35a710aa4673ccd6a0c1398169b7e6e0d39bcf304efba43b5608fbc7a153043bf96f541189682aeb2898481621380d536a025543c565b568700d599e3e20dc12fc1b5a99915571e8841ce99d278b23e46ed67c3897d7874b40040738fbfa0552d9e74a87f0430faa6820d069c955d43aa26cdce282f1e512a584d33a270b7500982509def1e5f3c18950498c4842f3ac0e10bff5aa2c563728a2d4a1784f8fd67b80a1d2b6937217eb225d8d5eca7668c00de3e52008805f98a175e9c2d6bcfb7ebff6b453e5e1ca38999470ec02f617259eefc08e8f242306f63b0ac9db50fa52b56537a571cacd8298c6bae96cf8031652aeae9f3589423159235d5eb1323c8afa785b395df6c94ed2963dc3557ebe53e32ee640a95c7d7a350095e08aef1f4345f83f1662560cba90ad5928df0926ffcd2c7c9ad78d6e6bcf6b481e0a49544e7696bab21224bed80155d0955e9857bc397d68eaba9f7f4824f9f63c0b069e3610fe2f1f3ec26c5c1849a3a0132ec2519ffa414148205d59db812d993531f2a70e99501beb485b2867ecd70f84d8103aa59d67064c5071c8eea91e73f2c962adbbf76c54853492b47cf15a2b857207e080accd16e3327111dbf6bec7567c58510cee61bd76511325213fc541131d3311be210c0d5ed4da59cf3f1f64fa6b79dececd428e40edb975ba3d1309d031779fb92d5e4ef56f09f800d3978a90bf718a1bf586fe371d40d9b2918512431552eccd2372fb0d7301dd3aff24773ed767ba7742cd50de81388b0a6a254c2828d105f6eee633fbb00d26e4ec0f7d3a66fd0aa59523395538650eab78edfe101e2785589bf48e641514213290f938ef9032b15ed965860480e15387751a1efd600af15911bb10782eaaa1c378659afd4eda381f3ce7942ad74c7ea21efb9b8192bdc336fb3fe5e18cdee7936b85bfd82f0bad201e6c607dc6c3976ddba053b1f3d0eacc7cb678bd77b06b71797b6bb81fb7e7da17050a23dafb64288f211574784c30c15d6482e30a5a7fe4d264aceb963cfd7e6a5d819145449d3bf601f7f69b9bac7cfd05457edad24a3a74d3c62a1a3e3fb96dbc0c59c6439486f219fab1501102e88c9d85df82847ae18222737ba433537887fc9ff8c59ccdcc0900d8ee084f670117a57a1b36abacd46fc57a8917354804a27f12f7b5454f6bb2cce56d4f2bf676440416dabcfd6c9fcb104588fad1d1ead856384d5e3f3a9c59de7fb5b050afa48d28ffa5c1676207aa413f7ce7b4ecfc21324c66f86069b59ca26ce78fd7c47417ef27588f78c9eadfc8af847867037e33a48a55d109af5e2bc0ac685876e1f1575d997a78f15ec3fdb4acd93384fda40f74b4c226339ab2477e01a759ef3138e99377fc3aea0252b711a8a16b0b3757e0d56aa545681e2abb659399efdd8dc7b611f6f1c1d3b1c0181c772d13bd353aea35f1408fe1712d14d3e0f0fa052aff0c4fdfb7b6f20cf4957bed2879ee064a344b8f5f5892504f5b9ef3fb0d956330a9d7e79e3f6efe9f2209f84758f661ba7df894a6f83e1cfb8a6a2fd20086ba8ab3ee3c2ffad296948d9300a924277f3fa6485316dbefc07ad0cd3a6d4918f9d4e6326e5de3595931d7184ad4ed9a8bec64c9a7798d6097f140f036bd4748e5a277abe89f80cf6bd433789a2f3acdab926841f476ee0d0a8a38d82466a464cd5a65a8d8d5f7fdb2a1ceccf3092f9e4712384398f1f67dd9b52612f8305cad6d35c3372f9d4a199bb300220d44da5925b89d0a146bf6a63151e72548d4e2ebb97ee9e1bf0d52d2a8bb53cd4dddff02aeb14635ef243fcd79fc8a08fbb72cde7b9a7b2134b66cac2f8db1a252d28897b8daa2ff30f62107e78755f37027868ac095d1d8d57a73d5e4679ded8a207220736e96593ba6cdaba21fb7a7dbd77b866003fe7c0f0012d1fb619f4e2a472d6cd247a2231dd99831eb1c28e3cc26123e3af0e0f271bd34403daa953360a0847cd08ed2844992db5f60fdd5dbb4c5610850556aaf54ff91c12b861585a92ebaa6efff435090feff7a52158b4df1f05beb67a1481e0641d5c9dd6f141095327277e4fb96c25d0914263f3f75ae24e4bf17384e64f67cb9862ec42fddf8f8f440bd9b12ac367c6cb45b98f6fb58b8cc141d2b331de02445b70e9ceedaa14498da55219e4124c2e9e70da53df4a55cc01718300bedc84de255015a48e54a21d72eeca5f63429d7a7b189672dc1d1a8ce5524c6c3813249527dde34428458e648945baf094f8fe29e665b0dfd2e98877b4cadc4ae2e1caa92e7918d4e5c5f6639612c2df768f159a3c7ffec23ae6dd1c23eec84357a6c1b015486e1b3b13e9b1001abfb64c9762cbc0ec8d8faa263b3ae7c74f2a18d7ce015fc9a61a8dea4acaf354fedec54b7f3c41265e74c09c2e88557d36a2c9a903a1c7aab990fdbe3aeecde83a32160d32fc478aa167916859ec1c0ac9c2570340a4945d24d41d0f9e1866fa0dbc6f2aa4ae659ba2e6638f999a942f563afced90058fac380c234c003f00d0c2bec61880c3308e22370024812e88d1b6349955a21f0fdffa168e8a1f7571bb346ae63fadb8690b332d1be7afec96dcd56a2d9143e2e5c170b8dfabf436fd4aba5d9e031f4cf52693a3b786cc8cc2def27bf0a5e8c82e72919b4fac0f47160258b738cc51927f7aa3621b02831d48f22243091465c96878662eaff70a24668a65a31067f7c2f27ef65508bd987f571fc5a06c8a35d4f177df98d3702b731cf01d72aedd164df9e7d866f9b844871597c91d100c35e6ffaa3d6208345c4fa893ea1021b32d6043a37699ff06336ea71c15f908f2ab4999d8fdb5f87a4c2fdb4742bf9bb3832d4f6ea0c0f7e6f3cce148c2f70e771d531a004b51120cb142e444e58581356b89cbbe158f6d2f0134204399b84aaffb0721ca0097c61515dd8a8dca4b4224be9c07ddd7cc0c0f3842caf953c44fbd4e8a3e21c5e19a5b7d0c5363ce3aa3dfef8fedc7a2d8c43bee7ab1352fc81bbb974006e2905d5765a01ec002e9bf7f0c837d140c177776f56b4084dde230162e7278010c6de32dc20dd7ace3dcfc12b36bc747fea5eae59862da312f73bc326460d3701a52faba7864424573847a2836b990079d7e6f963b42f56f3f1b9d33670376b504e6308450aa16f79e4eba858286c58fa4f422def7be97ffa29dfb077c68cb5f3b4b5f8cc07519021e2cb6d759cabca04ef8f739482fb43e100cc30cbc8015c0d072de3f959d48a43d83ec0798692e867124c13fb9435d4517c4d586eac1a4263fae59d472627b2330ce1a06f1fa4c28700cb1082a805fa221e0466e866e2f6103e9ac4e3fa183eca06a762daab8723eff6824ae52273a63a5a1de6d32b494621576a78767cc3da4463e9ff23db2dccdb04215bcb1604a6602950c614d6ffc2f1bb4ba9129e8690e0d216546932ff68d94b2588779d40431baac3eb31c3f36ca31276cfbb159655cb787d2cc63652f20d66db27c32247367b3db42e41375ed1ee493773ae282a3072572535ab205bff222b0e993f559fb52f322cc6e88338188189a40408c5a148a909dd83e8497ca5216953277858b311513b19b920dae9e26716e2dab825c88f956b627a14a2dee05637472c1fdac19a6c4d86403935c45cebf1970b29d3c6c4f19b887a7af3be19a8588f865d5729f2b939c88bb9de02ab0c3a1143e510fdfc11de797317cae381fdf5321092b0a8bf9b03ecef34a37e707df71b863630f371a952a427a2104f5dbcff3abc18d99ebf31c8b456e2ba375454e94a3dbec555067100ba4ffe355d619492f1f44d678f3c4e475c1e420f9e0eb0a0ede1901e256687b4415ecab49909d185a95b5b9a0b9a91b743db605593ec6193c4e7995d6589cf393077d250815d7ae949a34bd87ae086c75d2ab38773a029372e36ed11ec19e7757921a0550677e7a91dbc92706827ee784b9eb7d2c3767f0c941536a7c54ed0b0e8114301c8ab0042f197d979d68152494c9fac3ee34b50fc2b33d3c1de6d24deb39c492707c69dc572bc959ac7eb14b676bc455bf3b52417dc3c6fff31fcba2ccbb263399d98a50d33014431da20f969894375e3c2f35cf81731d4e89786e7dee150e8c11cf8e5e33e18eb2d7e5074a7ae85c1df37b68754fb7700783aa3e442321142c5a50ffcbb8d0f8813f3f54933ee36ab3532228405f1dbc98beca4259459112260e08d512c61c29e532ccd9a3fbbeb655ca001be8fb7f79370a9e4b276f05e95b9765c38358ff56a24705bbcac2b939e70bcf7cf5a9948b70771533f6295d45d24841ffcc406040d020144c8137af7382e42ff8d8308931f2b7d5d29efb38f9f355b27f5bcd35ec46cf840d7b190abd8b7e21a0cdcb4e0cdedd972cae920a8e9af65351fe668f20cdd078162579071259df7ec0d240a0918332e2dc004716a76f8389cbfe91d5c7f9509fa833cbd42d14a7ed242937cd8b3335d21f7f0f024100111809efb5a3deefb8c215719aa4257c253529d20e190b860d02415ca6ccdaa9cb29aa7ee37c79f6618741d96817a05e0b6a110d027f8196fb5db8dd9ff3ea0fd317467c99f926296c602e472d6df0dd37c32d32188dd38d39aaf35eea87dc56328b37bd7820f1809eb561e743692f42cc8e4af85588cc26544996a58bde6e84bb859dfca7196c18a20824a823e58bce8c23ec665722c50729eca0efbecfad66a6135385b51aa5784869e784365582547503b297cd8ac2e0014900ba861b36943d31634e17b7ca8581e23c7da9c435790627da27b1e4532ad1373630cfdebdca9b180b324c93bf9b7cd3990e80b0babdf08767ea2f256cb5c7f931ef9368bcdb1d6271029f9ec48020735db6b912b9420c25cb7995466c79d372877618a54e25d082bedf108d13d61bc825b5ea5025f71186490d14c490b74e9748399823e700108dd4e61e661080431ad853804c04cc467b8eecae69cb96aa38051c00c01340b0b85c714cff261ed802a43a2bfe52dbc000ea1e7e2a68f3f19aa04503b918d595352230abf2a80af64dd8b6adba07aae1727fa39d3b2a06e973939bb328f8ae1a5f15693e74a54edd472c394bba62a0fc7bf09a13441f919903f8c7361b80a0d9fdd56d46fda12e47474ca56f81bcc0f80c2ca67cac5112e547acafb4a8c57aeff3e0d32b436f00bfc370e4b9d30408eda3e4dedcb668673bb3e35dfb31079d6e9506486f5b313c5af211d6ef0bb2dcd37336afbb995bb306968dcc84ee75776d1f33a6809baf5ded7c3f2f1e3984f1259a65908d6344a556c6d95185d6ec4c4c424a4c54d868860935cd8918f47b670b69d6dab657357463fc2668597b1b12db75c7ce93c72e90b87e2ab5433e3a86eb60b810c7ae69941950dda44b93cafc1a4a49594e20584a50ae5d209906c15b0c3bf9a18fd1d926b55df7cd58122f663e77205216d255244d755576ee021aeb8f145a53693ce108add34285c398c4b0412631500c048c9e600014d9a255b17f2d1314553c60af09094e84d63a34e0d2d4780c0d756e2406fb59f31e960de1b45da868ab6775fe5b25f4d245628877a9b88e0887f0e0ae96a6d36c5f6a978209dd5b48a31284ce614ea3200bf849106e45037a609685d617a542008c4edf8450","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"8d7ede86964a1e515326742d416dc54a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
