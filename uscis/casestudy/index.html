<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e84fc5f0de0c9fb52f17d729403c01aa77d18be201feeb9f92cffd1fe6b6dea315a0a764164309e5fec2d0e6cadd30c7a36919d452745c9701c0f41e2b2823d4da03264ee94490205819133654e02216b3311cad9fc3d27b739edeb4ba7e1b3d6c8c3103c15cac6a172988e9a391b1e25fdc313785c00bff8246beb7398357819ae453043b73e8ee7436d92fc1a917037bcbb2b412fa468d38bd5e68454fd3612a907c4cbd4e93ec047f7402845fb89b4732c5261d965f52fa773fde621e871d12bb7602c5e70d1c67d66674645c5a2a44700159f174e22a2d120e74c698395486fb2e48ab96c791de25d82a9cc9d864ad46fde9d776bf51629d31e549dd5493d8b2e1e978b386c37586e90c731034b3d1b955dbd20415f480b6876f68dc30df00512029c704ebfe54c450a155c3bf2f1e5e1dff2098af7002d37759272bbfb1fca139cc228e4d3b8325d5af4568c60f243059a4d6b1420c00bdb936a02a6c9f1a6fb1d6590c39383ac55e476533a24d51e202d0304b5331f380684b970f61db2b830fed72c6cf0941ab2fcb1ec46c3b01631d7dec6e0b17ec3b823d397f86d8c2127525f60ba92eb1e6e3b797a900f05895113c988b8d351a0063a8b9896aa1f2a356baaf1655a49553040ab3e0601b9e0cf01f292d334007fcedacd6757fd4ea11e341f06b9e776653c50e7496992006dfc810c5189b10bbd63b807e26e4a86be1960e34f93ae5f859e7d41afdb1a0a8a7b614ec745b591b0bd5df9e64dd42959b8617765e47b8b82c35548b486b5751fce4fd79e97abe3274db0059efcec5c575c70e3ed0483c9f27de67ed57e35ff2333b74a9572901170b1f1176acb32f78eec1d0e8019d0d7720e2d42855b9050a98908d2ae21dad34446292159d13b213105a7260c4b526ed5d625a6dbb1e0960bf56cf35be84c2c1cc07f21449caab92fbe18fa3f0e168ba3a9c86c05bf62e1c969bcccf4ea53e2982b5cee7bdfff59e34066c68a806c9c4af6e2a7e61a704b9fac0ad41fa29bec21c280802081362461cf876774340182c1efa716cb9cbdfd8dd9851a47a4e00db0012fe0b7b0b9f101a165ccc66099d6226f5c84cb8c73ad42c019e3ae79f931e2697fb7acfc6ebed801e4047e7dad4f9d4528656e6d2d4a2e5d681c2bf3c91165b75633f35c84138eeb1f91fe417c1ef186bdc78aebabda2581ee39643c645be1e34bf8041903bd322c6d072551489798d6d4c8c48a6e30c47a2dc8c85bf3faf132c4e04ccf46caf62f4423e2d600f70f90b214435b2aed5582be395be54c729a093a4d1f26bd6259c53bc76cb4a836cbd999a0c24240f5f344502fb9b9212951e51fcb758bfb88955073764dedad5bc1f2740f6099bcc8900b43b7729c60d5c113900c5246ced5ce2741b5ddf7a964390ab7e936692e6c8a68ccfcae958cbc7b18cc5f315732d049062e343e0c1b7ee06cf5388a0c2b80547d4a28c560fba994768feaf3498c34bf426aa76ebf6a5f3ff4ccc83384fff695ac4b462bb5f516afc0309a19611c6af1c5135dfe7937023fcd85e660d07703b9cee6811760fab7ad1fe31714315d49d2f6e2f9d162a0e77718283657a0fc100dc50a2c7d0b46bd88177aa04ed7a52a9338391dd004971c6486a789c57c83b109f443fb6bc20c7d2ef3328d44891a5ab52ed2dc4f24dc09dc4003b5c84f707690ff5f52e44816fc44250bdde82423f251b3aa7ee4bf8e699587eccc0a3280aadd023fa554b47e005f98dac5235b1cb7469be1c38a0cf2e885d91daa964327aedabf735d2c2a011c271f01087bdeffe1fd58039e02a79f78479c171b7554681083c3d02841fcc395133b83f731a552383aa9a30a47a8f9a199845ebe787e3ffc18e4a18b352ed8a1c4ee7c3abf7139cd31c2d8d4ab603d94818fad28ad4d91deafefa37875cce525887fffd68c9392727761c919b5ea26cd0ea39681970605d7851980365820df7057131bbd5828805bc6c02761fc6554b5fd3ec4c8fbaaa535eb8dafc5725edaa8889be00abf42a6297151394d7bf2e25ba97e8854cd2a1c29ed84ef2af594000260253ffe046344c396676a7f11eb09aa6a23973fc830ce6a275bd49b9dc776b2ad3efe249c603b67ac2d6464f78d884dc4305ff0da142f0b8aabbfac27434991a4194e589ed1822c191cb68bcaaf775ce9f59d3772d01e578a2a2a929a9a04571da37f9632987245c2219bbdef0b6182d0ef1eac816040fca66e7842c91c81bb64b5c5e201bc0a1b4d7783ec230eb11086daa27255ede44d0c42d23627953775755056dac94917daca7e745c92d4e5244d15ab8e88663f5a101660def8f19cd4bad967c432d955f4732b860624edf1b5e4fe57fe3fe140342224bbe62aaf838c4cd21c0f2bba8faeeb5bff31eb95856723db46bd43ecdbd15fe9f8b396503eab25fac711e38ac798fc7c368439c20bc52ab5394c9744645547f10bbe84a21b753a0463a4836966c8ddd4a7d461f405affb35491ce1371ad5df3aa6acfc89f774fce6588850aebd786b95939b03a2dbed703e9b681b3365548cf9f1aaf9603289f14e4e92f0f429a85f3bf3c24d282beb3d7b7c8177530698c165b944c849e192f46d986e01a9e02e2e0085fd2538d611c71b66468a92e7692d3439dfb1ea66be0b215b068453d1249caedc4cc19adaa3a4f0f3d655917750306d6bebe7965763fc43bb48a57810187d21eb182974561b9821603ad174379b7d622c560b6c9b80e4248698a102492362182d7b7d831e8ef3abdaf7ae60c9da222aae6ed7e3fa350b1cd642bd2d225507fb726635dd4d2a109682191fb15ee0ddcadd5b026d023dd30bc0c9a7f6ebce4112fcf5b0e500d9bb29336805490c47720fee3b2203a47844c43055ce7593327a5295ccb9bbf9a521e5b6f71314b947ec3d06408c81e3dfa9847ad366cb3a04baa644611b2a17d8879b98af8bfcf034c473dc4e2ef4b96fc284040d24c2b7f028ae22bd3c4dfe602cec73ca55a0cd3e221735cd8d80b417c594df4427385ac2981911e49c13c688373bb86101b00f3c11e7626a51ce4c06273b8a285b5704b146f48a1ac5f289310c857c09d311dd6ead1d801591454cba9897b60a039626619bb9245e73c62c0ff02bc617d328fcadfd7f9c49f4aaacf767ad2b47574af8b77b60a63098c99a3d3fd1fd62276028772d7f286ef58c932e4bfdc819b65fcc718ad392c57361b4ca2bf80d0d468d62c979a44ed397f11e115aa980bc85736d688657017d4ad6bc529b570534a367d100648bddc1a9ff034eaf3da21143f6ab4cef1cf26b309d3ce5cb4ee7fb19531d6c287f17b15c563c193babe12f25d32ea7516c25f4b535d1b509113cc6c560b3e0dd75f54277d58612fc88ac7cf802cd82589fff96eff848f0dac34032b6a1c0fc33824c97822ad3be957c368ad94e3e4cc1ec1c9c0b33a4dc84852fc6361fd6187abbe97db09969eb1456c01a7fe49a3ed5719a962f01da78e2ef85f5f4298b80821055ffa16a6b561c08167259915b2d204c3b5b85ba8c432a1f91063b68a4a38860fb0ea4cbe91f37117407e4b08b4d13dad03bd39fefa438608a56329eeeaa3dc8d4cdf907534ac91cf0242a163649496f47ee5c6674bd452fe1d965314f5141838c37775c1b8e3a09801f8307cb7930f28b0b036c9c763bd0165eac7e89f1c461777cfd20fb1cf7f285fe5bb697e944ca4235b2f9670d7158f06ea512f13f0ada2822b806d56de8fa4588ab4438b946649512d60dc335717c511a6dda51d33865d6de72d8635035924c887b1d146edc39a4eb08786f3165f783a97114ad8c715b3eeda4919fc344d08d6d790237314f3b31663421bcaa427ccbdbaaba369d00cb993ecc5d6914ff035a093f9e8fab48a2574e5e10d3cfffe1ebcbcaac44ee012d1137883f8ff4e4fead8b38854fbe1be5898af140f3a06044aea47f9a36e0373668d5d99e06cdefd036b9ee47b380e2f294ca4850e56d24a6b6e082a22a68e3a553ba1f0f1617b11a09f54bbea6c49b0965c50a3bde556d93fe870c45899f11035802607237fb0335e74c50437e6d8e2b818196b960baa46ecefc1818e2979068966ee1e921d7b0a6f380f4e4e6e0efe29422c2ca5e525118bd5fa9c32079240b3ab6448d5b35e0799b6f0918d3e5aecc0c4e485159a1bb9b408b0fe553d802e5e4fb6657e460705651a341237b7f5c02b3dd7ca1f72a17d0e87076866d59ad24dafb535b2cd6e4d667e5220ee77d4549800e0366c0cb4c6ec0f501bd3579c180fc685c880512b7a5783a588d4065957267e77ab47304da2c110fee589695649b2c19ed1c3f85104d637a0e988da375dedf70d3eba666abbefde635cdd25642eb32b09116d8f5aabc3a436fb4fcf1bd04b55761fda8f009e874e386d8c5a7734f58599e6a4925c8a8f72ad2ea5b8e5a4a1bc0254b33c98dedb80fd66c322cdad19afed5b938103dfdb24d585add8c969d76a98936c044931d570a93d7bb0545e89850494ea7318134fc55d8a12a0cf40c2eb4cce8f4b268e8ccc2f415a8d1483870b678af9ee962ed39d9a3fa21ea80bc37a6f0b829a8e40e97737eed6bbe9131120da906016fa8a165e7fabfcffbf6005d72668b78e5c488b87b9a37d0b0b5c42197760b4f2c7486f1d759f053ece3d9a12e469db678083e62f58bdf8ed78dceaeec4b40f82eab7c33af81a971ae050fcef8e3b7d265c6eebcbb0ea680af5710fa1fc36e19e5f6f39c1f382edb3184e0b357deb15e867e5e46ecb6eaa4dca6f1d1938e24319eb6f72f3ec59aec1737f33e0da4d88802dccc3c2b15778c54394a18b7f8b4cf604bd8c6996faac11883a348dbf61afb5cc88ae0bc0128da70dd5555333519dfca1babcce2034efd038c4f86aab91cf5dcc469c7ef17989f7fbfd1ba75e31046bba2528b600a3002b61999a4e8f571fed582e9bababdd6eb7a3a10e56250ca7c120b919b819c802ff9e55e95ac41c1faff6a60539cdbb50743f7e0c8aa2846ce9b7debe34000deaafffd12fd64e3743b2d2eeded90ce8e979ac23592fbe2d6bef219f152e60f7d79ea51b5a1b2b90f38b690e34ec4064ccd33791aa427237ad7bafcfc7fe82fff1139e77d5e38eb48ea4747e6a469631dc1cc684fbd56f69c9626016b5c21a1a5a04d76e46996a4b57ce5103cfe7db81360050b838d77e8552ec1c596d1485d1b4ae882b7f5666f33a292d12c3e8ebdd26a9aa9cb14666476f74184da57457988d7f8b0ef5edefd1f302a5006ddb86c2f1dfb55b5d8a92c464028a8fac5d82e9808c1691d5fdffa4167ebb14aa84ce423df389ef6cbff45c7e95c475754b8b97a4839cb38807441baaf9d98fee5639c73098313c818a466f27f20a711b26192500625069e114bf0a00847c83eacf5695222594a726f261a4db13546ad3afb5fcf6abd3687c3d2f76dc95f5d8bba71b20513fbd70cea79ff67f37a1125733cfe631837e26a98484a3b6777819276a661ed5c13e0662aab067ff5ea317fe51154393b4c53fd617b96f5fa70fd2b6fd9f0a84caf67d7a5d1af0e3c226a00a4e2d2f4bf57e468ca5d10003ce903b505e0eef45323d3af29ebbb96341ebfb5ff00dbbf67732081e821b498e4debfcc7de60b4762ccf4c2b0815707fb3c5beeab5be2be66b698db7a1bec1289cb8f4797d970ac78d9b4401155e467ddce572971bb1d3f701666ff0f7a343f54207762c18196735b2c9b3eb7227ab72b8dd723b94b3018d4f9c2a8e7a874074edb51c293b26df9129cf906f1cbe6ea66b2e987620b49a18ad21359c7427fa74ad0650c6f1c2b9aff4452371a9a3e0e5456769576267f75ac92281b14ed0c7fe690d1753970fd08ce784b8ea24361b9b68aecb9dc6bbc122e43f39468e3fb8789674146afc6fb5ca929e26427546f4756bed58096545c12aab07d093ec43fa24d0c3fd7733ac63f661dc5c2e6e21a1f531d756d51b0aabe5ec489e66857733595e77a19cee797bdcf854ba40bdfc3f7be5b2582f9a03ecf729ed59dd9baa90c6ea983290d3bdd83dc3f64b31f6d946422386334f13048850b0b1fc4a82703b397237de57a07a8a25a2425e19dee473f2d2d3d19f24c77eb4b025a249e21c600232b7610cf2790775cca49b15ec07c9d4c4dd785585b7795470da53fc09fffdb36fae627139bf222dcc1cfa5c4c0c848e10ad90bdf271d00b19fd4c92aeefc7ead40239c58608dfb3a43be5543e7b8d0bc442464fcc6a5a6226b6f520fb326640ad4d4c230f226bd77b47e33e42f2dfea0a40c17995385636cbf1c232909588f4e9b4b1ce05f0ff18b4e641decb23fab981b6726c960c3dbfc993696ca4948b76def9c5f7adb315f5552691b66895624ebe1b40d0a4e0f943ec4674cb576e1d4f489a68e111a0763407f4b6770e6d8f4eb57e0b0d9975fea8ac13b6de24f6dc2730bd7a8bd086a8d169b09ece8d76c2be7f65d62cfae69ebcd7241cd4d26e2abc08f44c7a19aaf153c2ef0d90016cb6fce5ec3dd352b858b28b9daf5c681254925725feced0eb43cbb1ee85c0c4ee12a42cd1e9ee7c6e1382e99a15abdacc8ec60709aba969e6a701dbef06b3f1798679c623f53f1ba1056d039551ff025c0a3ce815ccbdf11e5e9d2f50cf7efe555238bfa44e5338d4587f47f79a0de63042db5adcab2666856848b9df555a50b55dff7c7f9daba097bf78df4c878f366ce1d3c7ce6bcbc8b8fa921fd6be6285f4a68d1c47bcdfd8ed3263ad89ea26d84898fd51ffbdb7a3ca172f1f6cf78112b12f627a24e94e121d2eb638b4ebcd30b9524b791a91e726f052cc6040e234be849d66023295365a32118a607d60974fb6b92ed8679d8d9b6c950fd8d70e7a46b82e78a685ecfc274568adcc457cc0996c3d6d63642c44a97d1585cf5ad061277855e42d6e9d25de02fbbbd016b1f189d79e421007c8ce57b0c7c6bef4ce6dd91d94f8bc0714540c582d72e7d29d495a7137a67f76f081b6a7673ee8f9ae94fd2f605da8c6b6f60261e6a6909809a90c6a90a2913d9d542102c85f20b3e487b4a56bd4b1153dd96b331138d6855916b9a71290ad0707948e9790456fad709e5dc176b6729792e794f78c4d678d28040d19df59deafedd8966fb6123e00e0dd700d1824c8183f109ca32e190112b70dc3c1a8adbd4d5b57c67b4b805a3382d15490da6aa896289955abe46adccf4dc2a7cd1e97bbe4e28832b41fc7b5e8548931b942b6dc731ae688880cb234b258f37b50ffe6e656c1aaeccb3906203b4b72192b346c29847875a5f4c62de9a3832d5839fad044ce7a84cec0c873c7d23f047eb0aeb34541f8baf88f18875df47958f5314786a0f0d26d23d6a31bad5a4665673f7c96e9813e1e0dd44a3face2009b2822725521ca3e45fcfa8fde24e95eca78e0f2da52c6074ae11729fce0f69893c933aa821bd50a5d8b52fa9e69f305f966045f8a8a3eece2f05e11fe206b02ce8599eee581720d4ca52f7de1041ede66dde82c0e5a75cbc406ab226bd71debfd87adcba42c0f647ba8a74e63aec76923d1432381e5809bf317994542d463e7143aa456b1d6db5ac39201e8768d708364c2d7d41339674121f44a7c8ab47d9e7f05665f2c689ddaa408fce6cecc21cf9057596b92068de54ea8322708263d4f34486beca52ec076df4c27b6dc1588930b8f1308ad84a73a1ccac2b7a7f6dac7c2889c488f21b65d4cf8afb12afc7c6f6b187831dea1324a89660f093db41498f982bfb7e5e549c245166301a8ff17a7fd0758e5c814a62d677be79c9bace5788b4136d2c0830ccf3a564dc439aff8a5cce2fbd72eabb638cce249b56b68c54a1ae69503bb2a01cbbd0ae4688af3b7219c3c46ba1243b1c2a1d99cdacfb5c740644d155c7b826b484dd14fd6f9836b8368f29bcadef0698c113e961dbab5482f8b4895750054576822d40241f9bea678ac775a5411ac6caa37c5850d306f8216e8aacdc657fb123a243ddedb91d9a3d9bc3d6cdf308617bc17f5427d83aa36e97cb9139013c950570280bc6d73bdbeed4bbbea6ede3edb219c0c7a4cfa2bf115e3f8ef62a61572bea2948f8225411e71a9f6e0ec540cc829f51a7ced3c203c512531f1b70e39587e24a1a8ff7f8c94b6b82aa51fddb973661820c7321c4491af2a5f79cd3503a92c8834bbb9ee7d353d9e5941c1088d03a72337cc9289bb8ff1cbfe15b98185e24774dc34d1e2d16e62e957c39261f87af4cf76bc3a98747935ed1f99f233b684137315d681beca678aa099cc5583bbe1ef9b6544eee4ccbad292e3340d4f1ac06c13417af1e62f81ad3105fd210b412fd2672187547d4dbc74aa194b0c39da171ca9cdf460f42895004a9424789d245806f5d857e144c1a4f4ddc3567a41afe16ad1bbef1c7135786b49432e96563d27e609439e413e784e96996a9171a987a001e5e46edf464d1306c44e739d68a899eb17ac43a48e837d1b1a8e1ebd800a9215f74f46ba268840e63c7ce9b3c054e3fc87caa99f1c0fba549580fdb72280f252799bb45a7de6f527aeb97a40710aefb4b389aaf620b11f40a0af763b0341d67e55ef1915b2ff7c5922c0bd472fe46f5164a2803e1a85be10eb61bc8f20d6690a8df85f20faa5edd878ee1f3183672d2fa9606ad6374a02b46faf82e519c3d6608ab5fd129a3fec3617b24251d2b445119eca4783652bc8e1c72747fff62f9f1764655bf7f7b2d7cb268a3136a05e997e981acf04854c4589ae5eeccb10f1c519ccc4cda31ec02a43eefbcc706deafa7be9504d723a608a251273946414fea697739267eebd0d08e84a4228f15dcc49ade73b22b3f9580ec3395e91417ae307d2122c0c291182d467e57c0f0aece9194d61c603ab80e18f775b90637bd3785e892d89de8f9430a12c1be294dea50e5edc5111a2a3893a223590851713a168a7070a01f01c075b6b77801356448c201ed75c221f885cf998714833bcc1a2c794670d391fe9259634a566c88a0d01ebfdc7f48c50dbf18a318a8b489193110f784ea36639d6b19b742cef819089557f5604c56220ed47ab286a14df8cbc91967baac14f3f1ec7719a43cff3ca63e80b1f336e952b69fe9727266b3da45ee286e209a75e5b3e1256b91703b61429c25818103b66306ffdd513fa9bd720f979cfebe43cb3092fbd86d8ba435a5ecb5c9ff93e8801b401144bab4d82e16d92b60562ccec6603e0f9da0e4bb88805e81f5e3a4e0a927eadee68dae64b2cb7bbd1e5bcdeeb12334e21979d7d363555ef20ba6abc9441e08b1bd576d18e27d17d8411026c27b05d4bd0dafc99e664c98048f483d9a546e1942ec3bca703dd6c9d7354fc34ffb8d315e6961cf1e89ad8cac9e6761d4ee60992d0781c3ea75553f65f2b782152f67eb6a84a14c208007da3e940cc42a5c98b56daf6418dc49e87415616e292ce9cc2cf94a69c12796585ddba5c03af8f2d9eefd9031afe14e722be2c932c5963983e44ab7ed3f94da61faf08590a0fe9950e8968710f2bcf9992d2f04cbd4ec439f68cddecb61da6b9cb047cb07b54d5faceaaed7d2152825ae7340f2f8d1f74b10ff24a507297bcb183456de4bca16174c082e906ca1eb16ad97f9fca5f7f6516419fcf85e56acb5c2bad4e191a9c1fea60f61e26229ce4ed3f6c1f2a3d556bac41c98cb3c706d834385e6afbf70d5aa09c082c43c05eae7eb8af1bcb521628d9bd97318c2d433fa2b2c1d142a528859ab1fb4b7fe8638febc84f609f39c9e369e4e768ef42e55eda1540723326ad14d10de8ff04121df04713246aad6fdf78586c43167827576cecb547ddc8c6bd0edba44a155ec378519d816502cfb02afd99e97bf739f9130dea3558977e8b8489c210757b0f87507e14d6b9427a2e6e2997183b6180cdff96bbf4ee9889d31417fd39ed1fad6174469127cf2ee3491ab887cdaf5bcad3db1128c10d3382a9cd933e1e84a2341fb5977f0ce2d5c3b4f65832dceac226dab01c83cc4613dc846fe8dd4e69ce30008036870531913c25e82ba6b3aa833726e5d1992677559f343344d49ab9a0d93ea6d4242cc78e965e7ebec3d322098b930165fcd926d516a3f575ac5ec50078087803a29ac1ac642dc27eb0124d75a7304ac05444165532fc8e4ebd83973ed251530677c3e6e8e2e1585e6ee16f29a6211f8c036f575b88b9b811c08dcb3e722adf2e784bd3c6efff245195b2d66563f75b668a8e2ce34f5796f7393e2b20025f1d19922f72704e84a15a2bdeadd8d2b9d211c7833b7f9ad4592ccb777f45df68f5f1da16387f3ff0e775d7a070fcfff2d18d727fb55ea43201160437121d45a3df2d33d65023f932170c311c002856a42a25476d6eac92c28a72533d8ae19bb272d3a1a5b7a6af7113cda1cf7443119ec8b4c83b823aaa420293e702ee016f45bfd604dea2218d9dce1c595feb38971196cf9f00b1ee6a6bc711f88bf48a9a906480d0cc9efbb90c575506dec438b49e91e1526fc12bab9c901ca5aa25cdfba04ef810992df427d0ba32de2a4360ebff8064b2b7f2579a2c1e2282024c6483bf18607ad44c6bed54ec29980889ce5767f8aba4742458c1f1c936a6fd9050e7e0fb105cdcc2bef5d661b375d766dc5eda695d08404f861b69fba5f4628481e3ab23966a2ef9d67d77d787f36eb28f13ca58bb591ebc5b2950b918f0c18bb7cb8326480553474fa78a30c908a6dfa56918368ac42d1f9e29f54b32b346d8aefe9c4834f6d985a059a423bbd8fcd7099f84d84a5dc6476db17de7c5afeca6dc0ccb424ce191fb8adce8ab8de320220b9e3da1cafc9078090094c51e693f9d8d62f05e11e0bbb4aad8341d0a41bcb134983169720e1ae72008baa7cdb588467bf5360a7017dbc3702642ac7e5a24e5813ab9979de122841b0ec30b4ed94ce1e670c32c3f32e7df2704fc4b4c05722947a4e49f8fc3fe273709bf6acc9579bda17b29ad7cff9312a5b4046b05feac61e8ba0e9f2df63ba775e7cee9242d889ebc3ee42547da95de77dcf08cd4b26b590ea0d1ce3f117bf390824017692b91941855948a3e1f2dbcb62d6e8fab7f1fffa552752a10d18e60e42df8433ebabf077f7aeb74e36e3c0962c5f1aa1b9a41e1c497f267a35f7795fd13b34d114ae7e45243947aa333ba151bbb96596a35225de4dac7ab8cadc54795524ebc28cf23e6d0638042d533625f12061ead73404762ac79d12eaefe330a9e68e2f6c31fe0cbd0b19528c434e2051b005c5fb654740ff11b28d16e02af6e8f696436db15edf79f6429b949c3aa39f6f2f537c2f32333d0da98bb8c5563cf44262ddc4de49c9f35760878380ce6a822ca36f2f145ffbf09de46a0573471b35b40dbf66cdebbcbadd5bee44debdf6382662ef9cfb5518f14d978c44a8a2d973f0bc2b3965be2f118eb161de52992836317fa9d0dafe92e4b835f7c9068dc49069d97c41f6b89a38f1da3b9a9106fdf6c558877525b07f0ab8eee47c1ddd2bc1dc44d0fa83e2b62fd27cb58c8c5f671dc009716ea096d036a3f49b1fe020e57606cc3709be9b818a7742da61ede26b38071b84b2d5aa4a74ce197f7fd03f27b431da277054ab9462436fb1e5c309523ad15534e6f2340bbb7567398ee434ecb6ef04f00ad30cf6e05eea8f5d1eef19accdcc6e177dafca621a51d79623968a6635c6db0ae88b0dc39e55313d70cd99bef4396553a9e1d001e1fbb29d245c70025961a5bae4ec63594a3094c913d445eb5557d70e72946f67bec1435559d1a4a76f39af63921a1df9d1e28477b8ff69cc30fe9f5a61bda79a4e1f2910a2ba14a47f9b30f17e0780396c811a10628fd531c4daf61ba73b2a87020cbbfc9b5595d64ca4bac7ad64088bd773185d195f2c99f640382539061677811211d707f34e0cc88ff34bc04cd05630d974fb10c42718b47efa4e330f680f708c2257a7fe177ce3ef0bc658a53cda84facafe656304e4935cc7be2e71d5e70a0106a125d6236eabf70058e729e8e3ca04a094e9f6c0926e16c3692f95b2229aba3e35daf5daa5668e528c3aa98172215ff36b0bb10193bac3d45e74f2a47a4b86f5486b84cf7b76e94297d34a4de048690fb8303c0d1ed7c872e9378d5aa0ffc705b85729f267e38c440df89ff7772efc8d95e889527aac5ebb72c6f96a2b035e232e4b8ead3c9598ea1b8bce0024dc3faeb357845727bfd183bc74a97b097bb331f574876c41aeb13050d38025ad9ef39902d1e036f306b93d9abf168f58bb2fefd0613dd54657392f2747f493e431960133edbaab447b8a732e62a5d5bc7e72f77927f8a56ad0ca1bcb1b8847f67ede520da5e7abee5d5db595ade305d02dbc998cf24ef17adaadc309fc2e34f6cec63dd6488de405652e01ca1503e98e10fce821f7ae2dbb6196a358862ce357f259ef68921e40346c777b3c6db8aa61ab360665e631a40cb099b7e7b6e50da9943f3c993b8a0f636be8156b4cc27ab72020906736639bd0691dc371292e02479dc73ba655a715eaab1abb113ee593ad35e3317543c2de8f2f2cf20b59fd051653650ba9c1ef2645b4c5c3f839c53359aeda960852de0007adf01568723cba53086ada8a7ae5536c63d03a90c1bee0b41e3e4afb1520dbd5e1f21be44940545edc3b4e8d19a4d153bccd4d334a247f27316f7b371f882c512252c4c96d29dd0678ac287a3a785317101941a7661fa6a260e6d510e7ccf8ef1719102b0abcb43dfeff19a773e8d9a0be5b4a4856a71de8f2c7399c62c8997c5a745b9203185f14dbf08090fab3fb97af8baa4ed0302881f102c6b0da9e174f71a6152c81ac70b7bd67d42e4220ca6280edf39b42e8e2dfed8754eb2a2b18f5346d870bd3f621c7251b690e2a5fa8702e7b9d11bcd397df0ddfc55cc7330728714648d9ce9f0dd26c248c65b27237c936af9843c43251384a348306a2efc438120e5bd1ef5e9758a843c2648cca42fe6865f3086c27d169dcc2135e2270069092658d053db5b66b7a0ad793a379a2c5939e237cbc50d008134ed7cb2a54884ddcb8bfeccb19f9263b86d9191a9bf8454d4c732bb7e7e5225799d92e3c2b0a77fb86d19d2d82813b2d04c00e0e6b00bfb0d01b798db52cd3c56b2177dbbfc14f35f25e7b12b1d25229fb0f793daa05ccbda82afa1d90ddc34ce0a674a1915a6ead1a651f12b1b727e59579f2ed788a7377cb5087cf6821c6472445adc105b54d74bac1cfb8974af7aae4344e619213353daf142f2ee3d47a4476cb43520c23398b8e61c5975dc1d3394aa90e9df4e301abaa2510e479d513533f795a8c61db134d04de55470b7ead7be4e624685ba0579d2b344b0ece6eda45acfdcba7be2d22c9663bfdc45219069b9f0e717528416fc520f4b5f7c70461d2c12ec1ec0fa2d607f29f8d1475aa68e77c8a2fd6f3c79611ed1a8ff7669ad89c58c837fc51041479f69a0137d492af4a065c966c7091907bf94dc0643709e4f23b0590ffa04fb1f12558ea2ce81ee5eaf243dbf64653e014608c75a2d2ed19115756799f19eb6b379390cb273435daca5e05e1aa829e614b35a7f626caa92a194bdf7f87206051161ab1e9586a22e644f37ae306fa2e7b8e46c352496d7233a1e62946b5ff59ae5ede28bc7b593db855dc2567241a6464752ee3d9cd874803bcd65c799e92878e8318615acb1ff14adf92831678ac1b7f9e4c87ce587ef080d8730ccc6b53f052026dc29c06ad48bb41538d803829d911069cbe567bdf1f30db1ff8f0ee2c4d3dd99b4788469a045be2c24a23c50616a135fd4185c500c76a8920dc0ff502889b202307a80340179a090a6627a889250234f4086ed36ee2491529796fced6f95f04bfec6e2574ba650b09c638385b2f0b5aa400ded77c9ed05e8a7c1602b1d7a04cbe622d334752737ccf6b7f1a95dc96309ee2fcf76129d4f5cdf03754d0c5e3c1a2bb99b652d951c36f9843ff767cda12ea513d7a8962d959a5a3752a246089487519499c9c3f6d0e18a8d71270a13907e3a0c89e2c40f88662e4ed1aff69d2684dce774b2867fc910effd32dc08921ad1c9eaf325fbe63615f43d758c6a0dd410e0c9393b41caec40df20f8c129c2d0ab9b1c15292f0abeaa026c7920e24beafe1d0c63700e79f1f00baf275441a789bd48a849f3db76bf4bbe4a8a9e9471aa4d98ac2ee565c1382e8d8d81a916bfcd36deda102605a35a47b7d83b0f03f907334c55bf30136ae19b9153700c74f5b1724e0142ae6b78deee063b0d6aab5b5e8e7aaf2d0dae2f3fafe137c644065d312d85c5855f948cfaec01d36992d29ec524f4eeaf966011b3a619e13dc31d81e1254de663c25f9df2bdf094364b57983e972602f2201008e9ca61ebdefccd16f3742da358a7127e818c33959e1977da7c1c1b87d9944bfcbda76d3c311dfea639222b1cd9bbcc21d467c5b066afcb4b2da94ed610cc8856e4a3db9bf918d9737271d4925187552ce6f512b27d9bc8dc5447b0ae2346694d47357f5af0e5bb3d9c4065a55db1eb17ece1c94150411f08c067359860bf8ec62347e713e3e7ba9f5854936c4a151ad0901e26ab4b60287cbe8b65b1e9e41b4566f3b4455756ba3bd304d374725defd067932d5ffdd9c6ebfeded975e8b0eb8ae84012ad976c59b88969ff7e55c3958d14fe6ed55214e814f7d5ba71858092ae997f4785fa0c2f340afe80e609c89cc85bd56206125cc798886a04f6dbca4db2e9b87410ed570f61847636ac9b98b0db9aa8c6264f95629d26ce063e7cd196471b54e64f277d450542aae6985be9440e5f39afda7aca915987a8c1a9b4f6f63a4fde6e84555eabb468dd314aba570e058fcfa080889fe4a18bb559ef7ac7846181c9380ba33f43ea82690dedab165b44ff156ee51a3066df8fc002dd69e47b53ac0ba5eff07f9c9d1135865edc6023f9fd2f8b591a575ad824d31eb91aa9c5fb76664af41c7cac9df369c1b1536f4add512bb8e8c053d0ea2e56d83b8a8a05df3c79fa601a77b5bcda6568001592d5f26a69dc3108c89f3c3402e6619a5d6a8ec1e7593b667e15cc3fd6960126e3b4a941b88b3fa822e6ebab80d4e17ee3b7f315c1ab6126e2b12f1747f5da8c2c9047df79e65751e612b79998c20dcde408cdf5ba21e85c950f95c8bc5df4317eab81a3199ef51b2dca5e4d953a76468133842510a0bd3ede44d317bf1eb58fde3dc2b0ce0cff4252a39db3e9d15a4fb5ea1aa435adae7a13d83661ed8beadc1c7cd746fc980981024fb208610f14fa6dff1749ebf27165b165e5732dfdc482c1a8b9b85e3f2c754b64dc82ed8e96775b33cce1bb5d8c8933deb4a809a0716674110b1f17734408a2b51e54bb6af37a8d12df8f938a26d044598c7ab864796f543d15475833cb4ddffed6f497349b3172b5bb5782a6dadd4ed0b0a03a9490649e317bfbd59fb8318c8da75418e97db58beab4aa6e2cec33bc357f73869325be61590135222ea48f58fb7f9fe86a2a9a6a2f110baee3025392626c4adf43cc2abb41cc710cdbcfd44714c31d724018bcc59b11193c0909ed69c65e0687cbc41e0da37ef64022eac8e4299d6af4189392c50a0e45c4cb204772334f0f6c740e0132349055363e055ad96baf451c844280657fc3f035e870765d3cd2d88c3398e66da51a1b9202ec39a1c1ef6ca1ad1a9f71ede1b52d816d5a4f89fb032dd9557b0e02c385c19f396dd423da988509fbde9cd727a8dec3d38334a1ef946aa047f95325584a44382bf38516f11f893f4b35a40c725827d0643934ed4f12470e0a9e145d21c521e9c23656d994b107e80028b15d4b5f922ead08f220475f9d28a6ea33a6b8cbb516f26a8d111fce53643a45e06787e0c4b215391e1959c4049fa1d533facd0a256d74b402326c857fe2678be6a7f29aa6e7fe91dc0fb55fd561002dfb14181d58d3dfecafea03abe5a198ddaeec0c95b76c2ddd3ae000fe8ee3d61ab9620b3831758b4cce2b98277e476a1b6d1e1bd7f3f5617bd2305c2fd9383593e7305bc34270072e882fc4cfd3c4d165c89bf2d0dc98ecf9341b5bd61b99ed655385f756d4e325b046a2ef8807f5f15716db3fad8db0bfadfb9fa5d2a6535ebe184072117c9fe2be91e1b960655dabafdaaccb68648a60deba342787e608c154007c3b0022eb79b27689406c9f49d7c2afc9696a9bf114e1318f2d46a6eb219ece700df5a4b018bc54d0e6ed607ad6fa53b7ec09421f8f07becf1951509c0d796b233a071fa4b7e1464a70ef95db8ed77ae1ef352e95436bf75af7a1577d3a237b387c2a5baf83b2d201f6fb3c8841c4b1b4de578cfa6f26573737b3474e283d97c2310eacf39ec9de1d7e2ad0baa6a245bec45045abc247190524c22efc8bcec2665d96497b8f5347a9ee3976bbd5395c8f2c6a62a5d03413e438f9e92169359bb1d83dd97955f2138837cb3ea86dbbbd97b051757939b02da759b44643bb2a0784ba9814b5b358534bf5089f4788a35b47e94a485af8f6259c9b763863ba6d8f0becbc4fe056c3b0c70912f06846aebc95641c3f6c4a8900ebabeaf426711968018dd58719e33106cce2689d2a0258841b7b683aa56aa3a9bba368367f6a2c34cb51262b81a3174f9fe553a0efc0908d4b34ee7789573dd563fed2a31cb146c00cc61f0b03eb81434915f75a99318d6d8756b3906884483b53bb6038f4ca4581673eafe2a9188bf5c62a5f6e41fcba39bb57b8aa363abc732240f61aaf277dc348ccfd3fc232b3cee1d01abfa3c234965281a5df12228f8484e409ebf93c6ec4173a602293a43d830fc0070c76ba051ba3575813ebc65aa09c92871d2edc0f673d64854a0b8d6733005795441d6165b3c0632e11410f88a942d6a01ace645f74c51a6cd26966cce1fe0aae988d89e1611dcc77abdf62a5edb9b6e45158ef8f688806200d3cdcc90fdcd8d45a4c60bdb6232858baabae9d265a0e7df88da298e627e4843f54e5e286fcc98b328103c9d779cef162bafa3cd342e1931728bd7a28f8d8cc66b9853b41e1b85ad8af35c06f210ba223e9b71d4b1695b56eb5170e051184cab4ec825811d88bf172d11698c6e2e8c9ef6f1347ead03dfb6f3e4ca42aa7db6357fa4fa0f945bc419894f33db54d461914ece323f6972ab9a7d223770414358986a0c9492e75e66d26d540b25086569a181abe540f97009ad15c16e525df24c39b9496bc886ef2b27a163180b1f086b76e39c3e725096cc5e4262c2565e96e960d870ae4c94847548618de40b2f122b7ff844acdfd8cedcd938adce7c84aaf02710dbeea47119fbdf63427e3633ec3504301e33ef71bd6a534eabd9037e97eb3db8fb095cfbb344c48c02a257faf05cd48c62d9028556cc48819857c8966e3bd20660f762b7c7eda1939a773dc892dcef49ab872883d542cf961e1877cce375b8200037271394ab68c657423bdf508b74f738bda49227bcaf3ec61666a5e216b6d71b1bb36c7f1302f515c8491b97cdfebf2830c217bcff26f36fe624fc68fa513f8e6ed7b131da4205f67c263f0507dd18ac2e0ac20f6765fee94b473aaa7867202a99ded5c395e617608512c187628a4bddceb44b50d5628084f000e2f905411b55a321d30fd39caf5aec9b710d78986cca23a78963288c3a30f2265aecbb119f7d3950f7e4a67afdea2e916e7fecc5b005ef1472507458a90ce7ef83a75743febe97c1adb1ed9cb1c57f09355febd45496f8a7dd9067b824d278fe5dd5cbdf0f31c5bf486ef4e14f83a61303fc4c6e4260f2a022caa45f9b7078726452396286a6e08308dee6e9afa1d303597bfb0cdeedce9ce0a2c8e4bc5eca1e5e3efbdc70ac9c71faf2b7ed9e283acc1911a500949d8c836d62c72b356b8537a8ad13f89b18ce0aa227eb16df6395756633996d01253e9dcd0af73827e8f71ef788f2fc4da95008469f577f680c357be18c3e3a82aaaf37e424ad98d2f914ac379abe8280e08c0f88a5badb54b91f699a74f18bc0a32806769674d97b09bbf37552999ec5cb2df7f8f8a46a4ab87f4f5dff32c5be6c3a86b2fc157edc2bf511df5fd0f1b5babc1a7ba8d71db5f2e2688d97be6b4bf434acc803731d131fb0e8454d0a66a8fd698d02445f5c55bd583a9df008ac651dcb758ae850a3be5f5ce9ad98d38f02c2d8adf406e8dabc51aa3cf1a519b1363898046fd7b6d3f999c1261b5fc770c07be7714e1a0c5aa421542661659772d4a6fbb33cfe112def624cae670aa5d77bc0560aefe3ed1f0da844a850d75dc319d494fc1f9e250b7cc18d18659690a0bc7a935cb375f569ccb4b409e3e310f74ca9a2fc18524b93aabb03dca1ddefc6c24c86ca73258a360ace173cc7cb2dbdf2d6c5c82e3b44ce0a58b83096c3591796b333da45d2e550dcabef45a6ba593239b94fbdf423d14653aa5d40e4454f766a1226ae019863ceab55c9f5e966523fd4e0c1b28f8fccb240861004ae80ab7169e8e1ab51acf0dccc4d17c93cb534a8606cbcefc55d62491a7ccba95b06aff76e372e8605f480bc17fd6db782e5277cf4cb52f198113bdec57dfafac7c0ba9774636032b3734d4317831c7f1dbadb0d327ee52e4fff49710a25ea82b00b3edaf48374bd704cf53852c2f92ddc53df41da7cec249d168bca0a07e5e5cb73938e43f3562ecd8f9e24ddc80e991f1e1510f8fcff8be52015876418021c736c7d2d5218d1a79330d747e782aebf66d92f685cd61c418e1f2ed56af8753797ebb0360113469e1c1feab4c68068a358e01cec3475c211f3156b7cd4f403d5721238119633251e2d2609c1ddd60f5329a1987442fe0ab5c46b82a511ac047934867a3f382bbe750eccb3b5e5022598919c9134354e034c12f39fb45312f3c4d92a9942116f855c8ea78d87cb4513129e435ba831d0660f1f920377f04750c2bdbc15fc64b62873d268756321e22c2e874188d1f490d8715c44b20362eec592579bcb00c85e6cd93deb02d88d412f4cf1d2905b519859c3a684e610478b9ccd5092440ea6400b6f9772e19cf742fbc3eaf06405d86296ee9196890783dc15d013b6be2af9a7d6a650d4d2590f771871be69ff72593f906004b13c0cdf0785c1df3051ff0844ad2576a9792a8f84b7094441bc280d75cfcd78563c5957d570a5248a78bf4d7e223321e5526b1a048d177d0002e7b2962cc27cb37f798a1b3e19e2a65e2ddaa2c685fd7a7f6e029e12a79603a38185a6597edc3bad5edca5a23295151e01dc9ef1a96cc180903af157eff98fe6f0474a09fc57272458216a20f42279cc7442679cab0f20a428878adf0dea5af73dfca5da8cc2c445001cf414f21457e741a0503d5cc4dfd3286960a0bfc807f000fa01b68d6d418dee75178f10b57309051080e7c7ace97b94a483748cb95467a120a245589dddd5fe1a75b7cbeb12a9f64043bb67226baa69c4bdddb98e92cd81813500a1935baffb73ac5ffe680887bbc7f4820a2e15fde732f0c1d20e8f825670f99e12e86ac8825889255fdceafe33b7ea1aeccd8f07694197ea635721aeb6868be7e727b8d9d0adf886ffd18a8aa41cc64e13e122ffc965cfe75e490a2b62b11faf63f6295085bff965f2db27dc4f7c8be001f61922ddc07bb35eefd5b39af312dea41d22f0d1a00d97d0595ee97a306b02da6b8f9c6a79cfce40d891adf039b8aedae8ec622d461cc63848839014cca164e5044e1f8fd7ec8f531da190a7502b7f5bdc3a5a1915abff8acee608b148a0279aec6242ef2fb0a0b0de53ee542cd8a92bf17a449d69a412da5326ce5b5a71e1b65887b4210508b3634f1a450636e730615849237f7200c837235c73a73b22ad706fbb43c89927d46a10603bb95ee9cf184e7ca5758e652587be6be0745a3cd577263c0cd1b09c6bf1009c81156a8ceea4834bd8a1bfe0615c0aa4eb827281401562f8b61c646dd168589530ed128cb161df842f03c1f8a0e15ac131ef7ce4121cbde459be90ffc88b5c82ca5a1","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"6132a8638c8fc45eb4bc48081f508c72"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
