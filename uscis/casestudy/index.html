<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

         <style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"87d29a0b258cb9a09d3dc541ea2db05b46c92e69c08a94a7b519db3188e5a54be113e332e1b395814ce24164e4135c68d471acda14df6634fa639767af71d99fc768bc431127fd0447812c5361b9a9ae54bad8d3d2da6873e571869700b24f2c1462e6364bca08dfce46e07a54ec7c19e144f422357f927440a1487342c68cf1728361b67d10041346019fa5ff293455f1c33be0d196ea9c4e723059f986a0aecb0e3b25c5bae0ca3d2a6e598b239ae338dc26e19225b8d658be86e74b220e1ac388b7881ff92abd2ca07d2c3fbe5f1c698996a50d6c36376730ebc6c621478b7cfa5642d144383f2ef37b6d309713210f60cd9342f9b671bdf4d7c21567dc77ef54c9b8173c71f3393cdf8425ec3f17d78dbe30520b7fd3373b8fc7527e98246de37af4c4f85620f7e249d07b41ec7dd1f50e17ae96ecc7a7050a8d200ad212652e32b85c44a886766f0ed0a3f742072b32040a7ed02864ba0ef64ea98b2fe75d75d020bf8a03e791f4b3b380cea25341e335e28bdf89dc2b6cd673d82e0073d877098b454703909e27e9bd9216ad651ae475379750e5d5e3081f0e8c1f901d84ddd9b16b322cf4d299fe9975874f6b2c4e6db503bfcf357505e106f07b0a9c6c25968b676382b946ded4bd30ddf1b53f03d18d07aa25de7f341105882e68cf6ddd5da7161d6d591b546228c68457134dedfc22f05f0d949612afdf4567aad79f39f5c208f9ed4916e4f48483e5bc161f7c0aaca399cbec9c64cf65ed15aedd482ec185d8040b4ea869172b4f2fe39fe31ec39423ae99c85a15761706634ecfa2ea319db5db625f811187b543f215cfe3c183cb1b7cdf7a8208bac3c6e8f337dd2260e410c08ff4e74186e2484c5c8f15a861ff32259ca8d168683ffe1d7b79e542a906851dc152a51fadbbc3d4cedd5913bf537b1c68cacc9a0278b0058a3d83861f137016994c13e20ed857cc1982d5887bbc67011ddc02e2866c1d5894105d064528e8479fe70e086970f16c93f567ce92d3745ed3b3909a74e183413e0091670408165f5ce07b788876bb3c637fa9f81b2fd90fc0a8e98ed53becf76a7a73a0eaad5c199af6eced315e7ecf6dbc2aefd3a26847cc23686123e7799c65529049ee4565f47f77948d3da032419731662903e4b70174e0cc8ed1ab23633bfeffe9e7116b8ce62858516502ffd2e193a0fd2fd14ed29460b259d611a2ff966bba0443b262bad8c2eb067891b99a75f0a8313c8f054cd1c35b9cfeb41d7d8f962d1ef0a20812ccacba29fb7328076da50ce9eda9fc94c2482df6fc2d89be59fd4fd2fd7ce4ca71b5399d27e90141cebda5f5b313565b021292e1a698781af3028da10ffcec27b068687fb8ceec9bcafa3a09ec9ce53cc7ba96d06ecb6b7399b35f65956547102961e086765aae1ebf40698abe298540e967f805f782bb0f19b0a45ceaac8fd50d70d3e551f5337910ca46020859cf5e39de01eb3fe434711a3e2ce69436d19f9ce64b7601d694ca689b2747d3dae8af639614c3cfb5806bd8d526cac835e980cc65eaaec4b3e2936f6e1ebeb3d755b759b411f1773d7897c3b9c3a40f1e9aa5e8f42e489ef369c0198d5b887822584c8b6e521a029182dedaf403c292f7d7ae4deb486bddd448b34e3198e246aed4a540fbf8e5c20763e03675229cf7c896e57564495a8ee3b7e9295b92c33902a6da8b5ee7f2275e71240bc1694876eda164e91ae9045728fee4b23507cea60e87528e7c560002a9cc8e8c1c7af976e7b4874fc64fb0ffdf02b3c99f7f422a0ec9f5281467460c0334aae60396c1486bcdcb34c36b4425f9e2da2c79951ba01c90f6dc88b728fa3bf5786cefa49df873128ff6757c7ae3455aad977ce2ee50583adb23ce2ef5e6469d3a2aa28075f93e54fcb941b21e3b11b0e4ab6818eaad09257098c9586ab436678947a4ae14abce2b21703baab24652861ef7560b2b6aae4e0f116af3c549eebc5ff5665f4f32b70e9bd9b3a147b4ae72391aee014edb8ad8bf488ac7c41bb2f8b3b0d1d2fac75f18aa9570b3df862dce0c34735d890b6d226a354cfad5f3ca9bbe7bb7eacd1cb39dba5c6139eb7239d2381acc129fbbc575fcf71a0ce9eb585cfe865fb6f9c49e1d265a0ed8dc59d31d8a6db0a6d5d4e5bc8ea9651e07d9a2ef7b564e5fee0f99032eb6750c368bbabb123217627c818d65909dce7831c480ebbc61afbec8f9bba30f0b455ad2abbd871ef28448229f03f9abd396c2f69d280e69827004eda3bb04aa59070020cdadccc9a4f5e6bbb69bcb167df980f441cd204aaa092ee5f90a609e10d0c8f017a4dede85357e377fb27df15dfb758b264a0f9322908482b3236a414c34c9c5986fb1bb06cd2833e1b9d6400c2b45864c71a97b702c665469294b5db2ac756a31e761bae2303f68174c3bd09d090cf40eee1ac180af2feebca0d3db7eb75168714a26f4b199a913e98abfa0db41bf4e2640e6a4f478fbb8a8c82c0b8e2fc4ae8fa742aa0635be951929f48378d4fbf8c4399e4984204775d16b0a2e3e9cf9437f689a17f570ab5772adb91147a5b5d0f1efe12e90a8a5716487cc8cf4e79bacb78cfbc6c28ebcdc303646b509a293c18de23e6c16bb59901ecaf9a480c2c9fbfb6b5ed55ab430b4bc5964510046aac15c894f6ca356a7f6474752faf4bbdebac1f89504f5f785543d58cef167000819dc8a525775fe89ccd7fcf4e75af666a1ef2e743348d0a5f52ecba15a7c2b055f4fcd51b9d7e91f22d6d2177b8c82961d8e8e01a673c208f64c282ec58765e6f7a3aa9c449ae77d0b1745f6c550dd24b60afeeaf7d03d61aa76cd55af460b86b6107a5e42b0a2386b0e7df75890887f99e4ed88f94bfabb21e125bdf70ee6f855f41213ec8955ea982b93e59c198fbee6af5fcb5b0b5fcc523b3036e0bb4e22d7b1b0118e81c3db753babec863d276034e2e565218deb59a32280d5082de55982622a7134cd67cb4e0bb602e913b2d84c3805f4c334a1154ae478439f15be1788bb42bf5fd252de6196856b36bea2106b7e72716f63aa7593907f1f32c56d5b65983148479d8908f3ea65eefef452fd85299b9ef75e62815568c1beca73193c6f97335cf6f9b8c8279b6e0d4f8242b69f7ecf111baf1cdba61c595046bb268bd54b24472b243dcf00a9138e0dee2a1f467969cb7afb2db19842b28a5ab59ac31f013cd04fa1e4f9b1dc86a26c4db63260451152b5ab0c4fc2a44df4e4e6e07c59fe8b3b39c7932e1f59ad24c92960902946f6137fd9c16ced4e7f5d6bb2aa4a7257abfa8e517ab7ac9c854fc1ad8556dcae2d284ade79cf9724ec538d0af290833d210807baafae46003ccdd0c71e5cc0ffa1d165bd50cd1f529604469a62180b4990d994f5a0b74d705b5eb6754c325c5ceac8c18d90d09b61d5ebe90644e5b5c772fbc936ff6cf0cd34e917c1a344ddc194639eb494ddae5a19d342a4b812bc67f268b7c768cf7bbdd1689ea693387310a62cba1a88122cfc42f2b910a9477b1c59b7dfee8475d4fe873ad60f4069711222bf5d729c0d4b5bd9761e226780c38b246507bc04d68936d55df361675f9e5cff00093afefb5cb943ef29b3bc01a8887cce47233e52ae3c6751dec0a85b1d6021859ead071cb9f9cb00090d28b808d2ba6cfc4913ee05242d8115b53354ba0a915390656b19d5449a07a2b6c5361cd8c05792232d4eb715ff3d946c53762c747167ff20eb4fb8446d63a9821267690594177385b190345d001ee11eca527f06e363304302a1d991365efc8a279227b3962087b3e00df0109e54777c1b6bafbfca5fc6534f50b4f5ce0b15763ca70013222a0e7ceb7d64ca3a7f8e73c00fd7579fb31d6443730a1b98e1d8c49e0603dd1b73412058805409dee2040cda1cb20b33a0a856d92596b841925956ac20e5949d4a5737415b4bac52f25f20932839a47f55e26bbba53e006667a19f54ff66d7ed2d26b5caabef220b90eddae7d0f80ca058f47d889c17a84ea255a811955d771e9516e28862221b4d42597ef055aca66b849c8a6a8f760e421a70e78b4d2bc2f03659f95e4f5d4e7c013399c5c88241f7d9e89b96b850f83d392a967f4e0082f4c16301bac2c20adaba3328d5f49e43533a0e33f26a538f4ba90fcef43e7131e6267afc474dddb1c287bce941447d93780081ec647cddf64b5b9454006045448f8833b350fcefd0843d7219c3dd8f3a7ece780bac89e62869f96c4c31050f13ba664ba8fa1c675a1382ed5c374ff261252f41cedab729f64397709c121d81d954b5d8556d5ce371a96354f8093da4fe6063a40955ef03304f00b59db10dfd47ee28e3a8e61eb71a921f2057134b73ebe276e46367b5dc6850d1688be65c9ccae244ab0c4182ee1c0d4f3789a1d3f10381fa82f7075d79fd7044bed55cdcf7ca3f8c28b405a2669e7cd3b880e5b77216a63d180210501560388afdb90744b13ebcd8ecd7bb0687a93b9c3780da9b93f06e1f003f98535148a0cd117725e88672c8306770da4c1ce9d89f99da6ee61a9b62ec1b8b24125403eeecd0c479864e7635771bb7239df97ed46b954bc95865339a18911739845fcf65b3fa4a4959860b1e382cfd08d06062ae3d2ef130d5835142abd57117d52afdcf1e83842ea91ffedfb23bf3a44b9225e5e2ef7d8471c495516ee0d4d764e4e6c55f1a54bf4a755fb2e191f1f689208539644d58fcbecf1cee6019c4d36a78711debd1c3a4a7d164a1156ea1bd1822cf333b2bc8b5118a0de7e1339f0beb6bdeb11304736e763ec845c170603f8c5e7573906f3ee9b62efed7dd9c71cbb221b54de12f5234709d3f29fa0ab64f750bdfb78d2f5f3140023f935ca3eb61aca92746ac28fe03a369bb95e62a9d62ed5e273dbb6da673d01ded84fb4ff22603e992a09e3eaba45def9569cf4fd75ab1b623ff3b1e6552a4610de8ec4a19ac115a2e3ddcdf0b4ecc9abde28a68c583d0d0d3c1c5f618251248e59bca6e570ff90e109715290fc5cb03e4a6a9ef3bed8f543318eaaf8398ca4cd4136345e6811e1d31d8658b2464948a6b157422eaf36988ff8f06413a9e8a22298eaaff0a37260800cc534af1905932f55cf786ef331b186e66fbc0e4571ff1edc14eed984af269363c06e01d4323bcf5657c1808786ca8c2a1b9a4b073f29f4286df70503a79d8b0e43321db31c6b275f771673126185a6f2f01adbb86299cdf5554e8e12eb9b652471c37318b5d3b70dfa8708a0b4d5a0b688a612fc0cb1df6385cc5c083bbe56536e9fefb830d97d7176a426629a4e6e59f95fed76dd379ddd771cb0411a52ab94a79b473226682014f63f029d5b1f5c6ddce1ea81c3ed5fade62c989b4b8364f914820b5bd7862808161f52fd3431a8f427f8a19b57d3de1d444dc98f0e24b13947f4bee7542b3d5b96cffd7d1f3730418708d156fb287a93dde5b2a207107d2ee5ea790655c4e66dfaa4887b58e657e2d34248b8a60cccc203e43a232e75916f793210714a683f174fdccb66058b06bc6b20f692d373fdaab8830b30974feac3c36e67b17bb800a6e607e9d7a20d8d723c8b56d107bea4c91686218bf2c019802e1f745aa61bd76843b5be57e86126a9c721cfdc488c6e10126a2e00ad4dcea6ee078dc4307302fc6b87b0ef845c66fa53ade16e19367a5d9b36ec0f3ff78adf5424abf21964942938ebb0f7050e7a44086c988a29217b279685ceb828ad35890eadff05c365be5a82928f8fbe83c82d3ee58be559ae05348fe8b8de690eebd34309e5fa0b69443af09c5cefd3f63da090edaf3f6253d60a16e362d3881ede91d50c6899e441a930c2d2cb0c992618dfedbc11794b374007f7be97520d20c9863fca20b32a78a75eeba8cc65bed347a87cca20460ac836e7dc07543ae001d66be7389acdaf1f2e6ccbec568ef6783bc446d053554d6b6b49137a345d334055e2c4c4bd09f9a2bfce429dcb65f64b491f286877603fdce2155153c62656343e3602fda451e253ae9de5a63d5dedb8393204bcfa5225f1cf05d1ef85e5cd041ab4a9fa57cd6ac0f8253bba5cd738267a2938f64957c2a6ddca0c615c34d72abbd1066a737a548a39e79dfd4d5d3cff9f675551f1709abf1d8f42e294e71394ba5fe516cdd749c31ede5ecac4ea7c46aef1e4845c94f79be560c5f33ba75104f39dbde03fcc26db1eba4a06dbd3fdb2a97a16782d5c8e62f48b488400d1c9684a59cad41a0c6bd391abca247c002a52146751772e763421d0b70297e796fdd41944beea3d1bd8f034594e267b00f3052cd6572ae2eff9bef11d5fde391d4fe356d4ff5029aaa7c2d7c2cb845562d48f536307220372c680fd7c2de232cca6d0f6f1d21f6c30ddbd30f8f7cd32a62a3a968ee62b8e7e5a294bc877b5d773e65f6aeeff430e73470127500bc1adbbc53895d81b0c3060ddd652f932346268acd16343be221d521511fffadd56349cb51a7ce66dea757d5ae61670aee1a27f39956df12fa9fadc5b05ea83c46b80302139072ca450280c378c33534c5eefd1acfca03dbfdaa13a04af74344f2aa3b703f33c603c19b4733372a9072487c71e910ade88d2a6f6643435ab145707d15ea9e7172b66164f98d4283c3405be01f3261dc5c2338ee7275226a7e8c9eee1a55ac02d83f24ebb6ac3d2e96bd84e48e7e3d842fc961da8c16484c0d6ea7c5666a7393aa8c910006bf3922ac9e12cd631efbe2252c149cd77c21bdd85d84b09bb8acdea681c777c46edf45df44025e7942e9069befeec36f468203b2c4748b36b44303bd4179ee1c7be1551d73b9cdf4cf8cbd575349c72ba37d24079501dcc1cb529538767477d6f07817dfa06af5410d08c7b09046e0281bee19526b02e4ede69675d4e3f55381c55f6de7fe59df4f4516629cd346b78acb482fd4fb170ce2bd5a7e404b6c687200f2eefa39c8fa56d40508ffdc379e2b433272b29bb98532c0529659278705e6486190aa077fa62e051b2926dce7a48c98dc7995de47eec905b4342b24bccc539853893100bc66267f31c286b8a104212a862e33be010445441c39c4b2785836062d52ed385c8273ff072032fcca49fca52a57fbe514a1bf5c63853ccb3998978a949b691cced79c9fbe569a5cc741aee2054bca4c1cb0b9ca0f944ffc4507cf21c008ac1df375b2027ca7a8e7046172b29aa02e64844c5a786d8dae4713640bc90025e1afc83e2653c3ee739d63137042dfcadd366e85f09370412c21a71d6da39df65b252f7629d8250591f3d87110e34a2f3ea1d46d2a531f5beddbd77ed463c06f6acb8353808071f85f2fff9fcc4e80e1582821da2a1c00728aba33bd66aa6744f89e930601c6c1bbf0f03e646de1dd29380b899bc8749e5df32728b6550b9273f27b6fc143246c2b49efb768de5455bdf18ea7881d0b3972ca5f6978bf2409908f6ae8380ae766d1e43c6fa6ca62a1b914023702b03861b86efddeed72cd182653fc5af3edcf8d1814571d7b5df6bea07dc483a2ab4a6aade6e4e9f3f2c8b501ace4c2a4c7f364b1b7c11c3be2201ce06cdcb628fe063fd503de4179f6df42bc80ec89da6eca2dab1a4ea277c5eb800d6fe73b615ad7db9931d95039eb23a38f56a60c106fc7fc217e6bf8041f2e84140c9fbbe36e79cd0c0c424fc785a140609560e64682b480b754994f4f2c0ab601ac30c8b06eeb2eaa17236890c86f6603fc11c4370e0d6bf0a9c2bbea491a1a96d42141da78b78cc83cbdf45ccbd6f41a45e2e0c94b272bf68f5e975cf170dfde39d20c1c2d50a1ebe03ae0f4ddf43b6804482dceda736f4c2936e746f74af3044c6cbab8ca0cadcd7c8d5a83aa4e863bae738618bb3fd4340642afa16625322c5656f53c641e6406fe94c01918d46707d6e5dc6c65a9adb8bcc6647d8df8b3fade85f56bb54d503f5e2dd409b0669e6f92b0a28db73a59c4f1e85429a13e79311d2aa9555c91fc2935198c3668c3db00e9d24bce5dee397871220542edf06ef271fcdda492988feec50cdd57c1ecf42eabb8c868b736c7ee13644c2a5907eb7e1c2e83755221b44a39e6058b3e809caf888083767cfafb0948746b2af2fde0fbfffc42331d8ea85428729f7476bb5a02a2660907552f2d63995f91b017a7c7a2e3123e96426abfbf8ecb8554a1492b0090e2788bf8b0f973981131413e26f7902ec2b355c92676fcdf55198d9d4a67fa9259218b7a045edea9992d9d5bed13af4fece105e96ce138d1e6a836721f43d7ece3555076f730c77a39980db91aec033bd18fe53a9fdda216581203156f2ff73aa3b3931192bfaa6b0cb8c2264f20e956ef36c8861717a1150764d15604b30684ed9f5d77fe96328c22142f8fcfbb4db5a402e9599fcac507eba4895df30bd61316d37d83eccdaed33af3d30f372b49d77f935ac6ad0dcf8b8c0207076d263f8c2d81415f94ac9bf6224901cab1bd6edec29f31ee10da7d0c026c1a9258b62ecc00dfcfccd2409eead2ca27313c3e6c6aedf76f5f5bc8d942d70445a997c6a5b6ae803f89d19c2698080f093f9d2be5d03a8ea2d47c24de87ebda917281a748d6dc7e72bd6bf1832f2a6c33c3f7290fa332803d3c37588d1f5d085504c649b72f6f258df5469ef5682b32d4eae5fb9748bb350c7c24d1605182feae23757c4c15d6927e648fcd74996ceceb6dc25d73057b714dbc145d59b32bde2a6be46e4e10146d4c8900318f4929e2306d0af69f7e6a01200579df6476382d1e2ee7256cc45cf5560916b161a912b602925c59b47967bfd062abcda79126e24dc58cd773c1aad164fff7e6ce9cc54eae1cf4e040d6a4edc85cfc7975cf9a669cbb344f429ff15a46e74727343d2c1c60d1b72dc34fbaa7089ec15b507f88927be263f0eb41535e7ba0d6c8f8742eab968b709c8db4c953fbb1054bffec389de9f7fc9902499b477be49f29045e8432f6556534711a3af606fe539cf49bd04bc8b71f7b1c5542358f44c5a61306db6464a099bb1d9651dcb52edc237decd06f2158c534a33752e02c3ee16f854e828e7fbd6a3b372c37640977d5429a6f12a64525f31d85b0947c1641968a0df1c4c5098a09fb206b1bf69468be5cb9d04941fb8fffd2cfb7669554a8d298c7ca64533c06281bac0d40760b156c5cc7ab7782c7f7e34189204b7cd9d7c9d79c9b898cc447895eacacc72e1df48c8e07e15a27aaa76b535b45a846fa5f9ef9891e12fda4d667c717da8d26e66ea38a9b3a65d8027d3df4ac9551c248e64e1315e611e07508237fe15eb8728efcee87fe3541552b894802f6a1240f3bdd3d936d51eec1c39ad2debc7931b9d8c24129511d4bb780a3367c6c32c8bc490c16bbe9cd827d6f89e42ba73e8f34e1d9e99fbf672afa9a5aae79168d239306ce3e6d806fef4a89c2738b298a2b0939ef32ac028ea77af5a8426d7fd0c57d3ad833d0ba926bc848d6bd9e07d1599774aca9ce96f3694127118201b2cda906ced27413e787e4ce34a8ca13fd7cbdf13840125cd3a5ef75899e1242b4c6d0fc4a1d8745004e567a7579a6b4a491bfb021ed60eaf670f8f967f979fa4ec859f9135086fc36aa9c4f7d1aa3e4c70aea1fbc877c1f929822fa4c5c210dee660f37e2a7c9b66dcb3b9be3902af9d99148d1f6cc2fea3348fbc90ee55c56e5ab87d70515027a455276ce145d1a8fe8836faf8e4567c8b0d63b250cb7fdb4245386854f8692d49b26803fb39a577a714cd6569201886817ba6fe30672d1907e1954f4add995dcf0acb93b1c377bc2f4fb580a83185ad01e0c3b1b24eb4daa2e092a21157a2d5e8d35a6710c484ff3c2e8a92c650899b8ecbbc30c42f9eb81878d64d0e109e41524398d8038dc3facdb347866823996bd05cca3beda6b078a99f240e1a57f548e6a775c0ddb9244a51ea81c1ce40b064bae026c63d14b5e8452767ccd2db6f5ff1c7c79760193dcbf4bbe17dd2fc72c61564f2aef4a62e4cd1aec1bcc3c384f628725588ff11fae156278cb06621733755541fbcbe84b2664150b7cec57d443bb4e4c366fba7861d5f6def274f8c7b3cea241a428e2b5f6e7f5f293d2764ad466bbca85133afaed8c4c2534ead0855770b0c3df3b7ed5f2ab4277427a0a69b4c81c7adb565a05a0b3ba16eef02c185faa8ade1829cd41feb8edf33764a11ed018d2384fd407038e702f013d16131c7bd0e632bfc68a6863096118ffd5b4e322d372e8b69e4dbec059db5de6af3a50d6251203dd800f015a75dd364c5af09d46a7c6719123e902879985dbfd58c308d9849c01f501c3a51947851228e8db173bd7d2be11767b138f9823ce0957e69658b9bd71d543b52e6cbf354773f9711fc08035daa4ba1d18bb1df55c42efaa0b2ba6d987db729be66d03e9f0ad6dbce08d8590a90c273181e09435ee67a91631806e01c5570a78482a8e3ba0d29300cf69623c137e85593909d0604aaf0227dcf6e6082f6d7245e960e3ac3c61e6bab61aac41b065fb559b242c41663040bdce4e748407c20618cef506fa4e3cdfcb82e5f037af7808d72070096988bed0b4e4b8798c73e7f1352c22f7d3521bce56908955d2a257edaf2a033705b7ce4d0db8147848f25b3f891630d510254205283e21fbe5b0fedafad26c532ab3cde197c128702f1db8d89317db33fe4f5fe29ee1f523a4189dc10edd6c7f465e9a80f1d36153f7df17a9abb817a6ee82c65c4afc9b6e4a2d43c37342097f995c42c7ea65e5cdaa5e54c29ea3d00cb8b0f9594ab18533c8ab4972abeb65f0578130a43e33efff2de17985d28399050b9cb2249510993d2904adcfc9992b0af6751b379003be41ff6c6e5f338dfe1f357be33cb64c56f69dfb7c44c17a8b7d747374448d34cf19dda7541dfd2dcabcb43c437b2f1efd6fee677d7bdc32db7a0fce0a5cee4892342da7d091f9a5590af22b238fe31a1b44b8e8c89aa9b20046402412b3742d45f225295afe9b555fa80e90572d7dc378af59f2c2e70d4663d2212e0babc94f0c128c04dac7f0f73e0bdbe6163c9fe34ed664eb9b626fb010d75dc4948ff26f5489f1a393fb717898679459b2db07512d75551efaa0fc017ce846ebcb3a7d67c1d74cb43546ee08e0dafedad97c7771c7c6edd686fa136253ed63a26e2d1693ac05c3b118882880614df3535182f35c905dd3f8f4dc5707afc17aa789f6ae0a18202bff929ea59500f2951136e1005a85fe2222b9734e5c3e3c6a5cdf3adc9895fdc4661f733f4c81e495e6760f50a925b45ee61e7e4037b072f89a2c59c7ef97a7cffb1025fcd083505760ecb71ddda9280ff68c3bd007ba7884aae919c9acb099539b0a01d91e79d7504cf6e69dbb2fa181d52f482f9f8b1ada157fbcd64879eaa42222a0dd0851b570a778ca15a99ec34a26880b8fe472bf3e2b2ca719a295700d800823226a5e0cf6fc0f74f848c6e95f5aa6a6e90b3341666550966984ce5ed0eb9a2375bd8fa2e39ac6dc6d39ba9d09b7ceb95a089397412f89d8b10503822f21fc6965048382f9a97994527b6559859dcf3eb1aa40d395f3f9b1514562169e11d0df2e32b0852ba4d21dc20fe74a7019444b90984ccb4019bf706190de9370c5dcad637acc3af2f771845af4ccaf46039df7cc845b5198e9ba08a5665f5aba28a0ff409b322d6dea07885f419b385c40a1dfc5204e527479abe7b72c4570752bfb43e9f1ebb822066e7d19c5c9fd1933782c88da3b8c9cee21f9c6e3983c2ce6658bd7270601bedd43d841d8b2972a971325339576c7f0ee4bd0adcffd8bb80e6b6fd78c62281a656c1c61811209d4c158b8a29d8049c7c90688eb57a3f00bffe0e52387008afb42ae28bc074232183da77853c14adf662ba01f0185203b671789b311e6af4ba47cfbdb64a3598e18d0b915175ce05e23cdb42104b2db1a6c3247a5f15c2caaeb0f1b61a5a4c7f6e01a19569da64a6236290de36985157fd4ce59e297df0c03655cde2db1b8c4c9e95017b1b012e601539d5a4a25340fe4e9f005413befb6e9a68f8721e7d23d0d25108895462f050cb635a92184a0c6f4e721f840bcbae34e60958e5a2a24553c9acfa6c4b0af4680eff61d180da9fadd604d22bb9e3d73d6745641be02fcebdb1711d42384698245f08a3f14ae50b57bfd9a5ba34c1bebc4e4f947faeef539407b73655b27c51a36f3ec371654831a2ca0f08f42db88248c6d03b5018b87868189ede4cc25c53c729970e285969e14eb8261a68cce561af8c8ce3c5d907d38e97f55d2e058445d9eb99ed3360a62ba3b9a28d3e36646e830983b57466a3c470c4e29f96edc09c53c52144232cf1aa77c43db03c5f9224af6597819500740fba0befd2116da224e4f301cb31ed3f4d8cf927c02829ceb627b2445cf1ffffe6a45e17da7448063e5f30960930e1955973179a300cd82e5f0ce8bc67f9446a9731cbf463d4b8799080c37f75337e725f9cba73a46df5d74c55ddd072599bcbaa85759c42cb5e55e456f0a3e35a7f19c88abc77af640be77129d407106780cd5c56eca6c0dc665c40ecb7d0c35ec37f1f7d791faa82bc6a64e6026a4428fa94747ff927e8f4d4a45092d8c4040e4ea3b16933cdf766a655af4b7b6fc88f5d8eaf3a68535ff9f5733ac79b22062d53ebd10f48b8ac98d820dc7db2635b13427dce023cb64ea71b459530d25661b2eac32ecb0c565c54fe5d8ccc844fa36cbca873e61574389988ae1af7ff528c5ff88a0765ef4e64dd0a0896e5eac9d6e7c82aa25eff7cf42a4434da58a38188b0d62f3161abadd3860f1fd9b5568ef7677e9ca1677ea795f83ca469c7e8f9360d077e0798a4a9da069ffa1ca09de2f14229f94700f4b0061545820b2b08f8b1604b9e430b639e39f7271ee1099fcdb8cd0e3c1d832fcd3a6d5abf76c06a3fe0a5cc297776013774a47c37568ef71fd6e5f9478f5e89121db22c652a935025de05148d4e8d888b8a8fde21109f2c9d2bc2a1a2be070965b1d21d3ce4423599629375a21fc48feb887ca8ecad8b03d6503d05b72d366982a5677819a1fad97759285ade81e06409a5c7eb8c78e0e70aaab6bb420e57d0eb8dbd59aac4186dbc9aebbc995db7007c9c179ae5acde77701d447ef7a025c2423f0655d4cdb89fdd6eafd9fdf7c9e57d80678ea8ff63bb71d3ffbcd8d0a23f82641b7c6265e53a22aa0806d29b462556b8bed915ac6e0c176669c989c88aa845bee3c361ad25e4c319e520569f146c1da08337cd12e520304b62bcf916be51239ad5e36c476c681cd4dd0fc3c4ccbb795797adbf4c2dda4f926139480779c121d17584f6138fd158100c701db81d569f4e08b50d7b2c92ed1d8923d26f1c1b190fabc7243e7dc1c068e7940773918af1b74c0ea5db361e7b1fd6dd11d40a77d805cbce6811f1c74094352e2a0394c4bd3e0871bc6b9f6b01f0d8aa2124d0d7b835a1fee4f879164a63ee2072af3b1ed7c7187a6c36f31e2d2dc6e9057f24d01d77e8fdcf377a093acaee36904aa5e8488f95c175e46019cbf03ca63453b6db8a818422825701ff8372199f9e33c0cbcfbe2d7532c63c4023a58509bb506c8cb73c7fdc81d14480eef0842d7317c6ec0bb1f862f56dedca00f5b7b90c547eaae0611d1da773e99295db5ba3fafbd2d1ed2ac6983ed02bdcb729b16aad725732eeb589dae52898b66601e60453dafca9b1c37887f3aad3bfef9bd55b4b9adde3eb9a6378f2f1b90fcd9abdf53b6923b0531d5eb439065fe884566acde813d960055949d7aee39d0ee0d4b318d460303a5943762d0e309c1fb496a1842cf6c12269e5c891547fb55cdb001d30fa0e2458bdc68992ff18c67c2b9b3a3a8e88341fac309d2ce7e7ce6189a0334a0ccd2d4075c3965e1d8ec7181cbf39eeced8fac8542ba2bec07da0e65791294fb8fc174dd73bc168ff8bac020d3ad3cfd00d4c129ec96e3639b0fece86a970c8f4d836c3b28d00b715d01c3036fcf94445b3dcc99c0ada2e28e4d2647ca16f090fbf81637ed158defc15441b5bd88e287597e81da2123c2e8046840f485df90dfca2940a6eb0637ec69ce33b3bc629f52a2bc5ae1868fa86d2650e41334ed4fb92e800724a55ecac62edbaa77651609d8a82f9c756d4e567be36499962462918a633ab0f2fa68050c37a9356d2e6a9e6aee8e4ef59989322a4a65673ef0a37e9b1837b20180cc41e529aca4ce148438656ba04bb7b9871fe26e4e7c3e19150f4eff6667219ba9f29a530add445ee45030d82ed9cdf4dcc7fbf11b04582c6332f918ba99a757579dc8fc9844b4055be5a9cd79fe75f6add1de913aeb510d18b9deaa019cdb1dbd65c545419161ac929acca93663f2ec6676e02c310c8663a8624960983bb2612513c6cee8a4b0399aadda3545fb25ecc6c79d833f463be0d06709e6e8e1a74331f578769ad9360ff096577cfa52a8459dbba3277cab294f4e17a79dd626401ee8691746601e598466c9d7fedef69a1c050ef50c45136b9a9dcdeacc9ea62d29baf764aa1d55791d58ce32141f769e87fbda2297d5aa81903d4a6ac57e932325e1e172772251e0122ca69130f27efc0ed18703e1a33e587f8f64fa9a0791798672c9d17896384f74cb440dd5d057fac161991755ce604dfe6329d863d02c207a083c4c92435f68b8a8a9b73df2d4317fb2929a9213aba480d7a81ad6f7a46d7627aa0ae088bca19581086b09024d0c948907415d57ea1add8ad7d812e8a48b0fe3344f98587b08d92d2bdbab54f1c80725bc1f0d308f2ffd072f4ffc9bf10abf321538d56a854a3c6bbcf69d96f577b5e176955facad0b5fb0165aa62c546d01c0195dc757777ed0f60ada522656793a3ec1194dfe7bbe327b1ca918cc905a3036d8f09419c8c977202841d45b0da5ad2a61b6660562cb78a5d0e1d097394dfc0d7ee96cb985a608076c7befb23c919f6c9e9bd4e98dde2eadfd66a50b850cc922976bcc626e5b18a0f7968c27f2f99db05d96f3074897542f0a676906d10dfc0941704cd275b783dfca1211c644dcdb8a06f266004f68eaf1fd49e2dadb224a4103f0e48ddb4ec09adcfe88e76e2a0aed99d65a5287aa2868c87ad173aed1f2c1715b5aa97d56b22d7d6dcc1f62f96ceab17c123ed7ef9acac76fd5207579a56fe725b5e49ea1c7d987b8fc5eadbc5e3b2732750ea0ec16bd00c5368eb55d0871f4f42182a480eebacea3783f6665078ae3821be428af920baac7dd5241befea6cfbb650c65edbf795b203af349f30be236c64920edf84c259a0a9ec9a7154311083b27a3ec475cbaa047622e05705a3d3fee866ce9759bc3b44e01e9c614e7a713598d443b677e04fb962cda548de696a5780b788aafcda61b231df6b8b74f17efc787fc0b08ff1a6ecd7044df68de4b0dc6d6a78985376dc30bc94c326ff70ee8019b8997aab0b54a338ab5df23b8966a9343611a549f938ffee13d0bece60ffef025e434fcefe939da59fb227d3fde94fb05159d035dd442c8ad96c8ca6bc334b7d00d51bffc65317b6967c1e3469fa0f6b488504e4f62cca233a39a49f82df4e5d068839175069e68ba0763880056501d979d96c36f896152a3066009098e8a444bb4d94e133e19ba7c7642e62568966e332bf65eb00ea1dcb2403b8cd23750e9717451c71500f69916521e353e650382a181aab00dbce75107b0eb0f567981a44a0759c4450e7f2fea391d4eecbe031bc7f735ab61e123abf7e1e919a32d6575e4a31d2b8f8081442b560e6e62820dd1e50d7e09e9bb3537bc46ec3ca8d91dd50bfdc8c9f3a83485e4138da4f8effc277f5a2bf8d884e722d991c3c98a5ad90a513facc8e4bd776222f31bf1b53d7f78108f518428a4aaf9dd4b198d23fa2b784991b5149a5f46050d3dce2602d7337c042ec53a42c9c72c84c94d5ddaec9cec93bedc0604bf98936c17bd8d489310b79de417f1d2a4f3d4632a8c48203c99c593807728707817e4b59e5b6772779319e50e3cbb8d11073967e12d9ccf7972ab65ee18ddb3debb25f1d4ec8bd7a27d3eb4b89b09cfb1c7839b5ed7b699b4599378c8be2ca447354e3994bd5ea5dc172d7844fe3fb46358c28ac59f3730d219bf5af40d26d4ab2623713a95f39c66d972279c0d8fb09aae3b2adfc191e292ac38068103251f6ae50264d4322fd18301652553ee91d66b3a5e2ec14090437408ff4279d91a15876090cae4c4e1cce83126c1450e8927b1c9b0d61fc7e6a3d351efe2db7cadea67b523168aefa58586b53568feb73b19122f7c76290eb55d4a280c69e41ed852ebfb820a2ef81b37bd90bb60a60d5bda7bfc79a668d1e1c518fe780135217f1f406f293f3dda75c995703fda81e4acafec4435926f79097c98aa39592c609846a4c5badb491ea4dcd548bf26a6132e2b1d34409162e9d00dc6743c0bdcf2f04a18970a0ff7cd0534505d7d7d349cea055239298d34d2f2cafecb2d562390f0e3a6427cd3999ac6c8ca3210c53f79af82b13bb28f2d346265c50a3950cd580276625898897f12595085e78e556e25a70f01a8e8101ce5c6af0f3e891d2c8e699ee5d1c2f9c4bce781415dedc95cb418069c544042cd69fcef4c0cd6766446fb8aaa6982de709ce9fc63bc6a57b60afbffa6d0153d31aaed2012d782d10a990469ba61193882e55a2a3a0b7bdecd41f0b5377e65c143ac645978c9f11f2694a325450fb1d4e7483d9e318c84cf07988800896e7da99e1c9a64cdfe959a721b241b242c2ea9dd772b275611be69eb3eca73bed1b9a80bc6005141c889ae3d5a27b7b73461904a1421b927ab6a7d904934dd15f686ba2072667b6c206655b8ee031d4750aec9a6708a106fd5251e9d367b9d2bbc1d91f62901edfa9f2ffc2b753ef1f2477fcf2606fe2aaf364e656df2b1f790da79b1e83b1d182b4cb5022397d9f8590a58c66fd07696a1cdd281ed81c5fa97a9db2e23e0db379e975459aa94ddef389900ca499499936d196a5cc1eece01002f2bfa70c10f3b8b43f0807938f62364c10ad8adfbcf3e7d25db414afba1242044573173fed6ecc073e7593419e348a22578207bb40e523d4c1e31e2630d2b706c27b7a6c6593cf3d23287d7472a59b9f14341e301e99b7454b588343b029b439dcc0e15ed99b8bbbb4db4dbc2f0aa80c89f04419e91405c92d8613a16f3cf5cbb1d974ffc92b093601d272aec98d610615c764b7f719f2240da572bae167740f509e61a95d18aace2a2fb62abb840c7fb5079b47100cfa3607eab35c9a9400253ff39ed9e058998e87d2b11dacda9670c82dfe0f6e3829df63f80f4c131c2cc885e0e47a19cd38441f1be7f8284e4af3f235a6079457ae3fc33ddbe20f93554c487d7c8132795d00bd523aabddbcdaaadf02a1dfc7e058fc54cdeee0d04ee0a0dcbe68ad9d9a7f7744bb7a54bd1cdad8ed521648951d09bc9cd8463d9846296918591d09e1c1f5e2e27d580831a17a843730ae83cae34b362d121d9d4d52cdccb08acdee2c9b25bec30f33ca94c359212461249f6b64dde6096481fc54eec804013bb61ef6bbe3e60ab5ac283f091ab6412e5a61a1bb398aade2a5b3adb4a7d129338b0cc655bbcdbc74eac5b2439388f2b0ad787893b6a641ade34f1bcda6e0f9034b0ec3b782f687da256bf522b8ca33cf549731dacfa633ad2b7037eafdc36d564f7180f98e9fef4a30c0f3ec746453ae4e03574e408f8133f75e21f13815a99a998b3141f39d57ee78465ddd57ec99312c2bda22bfb758e8743932dbb6ba1edc85299c4cd7cc82e29ba9af64ee0ecc7dcdbc606944b4c71050c13ea9ca331d635c6bf498f8b1f1f837ab2fb39e84afa3bb3b001c50b25d32e73fd2bf19de906790d45f29ed352e93294b20694d8a45826b1e66ad8250547ec79cbbed344e8daf8c8174669eb584c11d327e790cdf1113334f816de109889b3a87ffe7325ba2c9db72ec979aff9f22e84345e82e7bb374056977f894dd4b093a9fd95021c7d10d4c29f6a7bd00b5f1cf765ab06767654e03f1388efdb8ac30d7a0521162a3bb282d950768df82acd00340ff5a6a30444dd71a82210aa41522d2ba69e2613bdb607476104dbc8ae5ebdb664531c3b01ab98af773fd2068619e9c2e6a9f6754c5086f8a0a50bd476fa95c608c8449f73b9040535d0e347941ef92000ba7107d96919a65d152cb387463354a51f967c18e057e6eed359bf8c10f8a302eb9d8584b4c5e06601d5300f9d44e9c3fe5e186fb47a14bcfdad5b434b3408772afff2c1255c0d6461e21919db800d38877f39102f324e76b921649dd366d218d3e543f6d96c06a7ee0352d99d36b979e0da456be260da837d8e08939987c55cd8627869d487cfd0efc10bebf7dbfb1c8bac9de433fb633b2b9a65471dd02762f7c1a36b4ed2815b28b6a745dfd5a43ea4c36c54e93d168900c9fffcd54515ce182b6aad25d571640b9c855fa9ee491c846717d978734556a9a343bbb2ed732ce5c4ccb6455964e0edab757f934252f54d15d88fb804569a8c6b376e2da85adc16110a093c9092d053c65cf0d9ff82bb97144f07eb0913c6d3c64664ea1c4612142bc4b13e7240738d3ab6725be40f07f2535e9c5037c619b66ef90336902f75cc2be20b1e9017fc6f572f597f9e3b0cbf44d165c873409c925a79fba6275f7f7bc88cfc9141d040d42f907d05ee7aa27d9a0618aef5559c28e19005077b034dc03456ba01336c0ace82f32561c003c38eb2f952744b6f8013159e245b111905aec812fd1355b4774b9448362a84a9dabe8b3db92033d521a94235d2193b84705a2a5d9d2daa96eb65be8571c0d87f547bc96b0afb59ffb2685f2b422124df82b2a8720a68fd121187e555af15aaa575e756b6f6601423439a5aef6f8638a5f3361fbf9ecb47823da99f2293c58c8957444153fdc2c7e10e531b5f7bd1467e6138faad843ea7243ad78d6f3c77ece4aa455a702e05c149ab83a84436212c5952a348ad76ed2f16c2d68d9ff55b073f7dda1fcf606759aeaf4b07a2a51d62a02d086f593689eb5c7f8a8e19e4f937afad4db1e92c342681586c387e5f9bc68353a6363e8be624944dcbe8706ce9b3de3d67631d2adef12343a1f9e49db74daf82473bd843ba1f3883bf0e89b7b4288a1d881c12ad116e43a22f1a0278809c266b95412284aaa7c0c9e4c673c225975e8e2c83190bb5beee17c4b895b9dd058c6b8f7b85223145a38e54c76425234b20e4fa7437d6c9325aa93557dfb761d78624b881c656546db764810494936e30cc025b277ca64796df39dabddc3a33d5f3157b88f9e3b82bbc73cff5ee3df656e3b4f7c4e5e3487b494bdda85784b49fa6d9b17b8c4b45743fa5638996a79b0711683c17ff1f0331cf2361916f800b2f400d3d76c885c0c24d2976650ce77c12f2b630279658e4f1fde2b96c70946f7fe7f572d5ec16ff2ac10ec375dd5e08d5f950a7192d2bd199cbd89403f0bc5550beab7d96f1995a772848c8d6a470dad7eac9fb882ee451c1756b4a84b6bcbbce863c9b0d2d3f94d533c3727e6bef4467cc5e13080f66067e2d3ea05030732cbcd0d5e25e9b78965945097e4c3d3517d8dce97e97397d9abd8d8e33c32c1f9787859e791e8fc2c131583cd894ca591007f835f09720016d24eaed5cfa36deacedc6a7fddf54b6971d271f467b7b68bc439c43ce0142cb4bee8c8b4837cf88059fddacf00d17425a136c9c691ba6c7f06b7f8f4d7db9a19e929da2f0c681aae86f93de35168f93d1fc6145b81089ce061245b296c3e4fb7e6478ed5b8837a0d262eb6879c7a23fbb8aba83e51b2adbf236ac46d7b4b1cfb07a76ed168ef4fca8610a410c8aac6c4edba6ec2daf970f802a8e2bc04198346c70921c56347282cc8b923ee87d976e71cba53f0b5cc95bb0bfef48009eb05445db8e19f52f7df4db61f17e5d69527c391234f958121bb18574c196b2ce2a2e819fc0d4c8d1ca127bd80f44ace9e3592eea2cadd534351d167dd6a2dc250117e8b70e715a96a8f7c9fbd3887ce4eebaa7a923e95455cd6948ee0ec1120ef8c677ff3897c4a3591301a7559d61531328fb7014e0c058afaff250732fcbbe8343ce5f6c46f9a60e74c2051c416aa88d3175af6a8f0752614eeac8dcd5a5f14007ce8bc377f6f47d0ae3338b68fd77dad011a3fecf202bb88319612803f346494b75837bf31d0bfdcc971776433c7438d4d641743ac11a1dd57fb854680431ec8bf1ec748a5b6feaf55e40936c57e7c96b18ccfaad1aef28c4d6313305e728420b8b42fa","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"a2e3ca934e917808643d114de5b53fd6"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
