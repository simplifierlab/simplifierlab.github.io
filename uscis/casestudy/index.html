<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                border-radius: 3px;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, .12), 0 5px 5px 0 rgba(0, 0, 0, 0.12);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 4px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                outline: 0;
                background: #212b36;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
                border-radius: 3px;
                margin-top: 24px;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #212b36;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #212b36;
                font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                font-size: 12px;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.2);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca56712d913ba456b9769da975b8377cb7fd639cd9af7f97f46f70775943c54f3c6a7a72476b989fa3e63fe1bf41ae53754ae2a337ca049f3226c9a37ff3de844f826192ded99416b82d8d2426549bd8c73c6ec8723764cecfab6182f7ae6b02a0c0f9ecb95849f04cad64736e008baa00b9cf9cdac7d86f5da8a8ff4f9c7398b25f925d72ca8004db0bfc6efc8268790ed9ecd80247f31eb961d2119ab7825d69d9a8db33c49a3d0454095196a9cd1f576fb82767c3ae46696448a333b0ede2b082551e5fa06fe1e6758a3435165bea61f151f6d684a639be0c7761a890118ebe96a8bb091f86dad87d785afb4339d259173c48945832efeaeea890ec72a913352c3c5f8a78f0164725ed2c73e877deb7aa5a369d8bac7310741fdffd182819ec157c83e820df755b3cfaeb7846bd9c1b91022aff7b6ea1b61e22202518a46862d84891d5adab3db55b0ebb4122997ebdfa582f8699a86605152cbf57106e9196fdb5f1c2cea5a583da85e64aa1f8e950afa90f8c396e55b254e3cf401c36d5c17d59f7e21c5160ddf1e1e2ff1b1b48ece2673608bdc92983b31543d00db1e4d7594c895b8b73628cae20a7d966577874bf5a08fc4256d119544695b2ece1043632c6ddc8911a3005ad9f1caf8d0292e40cd9e8b56527b6eaff17a572f39992c018a35bf6a2fe38227547ff0e47b502033b5d331a3274253442d4eb4f18bcdf22e1f63c961b7bc96d452d0d4e2a6458c2eebcda5ff5dbf8c3861351c470a362e1cb7c7f798056ada14c09c23a9dcb2d44b0d1ab266b9f74533f37c0c3c042fa8ff1f2c5d9d0b8cae37b26910d2c1fdc6e6cfb7072f6fb1141f015a4b095ada8e30b0f98b9d6964cf1ed1eb93af30592012284a0e094c4d0c23e3f389b6235123ec63b5fdc29c622cf808861ab8c144e1bb55c7ce8158f93f5647c96c276d90360f8357f0998a44fbe5914013d58465c37133c7b52cde31029bfdd9b538881075f68c06e56c0f276553f61c1d817b9cc843e80185f022a44dfa475eba61692dc9973b3e509fe1b1353350db4659331ef39e940643eb48cd8c6b8cb8ee45e4226147403a29c2131e93e8d9401d679d827ed17432632d3e5ad3f4d029879ad2b28be39853ed214bf5a2ab34243d7d85201353c577d4a5363cf74d08e3e7914e9f264ccbdd411a5fbb34ca6b2768169baf74e56cf6212178f0e1046e00a48c9fb974cd8a70e7a5c0136c6cc524f8277feff673255e3352b216df99275ced6e0053e2192fa2c661a47d62ed7d3e228410b22cbf0d47a4c4284c6c641c9071affcd588b3897e48fef46831a87768f343f50f4b6f33de0d85ba3ec20bfca15aa7910404e06d381bcd55e301e284a52a6b6e1e183628a0cbedba37153f2e60920f8d8de9339847fd5b1b63773a5785bfde5e9f05490e125485c5088ce8d18bb06e6301e1c1f0262734d7c7f78e90f62d1aced4e6cc7d2794b693e81d477af11fcfe8875d34566a8fa5cc8f230c0a3dc225ee397ac723beec1fdc70f5637b80089cf7aa893077c9aff3074da7979a41a38fe7e36dd396e0d2d255b0f578abcb4940d4cbb8a00e77838577e4f1d692428344d54de6f54f6d1c50fa813180360c79e6008d5415475d259a2afd4df378a8a8b39b8bd363409ff8dfc4babdcc2c854e6eba60c30d1b1383ffa8f515a1856049f5ae8f832699db82f47c51cbb6c8a96fcb6769d551a48ec5dea2e85b7fab955a1967419229b883e5e7a351a411e2bd0f3d812c2713fd5fcb31c591987650c2ace82591b613c1454c25a7d03c1aa80f6315d1ed74774f2e853cbebe8b4bf4ecd4cc472d571a519c7b4562fb7abe8b34d11ffcc8e487a4b9b3856a18f9f98323ce4f28a423f9c06f28809bb9e885a6940f52191a103fd76198f62f415aaf2114eae47f31748cc011ce12e6886105e3731c14fe2d92f7535760f180784c32e8a68597b4e0720664f795ff6cf210cf5bc01f17ca56003f7c5c6371deb57258350a2775ad6cee8c0eb3ea05d07ccc3680160a9fbe9bafa49279308cb98b8972c3d5706818a991d31bf218683e7dbaae8e27953a24935a45baf59f088c3713ea22d8541abdd7f6a776362c9b70b5e46ef30521e58f9dddde2d9a08692a26936e576b855a0791b808c743c980a0e61d148c40698329060c6f65e79056100c78f34db27c80a1db73f83fc4a345f218e27b3190c104ddcc8e21d65bf86f4409d5b6bf691d238bc12ba29b172cfad23f481750c4a93e0060721c23c56bf190bf3d36eb4b5b6b8d941747a9fb45accdf56cb5dd24f577777c76242872119c0505790c555eedad32bbf262fcf0a650366c7b1951b76630eb5062721087c3807e39f959514e1411ba75dbbca8325e1b8da306c93cbdfc1e7e4d7d14d179f76e569a8d2b585e9b9eac757a38f55723553f7c6fea0271eb29ca7cd872a1dd0da31b7ee41528d8f7d5e3a668e653abe4b88ec3fd221c1faea3036e63d2f5da3b2449bb1b9b8e41d754aae74e54ccc77e2b04936196e7237faebb597d237307d90aaa810b933524da2d4f0608eb4ba6a1323f18b0ca31fc951c95b8eae590703afd9faafebd1aeb1afa0e2e6a2ebbfa83aeba7870e2d4459f2570ec8b6b76dbf8f026436c545cc8cb7a4b18bae1202915ab8bab2726ab4fc02d9bfb8a24e038b49d511ad335384cbfcb945d3fa76fc2e0c9fe228d478943a9e5e9ab515aa98e61e4005c6bff7c1b492f78caae0bc8a57963c03302f7c158ad6268536d761b17727eb4ad80f8d6e77c03d31ebe74b609c246de48083f45fe2ede5cdf0cda31acaccf190b5041a1ecd57381384fa4a861aafb15fbba0c9c29dfa1de9d1891da9cbe3cd737072f00f085b9779760e64bdd34c48850cc3819235b85702189d22e70a0717eba0f3665488d05854318aa013178830b6102e90f3b55e1d599b045ef0f394c5c1385946d40243edc4c5c9c1a0676c18f2ce83baa924fa990d8d241a29c38b66758ea56390a7a00f0620674f36fa7ce5825cd55120bde2bcd2205e5b8489fdb142c0f9a6ad476a507df588e1580554954e9b98c7f2086ed75e0513d55f69fb2a967db88b434e3489a3a314aa77790331a7cc9475fb8bf26ebb53590d146e05201ecc0893ba0f8dccdd232cfd5da1ddeb1d4b4d716e729394a3e1cd43dc09d73cbca4d4c7be2b650fd499af2a1db8ee28f20ab8fda1bdc1f9db157c04ca5c4c5ed16df7a188ea15e28fb3348b3ee01c24a8efcbce69d7e1a51c7a09acbac042fb8c2718f3eca673da1f4db30c50d606709688627d83f54d83a4c59257dfe4bda151fd9c0a8eea5b06e9bc0ad96a63462c67c25cff1193994bb8d2eb9e2faf78df9eb596772c1f8f7e1b25294423611e2dca93e09ce171d30108444c8479bc70bd233b6d3bc5f0c17e74d8f2de8faa6c0a40028950a02963e0a21299b4d46579b6b152503df1a761b92ac6c010f6526df14a6946ea654a6580c9cf066a0f64699cdfb976d1f27b3956d4cfc2c3b81b1e09db113b212e121738ef96250f389649e3109fcee3185d7a0584c019b8eaa5edc5e3829282e692b76e09156fd2a21171f5fe0855c9ace783f3d0ba570254e6238cb3e32dc771df09b73186dc60948d324a3c616c373b037c45027ec850b031e2b36982f6634dc6140e2812b734e39dd29dce7ee3f43dde2ec7872099a79c8d59b2b5b00b99984a79267ee8b0891aae83ba26a52f3e89385cb0fd1e25550b58395a6a95784f234d800eed076c1afef2343a8e09e9bba2e9e2f851388cfc324309d22719201b3b5506558a5de5447c4faf99568b7c0395ffed25fc13c8f1950eb3498ecf41cee84d395b25632f27bba7557c5c5553cd1167dd993884e55892f4929892ce94675282454454aa26dcb140d7c97dfb91d36896e2372132bbd5a1a54fc21e305e1998dc9a5347ddfc00f714f56d102830e89c6f57563c41c2d87b098c5bc9e2bb31be20825db07fef1d02fefc55309340de9aadf8c5242bbe0ce69acd05a7db8613c42bd23694551ee165c488807048029a00bd8a31a1886b56f7b7f6c70447714ba19f78854690803ef0b0287b1ade4416fc9c3252d1e2e3b78f28440d3b1d8329ab1bee18bcc854d25540e55226bbfdb01b9e4c5f1afe2b3391d74eca753540320ed2a2afc8aa8e37903aba43bb9e617add8ec815bdef3da64b1bb5fc78db9402e750855a2bf6005abebe2b7e376421a46743645c6c13f3efb20a240a9abcf4ea511fc6e55fed578520c53d7d4d02896c9356b22b2f13b6c7ce55484f0787f9e04be9780523c26269e7dc6023aaffe8b4e316d770893774b2bc7af31ef19f8418f193b6770a43acb66e442823d68020a8a217cfbd27396730499998c526ddc809379868a8fe1ac61899b2fab6763ecf86eed15b3b7051d44be963ed8d08b865bb60e65d46ebf477e4748d9ad74dfa36916a901a519ddff48c777a5ad4aac4d8da8ffc7744a86b97224770417559db226afc814cf6397f5d5f9cb91b54f1a86ebd930e3ef98fa7c86b088b1b78a837e768c2b3b005aee12702499f1a36610f5d370df19b144847c2f2a49dd56e2f4d67d87ee520cef31b8c2cc8bb310d8114de9e74694d7eda60558d7295a66fb92d799c79eef8ead8713c5f378b595236cbf3df84b3cd2abd3fe3cf46499ad4dabb4459a82d1f55e02ce5b8a9f09f066f155f5d257f36df5a37faa241a852af8c5759863e06975df92d383772c4313f7dba1aebc7b61d0ac9dca3d280c7b46c58d67a78d428c86fbcfac33229f0c8813698c510aece4361c31297430fddc13904402a64b56792976e9290223b8294628efec2726b5a344ca9f54aebf1a99c039c45c92368d4899372e5d838c9551102c752e2ef17732ee24a9f3211d261803d4b3776239dd02fc6ce72c1c2fb1fa7f2adb47f77a1ff645335d312215bdd3004707ca08325f7c0157a45bffc87923278130bc5d2ee80d22851a819a78bb75bb8a0258460795274d7760b0da487c831c6b4f270ab105cffdc27954706502249a1a9a8c9d60eb0d2d38266f324226a3babcbd9db4677700015aa715b9e2c32b2002cfc49941021ff806c789b8be1625a18c1ebc2dc82aca3f7bae753fe162e2f72907ec28f2ec1e9a397f5f2248eb6caa525eb19d5d82b6f084cc0437e01c7b89f1550444d6814f4358ebdbb8a0f78c45390da02d5b15aa39c9ee4cc88df648547abda32f9d1573f07cf9a7b9c544f1c880ea3f806af6e2a4d252fb96954cfde13cb4cedcd625015b20bdcf66edb4fc81d323411c35f161129fcb01b48510cfd7989af77d00832e036271cf21f1f7763db331c02324d7afb1895662864d2c535a12084b3c4246227a9c0761fac6bd74662dd6f6350b2f64413ba50497aa7c60c267017dfc17d01292422535ba037c8177836ac3f5aa50fa74d440272ba65d487688148288acb4453989d87e7b70e531b47f050d0714ea7c1a80747382c458c24fb5de6a2e6f5e6a8f8ef168f566e8e7f2b3fe34728a171cf90e8f409c0b8654158a39073fd1cbf5d248c9683d331e55a742f83210e953de4d9371f85d90e1f96c37b38ac41a5883ecbb797e915be73b03ad62ae651056f36fc5d418fc41326dce55f31de3cef29229d7e3a6c8b7775447dac94428b98fd64f497a2ef113d3c6ca352bc8ff716f33a6ff699bd23312e24925af778eb3175734d1b3af838c021aa84fb092eb51662886694333243e3447fd2b5c7a16bcfa75bdee9610c5e315ea92bc8661a5f924386457dd2c87e4401b4ca2d25926150019142dd403349ed8cde2e67783296b15cd2280d794862b262742cf9331dc6a145f5a0408afc5ce9ff2884327905739fdacd1a6af8f2331b5f2a69d1aea9a0f3bd7c2aecbdc2b810d18e8e6b7b20c6fccf9d1bffc0a6793d384251b54eae24f79d8233455a961f18a8ec4edcc3cf3d1b7f4b8e7efdc0699d5f4f46275253be7b59c88f71dc75a2aae9309b65007f2118d79052eb5764ed66c0c09f2cac697110d7bac6bb693974bb4538df8a50116990b08726436646d413af00cc6cf42d1c4d8058e15ae07e15fe8b7e0a88eafe42d2933195db421bfa59d8c9ca8ecf339c62411f4da5a2791c34f1762b5ee2bdf8c30fa1b0b39aa4a609c8da2f51d960232d7ff524aef96905155f000f8bc698a453e2707b9aff1e959709bfe044da5306efd94192b2c549b1123c6da643a635f5a1239a000035c14f759c658cb4bc7d01262dd1ed58a1acc3a4f2aeb1af7700f17b55c2c8fe85804ecaf358da1cbb2d1a0ba19b05a4d68c1566fe3a82d9404b995222d7338466e5bd4e1bc84606f68529da3f81af7134a540b289100ba2a4dfeffc36dc937ec1423d273eb58d29bf4535e7852164448f38285d46d68ddd28baf103d17f61c976bb163619cd8e476ceb41d83bfb3667d189b40fc6effb4377665e942262f996bba4954f70742902c6a40dcd24a33dfb1dc67a0b4a624491f099115ed3a5c3488926e4483b0a6ff53c51d8387d9f9f611898e5caabd037308d83099fa81071c7a7ac90987790f3b8a51335e2a10e8f4aae1921ec451b9d4e755f2b0093f759537f16bb025616fe2f88bd80b7d92b164f0dca1fba6b314e1f1a703d413247c0196c4ce6caf7b7392e1f96df44640c28c399f83aab9b49172b2d5d523080db369685e58350b01d7361242dc99d09e3f9c0661fa4ff524568a9603b5331c8cc803c6ebe5043b73caa208c886029ea6ea1a446399fa30eb61ec40d34a412e0c5dffa9bc40c9811b5b4a4a822be3b555dcd6f63a9b0469a64b639897dbc62c79f428c9cb9a7c5d47cb44eb89a3a55320b900818c91fdf7694b56da044588cd6fb01486741e371431eddc905f07da16ed6274c60ec9df0ebf398a35a64cf1bd6f7649485da1319284060d9fa4ef918bf561991af07d35d618fb007ddd224f6963f9aef91ac4484fb4ece5cf3e25353484a29f87c0f82682aaaf89e81822680993a19713da595f6d60bb7aadadaf446f128c14672d6c119bd1b45ac92eb1437ce7fa4445f37080a607034ea60a48b880e6ec05025fbe3426466bcb66f443c1208c5b448cf5a0cffbcbcddb9dea42e85b90d402402a16c613cbf109393c982fc3ca80b31568170c67625dd89bb14b8c386345256106edc4ebe8e0819685f110b2fff0de6cdb447386faec2a070902ba0397c4a73a0eef2c07d707756de56c917b209dde67c9bcebfc9805a1dcf0b3c0d8aea1c53c6a6f000d37247cc6e1a7912fc3160ea5afc4a0fc2c704773a37512d5d470fc29ef3db16de8d0a108c0dc9160c14fb7fb6030c0325d537014d481f08b8626d8f7521805fbe09b641bb182548e2e1ff863b61c6d72bd90958dc96bb662f841bc0204161ac2434bd1d2e03bfbdffe60740a4e12271920e04048ae4600645428d52fc351d3ef83e397e9a8eb80b9c0df5fb0e2551e1df6df9a935cd0a5d26710721d15cb4f99a2d5d6e4f47ce97742e420c217d19c1712e4077985f2d68dd28812817c848bbb2a16a5362ce6778c53e0cde0a7229e5b5484115613f7be61c2bdc0ecf8e938a303a64338a9cf8bcabcbf74d6ffadcb0de23c395c3e3a5bef494b780a572f4fecce9b4f9b36847ebf68b12bb45e92e50a40df0d5e2d49023dc01de1aac452626b515d3d7964c9349b782ba455bf4e235d760a249e536812c029ef57a68f04cc8f3749589cfca60c0c628fab0dc630eced8ed9cc6a9ec2b6d0a070be90f4e2d488df05613c39020d2bbf1a02acde9c074fe19b91b2ab951aec8767796b3973edcf0960a503169c41c26609c274a81a2eb6ffa835da8ae5400c5e7814d6809664e99c78509e885945b4e06b003a930fc5045b3613c34c51f1b659b10fdba536c57b473762a505ba0667b81f3cd0473685fbf278e63d2b1c213227a2ea763ca126c9c90bf48eadfa882a8ee2ee97897617030b4defe36cfb60107f39a1bb66a7cef1fab61076c8263ac2066a2772709927d39b4240f2a6948f665898912f6b615b13da160b1d733be0287556ed980a910aeeb62ad4bc16ee86108b7c96af5bbc150e7aff2673c52cb01d32f6b69cbb96b62abada48e542cf53074256d6a274089a80426878837a69e63497856781bcb3a915bdc718a23efeec0577c44db88754cf797f3bed34f07c8e65f334f3a718a8c9226d31900664315facf2473a5b34920c831ac5f97b88008cccecfc7086c5723ac742813c6e0f845508262131c45669b54e3d676113c77cfba42b92881dea52a624fc8becc39b07b39b62eb4cb01a87d50159bf600edb6b3c8772669064691664d052b19f98c075a6b74b46cca0515b10f5fe216f3dc651472402827e7609ff5b7936070ae89dee7bf563fa6bd68caeecc228ff5e0cf191a2d5525931430da8bcc44113fc808021bcf7e5b580a5814f52dacc5f0b5232ea424f2ad4e8705a563d7b1c141b659c0b61a2b420d5630280c10b02353e83ad87b64f4476eab625fc8de2d16f057ee481eb37b1fce1c9444b9d31c84175d2c408667d2d9fa88939a645e41c34026593fe41a655b5b822d2e035ce20684e96983a4de67afcf5139360e3c5d20bda0b799068b4eeade3589e18e99f4c7f875bb470a8dcd982b9540afd5c743774a272a044805d9c5aabf4da6b0402994b3bd5a2bf1b1a1f77a8ad42a611838f9abdc1f82e16b1d1a58cba79f3768fa2fe107f2ae776b2057090fbeb0362a6cf42174fd13ad7a4b5af5fa9ab54518f6a4615e754bdf5dc2351ebe823470d32db0fa0f6bb174bd045683682d72aee6a067e46205ce8f0964c9003b1f0286059976fe080fd63da556918c2fe79be5112cee308ac15b87c975c93b8677f2ee82e27339b6387955aa0994dfe8087b15830f7b6b6706a34de1f5cdecc1feb47e9becd146ca14a09d23c97e1749648415d57b9de25f0ca9d53fccc05bdd95aed58fb880127b37fcaa0ecf20c76dd01026e67e743a03a5df423b4d91a15ec8286f3bf4a8e587f10cbb416fce15446cdce2c23b73c888100fe607b4c2b48788fefb952a881d9d51318d1cee2bcc539001f668a0e798958d322d37408df893d27f98502b5a2edfc18998ca41c1f846e149b0a8a337257c4839bb2a96d012224c66e76c31890170dc8e1f969848ed5b0ca6f7e20f026d08ae1c646437023bd01593d044845727d2ea36263d6861cc211ba6f2388aa00cdd7369130220073b11f04d7ac54b8e97402bf89367091bd8fe7769618649eaff27d058b3541d4c6ce01dff2a053d882ad769c0d7a87855691776babcbd565356db5e573618c5a89ee7dbec00aef3f8bd3232f981108de2c43ee535eb92644b93cbb3fc4fb7b52588dd18a8b14c5bd8fd96cfdf3dcb16440ec14183a82936179cae2f82de131ee5b52e82f2406e1a06eb35ada1d8ffb76f6fe5dbedf5773255dd62f47d9701019f63d95a10018456c28c40e11917afcd96c87f65b9821e44d107a7af8888b1c087ff4ca0c8bc4fb04832307f7fea2549b1c7377c267b91dd3cc151a21daa1ebf055f49e8939a125763c706bede3de582d11481e9edd8245a9fb694aab5a468f32754d947e98a27e548f0fc9778bbe5f231fab5d9506b580e37824cba790377f47cffd0a02363be61f2c42d12580e3b9bd93061417ad95b88ca872dd34f82222fcfe1aca382b701cb25cff1e8a387d19933c8e9eefad5387c0af5649df224a52e7e7c702f5c2aa77c2f95b055bc8295422860efc56d733670f1f303834490b73f9394ec1332918aa6b5e701919f506b12e53a15ac9d3703c75e2a03c5e557efcb1b5bad82c36348237ab84552268a195a27c9173bccbc82c1cbe4d4ae3f8b575fc7dfc167514e6bcd5fd2710c90a406765ffeb8ca7332da3ff632a34edddaa33bb71836e6066e3347bce8223e557fafe5e3ec8d124bf9ba388983eb4185d518bb95c5b6e70064d4b430359c35b79ac6852db5fdc355433df6af02316c0919ae9efddc4a26730318ffdb58505144c08793a610da09352685843cd00bfb7d55fda1ca5e1df64df797f429f1007df02939592417d0b95fc382cf3283a8f7a30d9a2d28b86a16ff16990b3843de57d9a9a7d440398ad74f608dbf4191822f587e112572afc7f236fc13d926f501f56e5f2c7f2adadb1730c39d07b06c0e3436d8b9ca327db5300eaa590e587a1435d74c9337732151c001707584c551578e249835badecec956c70a3b792ae17cdff04e17d9bfaff1fa69830f248424fe16c18fd5c08fb088fba477d9de33e281a9054b73ef324832d51d8c5d7dfca9943b10bc32b3c76e8fb45da73f7074322c2e1629c9be130c2373975c533c7b134a55aad2375dc0a1ff0ab6314bd3276949ea81c9afc7d7dffd8b33e61f5651a9968dac550453397a6c7fcf01289133505fca28c9a1f0d282aa76a05329d6a64feb2b2286ee39f35f41f04bbd34fa692904a91099ac26d71e5b25905235c90f28c550d87f32800df767ef87d7eb550597928b84375ba68707e28e288276ff0a0058e5985548470af1fd8a93304d54d868e09c5dc7c3454609938c1ac0e8d180ebb65ed4aa5c58c4541019ccb9673f02e797a272e59c3ff111bcd65b60b015e408379e07d08f34f6bd295de2d6971af2266f348abc12dc70d1bc03755aae71cdbdca2b381a876dee89f826f6b2ffd9bef78e9ab415a494e577dbd361c643b0c5a593d99e7abf279c3db883ddbfccf2ecdcf3f9492294ba352dbc23168654601746e722a39089a2b4333194e59f5c72996ec46116b3a84f30d197acdcc84d7781f0db90c289161338e87fbcb793c76513b1fb8256389e2a0c8e787cf4886875ee021dbc62c4d8b6ea1b03de1183ac85b8a92a4836a75c383947780c5f9b9f20ad1599bd5e48a852aba485a29b1ef2a34f9ff5020d37418442322f4c6ea31e833843ebce11be09767e59c80dad002fea74051edd6dcc791b062a99cc6b73ef13dd5351d1423b6d9e005c17075cae6d02a6d5890f9674bc4ecee102c3ff2cd407ad766274e4c9e11939949a9eded6c790000d86ac00baa82d5224cebeeac9b77b22b4517351f68b831b1bfe59eac047f4bae1a0096ca20029b1bcceb49d3cb4f31a62415095d22c91f74d8b8d7744cf233f114f29c948cd234416a163a3942141c468df774322183935b7f499e7d5127afc886f718718b6f395b6980b569579fc015973b2115f1c5fc281f180df8daaa319a53b0b145c2860b52ad6b1a52d7a1f29d61a45d44bb20df62199bc0a51726743542258aa157df95be49b646bcbbadda941a7cc527064960ea0a52dabc323707f491acee884714594ad2b72a76d1a5d57aa6367ce19a691454ae696cf39117ce7c53269445e21e41967942f82cfe9905e43d01cf242812b820b13a86cbdbdd72c2c810cde9bdffd968cc61809ec891af862b9c877f8b33d913ef869b92333b8775def600400a1fabfa066f861817f7cd21973f3d356bcc9016bf71eb952267371f65a777204fbb9edb0e99c98a13474c4e6e18de4b394dccdc1e42238c8c66bd227020f61cc7c9f8bbbb3b35c7e2c9469122816dcf80684552fa6e931f47121ef45ef9152f65bde6069e169dc39fc7b3efd2e0ceab8e845543bd6a312809b7a191cab64889da5a52a9a2449357b52ea921b67f46a7955dba5a1d3b23efa6c8b20816b3f202f5d43e020e691dc2c11f6bc6f6663b9f971685e61641d18e2d022791aeaad5ae381b0d0991824df309cf7b1f6aac043b7f1122bbd26d12e4bff93165fee234a1812631bdc72327af9582c69947a91ce3034c4e181b5824fcac861235d8abe6aaaef10435d6e4233e67ee527c8920828c982276b8dd8149cdc5680b4f47249443d4bbb5f7522f06834f53c950f1b7066038a47e34c53980ab30c67c148b3e3526d70853e3073c05e5bcc56821699a5c9e21e0cf27efe41000652ec84ac5f28215321be7356d4fae674a789d57f7d5867da0a3ccaf7e11d1ef2058050bb5b267015136db82d1c4fae61f4cb187c5bdedf250dfe936a743e9fbc363f7bae72d14f52f3f5507bd9909d8309a846e352f6140ec7ceaec6073550e681151edc625dbd3cdb40ebd42db7e5c13cad1e5d2ce568422338731daf30d7a68ddd77cc2a34257952149905f5019b38949d6d3a8aff3c9b8be2eb76990e4002484e5337d63d662f060e68aeb1caa64dc04dfe5d17dd8d199010f697576f0d2dd3f1bc99588c8b14e7b8187e24dc0d78484da9a91b3832d8e49b3a231a2675c981b136f96346a63816f7093692d01ed9ae5b520dae5818793d4062d8144704f01c870f081af61801bd1cfbfc82635a15e5c2bcb38e8c20459e0d3294aab82012fcdf9411e2a8f00156dc12cec18f8b1761ba4f6f32af9b2417d1dec947f1ce5b5e19ff0bb98c98639ed4b9f0f7a7e5d3da86b4fb175ccadffb3e8dbdcc5d6a04cd1fee68ee14204e59055068203a6a61ec27b298292f989b2b0027c5937baa4eb7665c6b740005a87ffa5b4e1b32909ce34031d7b9cab9418d5061f05ba4d120abf39fdf6535eecddfb4b70ddebaf9b922d812dccf4fc309202f8d14dab04ece8511102c71a7746b58e1b5aeaf3a4b2c5552938264073902615708d11d6733b7343851767516b8a4ea17e4c5e6a54d555f1d7fbaa2ff461f7a46c4e50f0123ad769a59b45f7f9bde22a510e2ec00cdf597dab7c8d0f06a34e70e65d17db4936768f0c0e04d5bbdee17ccc0c7f4a1db4526c0e87b2f8131e5a6a8ddced6b2e584164fcae9e658e53559f3de70096c0cba813ad9dce9101506ea7e7ee6b0e46ee97bb51ea759a09d8e733a9bb7af95524c777c07a9a1112d46569f914e80ff6c24af752f85c7d345d056e1bf7ec6c278f9a9f5065d706c3a098ba6247f6b2778700bcc33dc93802b265af4464b0a6341976ea550ee4d580a33da208fff7e65e30c71b4342a06b0dc68cef6d0f9d9d874a9011ad9690b3ef1eaa1815528d3675b95b4d943d163711fe09fc2382e79f6eabe4e51cd14e2dc98579feb926fb202ae487a726e5d7f40b6280f5a18c86da58248e5465699e6dd9f9c7f75e028e7a10e8e45518df57dd549d2abe8926c390f37973c29e8e87b14b7e18349efd2979c7575284a5c95b5dfa3005ffc055e8000c1bcf95bc9be9f6e2c8fb9d53199f5a3298c3022992accc5371a1003e72113498fa2ce498493a2b1aa5b7a978b7de78dc56b68875b964bf9b773bcd37546ca11eb3d4b67edebaf6a719eaa673e870ff910c242c0b7b2bea315bb2f18073486affbd518b0d15d28e6ddfe62169897508d815092b0da13cf3a33178f36aad5a8735e8396709f2b0436895be24a2254d77a61bca4376a28c79383907662c5973ed431ca402854461b79d749be1bccbc2534ed0ca89b700fd9ef85580eac935b6320ffe63be96363fe34b97089d746ab480009a567a3b3dc74ccf335558a9ebca2cdcf207889fe0349037d4eef86786a4d80c496dc2ac32ca5b2326017a67b128b437aff178175208ce44596517e990ce2a477b21311d38eaf5e13354b56d9536ad142ac2ce93c23c524eecf6a3e43de856e8e163b88f6dee78eaf72faffb3282491f086c6c77b955598423e357af1f5aa8d51788f0b141209899af784a10d00d5c84e5377ba02efce022fda2db1bfc7ca3eba156f5c42632bdbf19d2a6fa6e7629c73ca662565eef957a72de2ca2362c32f69e5d1514a3155e6a750d7b2fbed85ffdb3a43d503fdb9326ab487678e4f12f82c204d5219de45d7b95a87e7d584c82f368d1268530c5c9ba12b6ddcb1dba1cc1f310c9b5b8e0e2bbaaf0b37333876ce9c6a12031007067d2aae456956da0d96b46a15da98ff86a8bfb54b48a3e48cc45ac1a4cf9a4d9f2fb195c7f8a82ec7176383941eafe43b0375bf397b8d728e3377c2d5fce235b19d80542a4ab7f4ce2e0cd736ea73c7706c2c305bddcbb4578284261261505db709177ae3204398e2960b856e2ded588506fb29b8be02641507593cd47140eab61259013af12852d504206eaf676be51184e1625e1fed37fc8c1455938b6bb8d0f74bd3569bafb1875c3f114624a0cba3c751f26042f95c0835a983460da00a165dc796a6ae6d02edea30747018000377c374542274f54efc5e2ff5137363e51bc957f8d706bd7f2b6015586ab69a90334e9bc93de4f788a5e00327cc6ab9d200e18d3da47f49e301bacf6cf7448b503fee5552c3edbee9782f3ac6c7fbc90226486926adc24e1fc175ea403c6930558696df0df0dc98e7df9a29f402048b196e8271af144e0c8b7279ea58b2067aaee26570f20a936046a56a35dd7c850d5bec11e81aa751d622f2898b69812013bb5b373b4c72b3a9bb9743fac875678eb5fd24e38fe85e27cd3012086517d78e4465fbd093f0f3e998d99ee8ce44be370c750f8777464d3be16cb8176528f7e85287e4d38a539084042e9b20deb7771208ea8b276c535ce92455f1fc8ecdacdf89eedf8279beef62a039b8242da9e310f5cc2fca4043f9264b7bb3bb9e66a38445fcf6f676983d001650705cab22a466d13fb3b0c77d8c4dd04606dceeb71019f7936a7415975a630bc66a5312f3a74a2f311ca5d67b5e6795d948711ed574d5b61cc334c6fd8e8f9dd0fc59e6c1dd90f9e4d0cfd24eb245375154d3ea573bd9e8ba679e13270361e205336ec2e92d8f5205c48bbb47ffede02ae62d6ab7a8c9de1df97b3aa3d9149fb3950e7d15d1ba4604e64648dbefdad340c19670460279b1d5496d38db852c6f517af67e1fce101f9007ee31749f308a76db74ea56c5882eb468ff72e5df47030a1d8aa4497c61580694cf5a3a003ac4617de42adfe371423702a739da0f89287b52a1f23d957f22535de04c5c785ccc4b7a209cea76b518a2f3455ab549ee5fb7c4746213f1c05b33ab0d84f125cfcf1a4b3cdc8106b56417f699857b095dc539aed8f81a72a6835dd48b8f5b96d751a84a9a7080569e3d33b11d0854a6a85f42e66510c051e6d43cfdd65b7eb0d21edb1af7341c7f1980f47426c67b18ccef146098dcc101f98306b6c0578da00f634b1893876b7215e26193c5cb046bc53e7639b78a12b7c681170f2ef500af194e3669b4cac9fb842b83b371a5d83373fea3b36a40c19fdf3a059f000eaa118b0f424eac8b0e2512a17d068b41e7edcf21d763b312c69daa2e6e43d761ed04cb80061817dcc7d72011640ff560cbf502669de0fc30b6e5b5798bdb8756ed2f890861227b2ebaa3d34f03fcb36595fe4db53aa2af8385999c26cfdd44db0ba5fa74a09dbf3c0bc7d1401628c3bddf7e0428028bc50ed5692acb63d57722f307a25a3aaa06978c746178e05c4b4826cbb6440865e57db26cfa161a6b8e8ac791fc28f7dd38d6b9eb5eeeda79856bab90b069fff64ba51a5e5b2b4aec32b7db6d7d755ad8ea2b60264df1306b46132b9e42ae2678f9161966aab4f1fd1b652d6abad01eae829e4ab1748913029ff281d6fff03943db58a40de65bc0b285e6ff94c061f07eb247a7ecdaa35955ea7542c84369399d3a8cbfe6015d0697fbfff968e26437d11ad5f8465b5c580e945b71915d8dcbede131e5e019cd8ce4f895c690fb4be018320a1299906b54bbb8f8072f4010429a4e56e8c26f9a533e167dec3beb33e84c4cad30668bbbe5960f908f7f92f1a41c2139be377063976ea9c4577e8602bac313d79a9938170641d4f5a396b29d4bdb952149e10ec5a2a76d08f3e2e3750f5c6fc3672ecc9b2cd4c18e5be4438cc82b01367adcb329fb6b08e2e506e9a1dfb84e55555c1c919e503791fdfeefa356be6f30c43bfbf3723bab263daa54ebf65fba38ffc0d615695e8d726300f2c2d23a092062fb6f2bf7b8f72f683c359632a9ff5f9eb6451a5e9854ea00e4be659a4422b8dfff11bcbb3199f9d57f174fa7da6c4ad1b326bc22cc53cdc0c549152bf3944228edeb3179da2006f9dc99c16ed7e66b01af898fcee01d050f805c54b2e33d4349d1be8514ec287d77f31bc5f90d4cf3cd29d8a9f40ca41e89cf2a5c5a92f539c01ccd7f1cc2645db8c52cd120c578f763e1cb7daa183d93c92619d7ee080c4df48c2f7cdd7afbe5df1e65240d1ad0bb381a866564fefa44a30139dd37893012f757bd9b7cb3546ba3bfded8c482d986c42c6673949275b13e74c54d6a8735435a7f53f9d29d29c4a346bcb8b6b274c6f469e988b63a6bee91382071a8be5edd0490aee728de4eeaf8d3c7a4d8a31a1895297c582be224cf4a01e905f23656bd97a7c40c49a7a9799e353429759ae3c0db2633697a0d4ad85210d81e940e0adc3e53089b55f59f310b33235c12badc432ecdc2c96eff83fae5720a983bfb33e9f53069b6751255bd63cf27d75da6deaf171f5887f45101dd29cd91796f0a12d11310f1d6dd332bba32a24295a4ae61ff3487fb49fd8534213455cd99d0298f9a2f93b9a022fb7740cd4328078caee17876bfad9c49f21925b6a3a0d2e78c6d51fccabd856716354b70ed6ca95ca763815efeb0071ed5586702212c33e9216bc766000d43361d945026ad9bb9e17d0a6ee7644afa4c87961028b4ec28936b56d18b83a3eb9492a0b0ff18fa80fcc1e573b2a3b6fc49c9a71cbbbcc906208520340e93f6d936f40afca92d19b992fdbee9715447b308e460a5849896499664fcf42ebde2bf5e0e9e57fdd27e911ee3e2a0450bac41602bbc688e94bbe83d964619d5d2a32a3aae92e7a9e4dc49d19e9512b0f2c6a10c383cb41ae5ae7b87c1db4130b55a8fdad9d8d84177bae0fb680dec3132d5c69c52326cd40008f833db3970f1851ebb0e1e1fe12eec8f922ed8c36d7639c344d18e3ac2fb0328979852f8803a105add4f5dc1a95b80743dcb46cbe25bb816cda6bdb13ed651e7048fc6b2cabb6dfe586cdd4ab207b547987120dbe395ee694a35359dfa594eeb8b9a0037454a351ba98325d4ff399fbc62b09b48ac9338e424d62e2481b00da5a694a62009485734a6b34069e55c2a065940155e205b168aa95e2591648dea3bda967c3eed7a74970cea46cebafa3d81a809b922d88379a8c3bac0d4cb8e41ab820aead90ca2db8405a2ddf5c3a5438adde640ce9580ab4db3e1382f05776e27911488db7fd5e7babd5e60c71c30c10f289dfba87cc586c8b7a99249ad0b32a7ae232aeebe3cda5e4097fb27792c5efad6c5c058db45cd3dbaf4c758e8a6c6a3558e4964fffcb660f1c9194881b54a614d4cb77154190e2b432fabcb9a40deb8441d4f1e93378565d99e833dd4d89de09d9cf07ec3e6dd38efb9fb5c541ec4a61594db74754cd97936f5713a2baffe450ceba47aafcea919bd2eb4767c151c7e73cae5db2e25bb144c5f156f8d622e3d509dd04c859c6053f7626e7276607253093c034cd2932b38521eb46a6d91a10c412a90aa2b605b2ab53c161a94f9e4e3699312e03335a9977b7a602e0520a76ed96f6da57a364e8d87c535ead081819c84cfab65fe67d88283e6bcee0652dd938d773392aa59e4ac5d14260c2701e06a0d96bdd6a26a4cdb57f86608c60167385deb6b3e9775e8f12908f7c19d17ac91dd6e0352f3e86eb78aacf3e38af78974b0f89aeb905b3f9dd74f0b27eb05562534746cce8d97303173506723a7c8a64a71a6caf31b6311a67353273a8e343bae10237cf4a0112beaedf3a08d4cc4b5661446c28cea906578cdb19b1a447982c5e43987187a59d99b375dd82daf07099d306c3dcdaa3fc96201d08372f9e66732e063186e85c709fc4491c08afc27983c165b4fb28f9465693a98ff3213732aba6a3b9bf392d8a1c6d8a8ddb86ac349a933d30ea4290c257bb323007455af7ace8fba9f308a4ab1e861a79af5017976e9f77a18e77dcd634fa98fb1adb3da60fdd049850e257c5ce03e3e5d4f75e982bcb1671fd38c6d3511f89aeea40520491e126750764f1305df342f974cbf2a0a5baead2aa09b18e062fc6a12bdf49824e1622b3e933c6b77fa0f74cac5c12de88fd7c2646b174cd7dc7c9c2bda1b9086ffd9b134caf0eecb92c7f4b16a2b6c56cb9221cfe7c9313e9be61a6864e997185b6ce4285d6156d22646c148f53c0bd898bf016ccab1409cab3a6104f285475c53fb0dec5a707d51b2dedd58efb0446f6939686a9616405f3f7fc883fc4752ca43233ecb2d034141df0d896910ceffce26e7cfa922f80f767c73e29defd3856ad3a586098374306b7c87883dc360ddedf3ba401515241909098aec77d9154d7a65426e942a93e9ed0f15d989b1039ec443cba3aaad31cc0c3beeaf61045cecaa614dc11e37351fc1e0504bde25cbe409fc536980f43ba339f888a73d1c04476f4c032107a2170a2c7b8843c78d671a45f7c20f1f8e7933d7fc3f21cffbbb753ec811422c238f79c4c7c4437d916d6f81af91a1709256e1581634e6aea8eb9008a22ad67d7901941f3ab57e917203975fbf9e6cfd9b62b450ea5288b82eea4ba914580cafb80ac650c41c5d77d7810631c2649850e09e558caba3f64aa0e127959e6533ef","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"e75fb835e4970f721d21ca36ed2a5467"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
