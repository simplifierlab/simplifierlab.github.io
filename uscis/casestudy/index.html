<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

       <style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"56a6def471a2a2e6ff3bb3eb9c4c1157208d7ff7cde3ec9ad81ae3735e642eb35df8d06f04db60cf59db5582768aa56c649daffffb04e4af5b19b950d281278956ca238e6a663ca55f4ce3a36c64232828fe7be2302f7eb4e7678dbebec0971265e86979b85439b9a05fd14fefd17a84eb240178049f20a59853be91675cfa1465642bd5f1e3dfda1736ee3ce1fffaea675393f89708418db57e8ea840bdaa2bd1316aed143d312e1a95aadc20afe80ce13774d207f8c1b630333766e943accf74272360071df920ea42310372caceaa52cc40b938740b00f14b54fd97e76ba5b12d1d78c6d1d0f38eaa8ad320a00073b5c91087c06479f5f24910922896b4e6d0cac0beb93b85e77f2518fa67bb3ec8f9fc45e106363baf2951a8645164e9ec32b869830749bf3df8119bcd5921aad7f72bbc4c3e740ec232c8af15c1e933cba93f1e31dbfffc0a98718f31daee2bcc61c905ef8dd9295b0b4744c5ab5e070ca4776fb1820ecb9e2b5ab7bcfe215d2235cb8ca28cf890802c1edaf60ecb624997f6f0c0e898bcbb31b5b45eaf8a66e5add63124caa53a750187590691f0f0f64d4e177ccf1e86137bba86c4ae88dc67d418fabea7585b84bdfafa2e0f798003f8580ee3497fc3f5bb603599ed6e5a2b9a9f9c6567906b4003b7877923a14cc75c6ed9e22ce85e305773aa25193d3f2c6fd4c121109de475bca4ca31885f1f75c7154d5f9a3e2d9402bb4b26add821f8925b91ebceb42846832e06331e14e0f92b0df6a31f6f6cae27563715b23dd58390c5a2b471c381245e8d7c58f9930d1cb7447fb0fda654124b9f440950a202d69a1214918b69083744dba7338e3ac0fe96e096ae7b221d1849f0dc0a3c82a3446e5fdf646a9660d31086bb9ffd7094896460b9e274d12262358190279ac0e822de04909b5feed00dcd7d260b599e6e1dacb160a9bf5ed02a96df278ea9b08d75eb06b80c494a9bea8253c0fe205e42c7c1cdd71614ee4a578131a69efad46be2afc1b4c3af9b0670b3b37183232ff813e14bf5403711b21d057f05d78dd6058fe2f3e9e87f50bac49da87c6e5533686eac4cfd8bc93b5335cbc699af467f705e919b7bbbc534ffc9ffed5b2c1ab489994468b25517fb8c28603fbf8dfe4335415502bd8c09383cebbe9ef7dc92100a25ce54e9c33c37c5f3c41eaf62fb7bc825d400613e74dddc812b4266c7894c7dad674ce0f11c0b81ff67450766a830b2a58fde36ee337c2fbbd687240ecbfc500cd34f1b0a0bb7cc98ac52b3e681d732e716c7804d70fe9c87c95ce99706e930c512d82971d66d68a137d4048ed1e156b58555d75a9a3e061655ee0b7da1dd4146cae24f5f9f7455d827bd15d9054d7335019173a238db78a95ac8bf6d36f15d8ca0aa6453c227dc648444776d7aa1fc76b5699cef40093e338a3ab2ff0deecc47a88953b95217766cf5a6f6144f3bb7c8367df1a18eb11e6af85784c080d7c0e3c3e601ca646538183ef28ea6de1f574396d1de31b3eff649378581725729b18c1f048d6492a34b7d19bca1a4b0b71b67bb779058ec7234e23d547cb54650bd1b85eb74df6dc0f4b6e7ce3d30829083cf21dc5b6b3907cf06b111a2225daa5da7f79a5dc384f8479a8fb9f077704c587e56c078b1cd1ce424029ec4f51c610bfd11bafd495b3eb72a019ada381eb3f97bdc02c5cd76ee9d55366a122fabe9ab9f5e88a8c527d1e410d250ebbf4c561ad6a8dc77e7fa9f6b50682922ed7b997bc734358166b6d00834f3b65259c04462c699c38a6c59f7e069335256a79da168fadd71ce6aa7a78413d85d0cf1f930a598facd0aa0c39de7bd6e5eccebeab3454a7dcbb8ea779661b8f9d610d18865f4ac145aab147c19113aef4cd6a5c4ef370f7a7801b497d8cbf360c046f50221f9f8b2bd9d9db10052369363523cdce088e45be72e1f0bf1b9ede2e0cac6feaecc81f2241a30d402cddc7392c16e025ebd224a9b6c752bad3e951a6755c5d0fa7b573470667527c1260e15a06936dbe2dd0ddeed394a2971589bd409d6dd9122f129aba0a5d24883f1fd1f43bbe722e6062c592b0ce314a2a27705f2225b69b86e86466b8dc7dec78390cfe8a48ec45c77e37d23e6c42d2c5d9d85f201636a903c968259cee08cfb7abf7b5fcd21de1c1d4f7e33455e47b9bee76e07c81eb0c818fde5ff082ac576c6279aa34b1ab3569de9040900bfce17f36530ec2196555d05ea8a42d1a9459e20006b1dafbe0cfdf0c9dc45fd0fdf3e7049afb13b3bda1436126eaf80cb283a86766fafe87142ffa3608661cb84d13f2bf7354b86f7c3b5a7add19b31a47220754871763cdcaeb5c912b20e19a08c263958099507784712cf4b5d67e5fcb6b48d2cdbf7e64eb74f123b49b9066932e5ef6c061c6f3fbfa6ed7bf87d484ffc71058f3eed4f0149ee9ec57f36285d350c4ede7a3021df00b72c1753677ba1c0e6771a17683285900eb62cfd79592802c0c6cc511b942ee4cb5a5b4ce27c1118c1c492a167dea1096cf220036be144e4100afcbb5fae6b6c6034c40ace28616f86658931d6d13fb021eca5ef0a275e7a17d26b38a8c0d2301c1b3c5f79830ba7c1e8b242d2ce4a4e732bc13b88b99b5360f24d8e046305eb2e2d076cb92cfc6950de89caa5f7612d9a659a0ec9e14643e9496a68ef7e539fe0d30ee97f8dc91f7e5c9683b3ae91f499a616ed304950d663bca6d132b2f42023cf736c6182a4d41579306311694c424d8c18d519793e292e1fb22de509a97a5ed153060e1543a0a225f71d6af871d2be997d8d5dccc5d4c01297e42bd9cb18933e0b9dd7877dc0a83b974a0fb7f79b62506733ea5470743b50ab3488f220bd60b371f3791ef918670ef1d42417186ecf2a31f16e312ab67318ab1ed5362ebc1d98203904d2d9416b792fd2a82eabea05f5a7f69dfb3fb2acdacc7d65cee835f7a3da74a74fe485e71550f3fe927d133e710f755fad92df8b8749a7626351a2aaf6b8222dbd00a753ec60a13be587db7e683ffc00f4a17d2274f825933c3b027a6d4e3e6dee059422732f6182711da11927d7e7fdc4e1e74745268b4ff1a2d87e44d6da5d161ec7d2e582154b5b4e52c53c09edb575ec5e3fee75d59243a87f29baa4eaa26673e9927648a1f4584087f2b17ab47a74360e67baf7019bc119dfa0fa97aa3d77326a49bfad4f82c3aa173b444df9360e6dcf0577f2ee52a6cfffd5a6d6ca0c8e6936f95531f460b34dcbe6ac63b754da546716cfb60577c9aea8fe30dd067205c3be457b0253ac80f79c0d8113415ae16a6094f1f1452ab32dbb21ac7a720679167d82dc6045d1d2e790114bdb32d2a0dcf2a5203d611ef8b69f0d9edf3b57edeca35b809ee51d4ea3fd5bc7d5754c90514efcef15879e13e40196a42cccf3601b0ffa9abb92476e46992da427e0cccf364c8002b3c9399c0b2e6c9bfcb18673f296463e07dc56eaff990d584e5bcae4308d0b55a8dd0c4b37f23bcd6e37ec981930c6c78de5b3eb907f5e5d3c6344c6adc1eb7814d9ae67edce43f7fe33de95b3ba45202ad1fce790555fde6b15dc4c3293a64e084c193ec553d52e1d3ffc3ec6077d6db50880f9c2e14926b25f5a9fd05b3470e0e0f33bf3167f5403c0e881fe4c9cbaef63abad00eb6590ed0978d9c056aaf2a65e916d9068c1067730ddf0b17cc32171abb4d94c37df2936e5edd1795fbc17c79e36b430512f21c9e4db32dce508309ed21358640020f7012d72d31675f9df953dc9137fb1ffce703414acb122ef6b639959cb2d86c720e815afda290742581cd2c7356f3dfa632008c1f5ee7f0183cc5a30ae256f675ac67397d4dfeb9b5ac786183d015c628f3c7c0c9206b8e691d4b627382ec68f9aad8b6ccc409fa47eb9e390e789abb71f5ed40304d629028a83f59b487abb0b5aa21f701028bc44d53a445cac2a1d5bc4ba81f039d9bd37d64e9906eaa398c54bc7464a42e1699bcaab7b9feff5868de360daab1bb303f6ddd211fa9ca9dc7b6719ddbe2227f29cff952f756db69f3917db9d8eaeed2030c8af768958d87e9c21ddc768ad26ba46b533156e8834cfff3bf9fadda6c2799e62700ce1fdc684bc099dd4f8ae4d4381840418369f2b9c7c05c9a2e340bcb0bad028bab854a53e3c9db75bf7ce2dda23847c7b9f081f8a06a2c80123825844ab079793ffaae5c44a208c62aed594397d22ae13c55be29761f0b0f78065fb32b27ac0eb7b3fbad513ac225423fa5267c62e414336fdf4131e71c438d01a390040c3fed097e0f6ec29b9938bce1fe58511d3367130ac4573e0f61c142fafc6ff31be952e322514e0cffd258e5c075918b21161396ef455f8e8cdf938cf8276077f7ed06d68f912bc593fd234703b53cb7b38b1090754f2b0aaf059e84317ef9e1ec9cfc7b22aae7bd8c011ec5a193c23d15a4041f8db3ec1e0cf80afab848585360f006d0913b7f0bc29fe237acc353ecbfaa69a36f750bfde24f1576c45887d8c76ec4b2686ee91f30d7c8df69a2078e1793451d8f7eea5b7924e28a3bdb153741e1d9539f9e8ea21c9a91d84997157f9ff09372b3fe07d15a3789fb7a6e8008d15807b7ae1fdcdc83487b7a8e39a61ad53fb0f81c038cb49970e34b04e2837b7ebec969c00da70bbfdcc21852e5228d3ee06140472451dc0acbffc75a32f910996e23ad0f3486cfc2bcadfac97b091c6353cb5ae14f36c77c8f647d70802b5f309c46bb388f360e60e40c78d06d9be2194b36cc7877892de0ea3f568088a497452fb7dfe6ce7da7e7fa59bca825396e7e3ecf3bb8fa9b5e1c1ccfdba3d0d742c86c0da7efc2c60aaabbaa2256d88ea1dfe95d082f1350eb2065ca7872c6a2c0e47f543597de6f384c950d90d4555aac421b032bd356ce780abb4662c0493f431336cca5c096d28d81c52e64bac57e4c253264c2277388dc573045f78d0ca0d2716c51f30099a301e8019d78c70c6671f1349bc4475450e64bff691a91770dcf2d0ad5950e8d408503c35323cf098f094f9b3df182c1db0223b4b98269242c400f1253f5f29771079b4cd36d61777a5470958146af7c03e3abed414340369279c1fb83db2488cc1abbffe63a959d6ea6150fda4536c02368855b97a1cbffa5dbe9d1bcf3d961d512bee3241a06ceb85bb2e80012757188702d290721b6e3935119f171029acf9bd763060c14904d76bb143444522ea51bdf4d38448fc220e3db5770593a68e1452139ab58a30e4a03b3e728459873d42533af5359dfd38869e29ab927fb0e1b605b6b1a2ac48090356f4519193af1b955bffa0943a7dae9ceac4041626e2fa3f28d86237ff3566665e5f0601debde95b44778d2b7b94bfae73483888bd5c8f9d6c41ae616031357e09b497b95e660c62450bedb26563d288ad1130ac44cb23ea9fee98b73b32433e0ff4dd0ea6c64fb7f5378bf5466a961e915b09c933fe86c3c649585194bedf13363962b5ab99c34afe86d6d192302b103e5e7aaa35e769e0373904f6daadc59a5d259c7dd8586701b00dba198479acab17715cf51538f65f9d04f05d77993f49fe488a00fe3d936efca68f38a1f9b62909f1f25a68e849eb150801ea3a77ccd0d23afee51dd00890bd813f9773dc062ecf7cedef029609991728f2d440fa127f2abf7a9f1ad1345f2958b2a193c39812984f8f465279d3201c9fccc4bff1d30035a8231bbc44515de2f9b9c4edac7e863aa6727cfe7a633eb6cea78101b1ba657ce3cc90d31ce8cbad5eb64e1bb04512401b4b77620b0c9f10490cd6a78e0a5026728ea6587221b4d573798f9cf814fa4f01d7e597a574376608d5fabec856ba968b2e6b0badaf743dace40fe3747610982eba51a9300eda012f25bd28139596bddc03a22a22ec4a42ce99959a20a171fc7e4b4623c93fa62d45d2b53699331c7d6733b432e1a3d0485e7dd2de6e5a45a01eeacecd1c6249ad28522ea6eab2e929fb5c850d8411dfd3e01ef46d74feb7d20cea9f97b9958396407d7ac068add60e602447c371c9cdd5cab8fc0edf0f88896e4c437e429eb71c3ca48178a274356102c5ec811dbcb0bc6107253f7cadddab7e9e016f17f53a76229ea2fbdf4aeb1f5278d4d5fdb121b4580dd817c94a6f37c6ed82bd192d1d17b04359eee392d2471d41e37e0d6387a20b7ed947c47b1eab88f90a17fa6bddc23fcbc59284649cf121f2a1465ddaa8e96a9bfd2c27e54f64d48ea8d9038b0badd761d4be55f3414e4a2a14d8534a0c43930faabe2e9ed7d6f45c07f77c515f10b464eca235a35fc65b293d70b894fb15bb3e4d99b98ff751c4b3890bbc21405234732d3e30837818322d2eaee20f478d50ba4e9ed5dd9d8b5c12353a16556d1a5122d3dae12c8655f6742f4b7492b066c93e59ba5180cb6cf2a7e678a66c661e22a29a09ad5298cc0dd757d08fff1b13230dbe0294c24719d0f0181086ef24280a5b5884697f9cc9a9cb729cd2199e1fabfd1976400660e05ba9ea260b446a02ad3fad57757661554316b598ebd0370069903274a0c72bf31e06903b5925015f2d7dae638e9051a7e0fc38a194f9256a7f7a83fa76234b986dd8d2f80ecd6e6edca73eae0735edb083de4ee3d4560c8b64185fa054ddc49060efe6511959137240383327ed6f39a7f5928b97163aa21ec053b06c86c7152fe21b2f183a429db876d1bb5e41657ca252db187ba6176cca1fd5cfcf45a37476b8f1f7c15e21efd613cc3d72b1d957426a5e29d8082ede8482e4899f2a62f74e394a83d9cebc50197fa308610ce894a248917cb1db52e156e1decf17823a6d5337733e8e5654de88d157504c81b4f631b0c0214ae84bbffe22dfb21fe185d7d3e49d215ecfb064700623c54e3105251eb7d6e2677c169e20b0ef28f0335221b0ff4a82eeff610febdc232794a2f5dee9a4a90d0838aa55d8e2cf2522370faa915095431b216bf31bf3b9b8a540b5ffe947f04575886017dd357b99e47e6183239a378680290ce5fb52cc088e65996fafbf6b75053b1652b2e67ae37170114b15c2c3f6623c8c8329a098065c6b361f40631433a99bdbbff9e02ad266953cf939b4a8873026e7c7e06e7f0c99c1b96210a86ca8562478fd219c8e69381ad78411292a100240a37f3e7f84416e705abffeae349f12527710f3f7fac676c3e00716fcf78f4db7eb8e3c6ab1d8e3182da287c1f8125d7dcbdc47bdac1862fac5ad607c2d8e566ce386640a64dda03652260ff205c68f6e596dd1125c654737ca4dfe6c60e49a20a855e90bd429b2d134b65399402257e78657a675122755366afc421553c40f6328f93d92339b0e891f5f5f81edc49d53432ffc106fed99ae3f1fcd6e824614e7cfe2d319c08f1933544b787d40fdeb09077bc6f0a7286d7dc5e8bf653e4f85c86a7c8b784b4d0989134f36be8201e9632da5689e4ede9ff8ff8dbf51c716dbfce7d35f069702555be4c8510b02a5d839b0bcd69ed586c215c306400761c30449adda8e7c58a0838838a7cda2e8bea2cd771be51ce09488e485bd7590cd549ec60ccde91afa4ff7c006c101f6e366c9f10cfcc5322e14bb2b1e3ef1fecbf70435e62952ca768c57cb16c8b2ee607a5a5d010807473891a02508cdc9186ea479971c2a9d658210f75e671e7aafebca691e4def2bdbee5936b2ebf0cf35b60ac31a36560a31a8ae6dfd4218e84e114f14979aad1dc72a7e8171b9802acc798547db68b61327280ef61baf7a86e6f425f8d589e4dfb99137825378fcb53da382f10f97d9356b6a3fdb3d210df843de3cb0067d3aef610fe2a4ae89deca9f5666db08fdbcc21fe2915af31082607f310be750adaebcf00189116af3fe42e7b9217fcc1b26a3a845eba1ef30e86c5c4e644e9e2030b248610b199607dde64cfc656d16e55292ec6196c8f8cd343483ab10cfe401f2d749399d7bd2779ed7d0c528cc321a9bfb90250a445788ad28e9779da89788c679050db56fa7e5329555a81f30fbe0de2410468c98f30332c1a0a514f38092732c82ec464aac1d892c48fc3c15c8132f2950978a0ee0ecdaa648b38c7d0020be5da0559d41016ad561cb145cf68cdb3721426d4267fc3d765e449b15d76bc879acd4adc68aa2ef38b54f2350a24dd4f8f74b3a10d0c87ebeb668e14e5940fb934dfcec45fe33ec5aca33edbc9fabaf249014c32f5816767938f693e9945d9ed956939190c082ec9037f16d7358e427f594dcb6e12141616fbd5194b50ba00ee0bb070b4dae17ee076a4bf79f8cd8ded32b33ed94ba08187c17b79449b173d680bdbb38b96fb71b958f84c954667e4952053ede0c5dc0e261b86af057e14b8e43c60811fc35c4bdafbbbeabfac10eadfbbc02f8aaeac19b941677e81cd552862bc1f5e82a5f0f3a33116180aaf121a71758c9724e4076412de67391424c796bd7f2b26cc323f3047bd75f9744ad49b51842d4d5bea03ccb296e11d4baeb5e449b7f94eb8fd2f840b6167f43297bd2042cb49e81551517f6d42abb1794224da82e3b086b0e7ea8e4d3431b5695b59deb58fb6a595ca644ba1f4f52e4913c518ff75af5a648bfe43038968af1c0c3c03972b253a324333215972bd12ef20f2210451bd337da665e30340394f04548d73fa9d68869c5a10512958aeebf356561edaee1e3c2998292c6241a22149ae3f07723611550b65b15b2099cc0092237887dfbb4c86ad7e058065551f47f780eae343696dd8ec373805c6ecf47978890003d21b6eac1b575c9a26330f5921e0751bb8b3d5e21e80b620bb6b8f9b2d9486b0fc22605221baccdb8cca4687a646e28877da9960768a92087631ead2485223a044f67c3dcc1a313515b148a172c859b31ce9816a1d8bee2edcf258e5e08deb75969bd46958b8d027312b79d3dc7f5083aa293b838d182a4958926dfc7061e293b00b945a15acc3c49f4eed869568e62d1c4d8654b2d53452b3b92a292cfb75cd0050c88780397baeb57ad95adefc7e5a15e5750be4f9662d89c4f47f84b17bd03e35a93eae32f4ed6526beee6f296324dde66ccf54bafd89cac634d3f6b5fe9858595dd67df469650b2aa5c0029c5753c0f2aeccc1a44aa2f968cf0d641014710e7a89f77d1ce8cc70f14c6009e0a0fa19fc0d5789bc1615c663c062ed3e887213f5255e9e71a6629b8a88bf39e9b8e7cb31aa6059987d3176f1e841b5068a9ea7ddbe5a1ee15a487fba809d52a68c7337e3bf4fe57caa2a012463b6a3083e1ebc712ebca7a1511d58e5a20fb75235207ad9e2622061944d428fd8af7c2b02b29fc5817a1bf29505a3c2d8b4bc1339ff158ba38d07eca180c7373e45816f2f058783054580997ad28c1705799a7bc02a49187e38f854e9c3e040f49fca74e12e2b0795d41b1ca61852c9167d17b901649c5dae42aee581a3c4e019c1e62640e01fc439c7c50148bc3a5d8666ad93252c9d532a6f4ca07dc3f6357d2476ffb1feb0a2d0f45283fd10d913bea0ac99eaa9fc8d2a51875bb2a5007e23876cb1a04115e0cd07a214bc979f30dbf7bf5f78ee35e9894e171b296489c4417ae08e69d9294fd3a4a962122a0fbc3de7436d54d339bcbb03ee1f2b2451309394c05476b3a642bb1e45a45db82054742eb4c2ab06501568761612008f0589be1f1355b76cc2f0f53c850cb1dc495f071a5c6db96e4b9a65fcb9479e5b91fac41bf845a2ee86377f365465d286e2080e2c1bb109f405b83a410d20a7b05fb69442df76cc9c116c31740a842c3e9160939b257d2c72cb02a78359fdb893b1f01df5b238a23bf2823f574a4b62b2d5b2671a65f4538682012326b3d695a761ccc15bc22dbcdd4efa50ff5ca1dcca948d4cfb0fca2e86c1ac0de522c8b5b5103444768524f369c4434228aa1bf0147940b9555ab3e0db6f513a9ff45c3afa747f918aacbc848a351523ce90c552ceb1f34b7735f4733815d7c6dfb17b641b912d865ed415b73d244a9480bc1173efa261893a850fcabe754491589eac8abf3e96d2d9f83d535dcd56856a70ebf47767755ac3770860b0784b1b7e4c069f769dd6e3e6943219edeb118328909a4b37d0cf58d6eba49ca0a4c01c00ebc15df42f547a36fcd2557995e8320812adfb2fa7d82c2e27081a68b1762be15e3fdd68aaa092cdab20cad7ac9296d02b5cfd7790629e335a2b8988a8b362f512b623e8486b0da19c76d3606b691c9fad50248de65295d02008ae616f8a8ea4b1ab24c93a7287c14076d2ac0e90c14bf0140fbd441c01432fb4b4b08229332324743d29f690b14fb7a0d7c1bcc8ea3a51157ef40b5a28a3b7e390d7e1c78b88d8846b3c3c1bc4f6f4db90e458b9530b28c504a71188f765b073b297037105f62b42e1a0f48503d581b02313c59a965105bb825dad556006990a706275ac1174b6c2ccd83b99f71c207d2d93a77b781322eed59745fd71a6f74b9cf3f990947e6428e562a9694f3c734bfd59cb24b2e99284375924262dcf3d8ae50ee6f2ccfebc4685357b9c009f2c4c5bb11cb95a5a6040e28e1ca073807a27e9b7d3f30002f1d158829148b7a347dd5177dedd24b08ed152e6aec72fec9211a9b59626b3f7c635147d69382c7ef3d6d80c97f093d5c3d77b18771841c7881650c991fc4e78bdbf911863e5ff3289092d3bea0f017efc248de6248c9cf09a3db76c89d377305abd924df93006037415352ae80696882e7da4ad78cf373f895609b9eec7d9a3925ea83a48fd571c95fee981042bf0cc1216d545782b6c45c71d5d83b245b371c4df9eb92469ce87a27b1de2d0e91ef2b406b8e4abe27b6f73c5c12f757825e849280bee901bf275d5485c5df24b36fef90cd1ca94f11347a493b24f984cbdd5f70ceb4eed25e4f4f67bfcbf30904229d1a346d9818e07c19c452eda0cb8896070704fdaadac933cc4b1fc3dc6d4fb445105a242d61fd4f47014151745fff58d2994182677dc7b0e06e6551327287d11769b72c02c15d2c1dbb4a8322d241cd476a5a3fff2ab9d2d4bc8fdf0428a35c14396058d3cbf43e32afe4cb4d10365c8938d7401a64e2b1e55bf7abeecb877bdf697d1e051e106e4caec56f58ef44ad4d3af32d755c6237d751b4cfa5a62c5d43ef451ca6432850f8d17804341772a9af5a7cde3620bffaee240761d2e201ad14ca4bddfaeef4314625417a9fa66e4231912f4c31e106d954ad866b42600395843a9ec2c3aa0984fd83c30626ce67398dcc2c8c725494c7b94b5aa0e70b7a39975e6bcfe37a7647ae4f511141a4674a2e72dfb9dc64b57e770ab6481accf1395071714815281a0c03b8b4fd6f0fac6009649b283448215ef475500e01a436c471dc110789e5c5d3390b38ffc3bc5585fdd9df3e42664db0d13d4263f9b87b98c4cd6ff59885bb88a9d6f356e696c18a08abc4c891e887737a26acd60d1b891e2d259ce6427bd85219199afc87724e3fe1e1b4b0c6195e555599367531b8c95b2cdc1120774a6968fade9c6184cb466110f70b4652cd32d573810eb8c72626fc7b9e148f6e0634e01204f779d8727e19d6e61ca5ff3087884a774057738bd7d5cdabd4f8ba1eb013e139fff278f6322b131ee61760a942fbb58e87d4b84ec4fb1e591fa60173030fca34eb5d5091b9fa21b95f07c04159a666747957e1acf8cfb49cc5f20daa3940138ad5a399a0fb10ad55b840a23ecb0f8f62af5f970a7cf651989cf29a397b9c5b0fb70ed2b1bc4b17cf7edff8288b8e759c503e95e3967429ed310fa2ea622fab8212cdd14f9f6e2f49f63dbafa0879c768d5367d9fbbb76a9dc3c785f1a5592e3f1ab32b341232bb7586dde6c1c1312462e94b617e996f01dd69f71bb3b86a9e62bad323d85e82323fbc80f78ac2f62ca74cf34e0ddca3f415e279e201377fd2688f32dc94b1e83448dc8adcc15d90c8209ecd04f6f2dd9c2c34f3fdc51c874c073abc103ce7729652cdcda96dfb74ef229affea82c4b3e52b75681d78f599828db72312a67b5d0bbf16418df64f9e67974a7764f9e09302990115b65143a7e330d011f7b6fa34855cd197654dc7322b26d693b065cf2e675f99bf7d903aa8b3ed27b32ff90833ce8a7140b11b6b96a06e0542470dbfcfc045c4aa1d17894060c3b184d47abe72dcb29f319a57d4133e1a2218d20b2cc7d9ee0f34e2d4fae984eb2dd7603e12146534df2d1e17e9d30843f9ae2a3a240201c3bc4d8c4973452715341bc3609780d11c33a40534fdd9d14cfa65df6828e46466694dcb9719ca94d0682dd5124b227b3f2b118b5e09e3332ed449de3d5447d408a94cc29527f436487859022b832fd39681133f679d7adf10c3f69fc407d43bf0fae6af47b0412c0772294a7c0e5288d58de728935a9be4a8d6d74174e9812a870068deca15cf95b3cb66d11dd626a6d4e40501e01165644ed555db61214c132068e3a04d5bf58075c71a978f524b27cfa119f0810bd352879a5ce23987fab4e6d87ed8902aec2f4b217623673be0b6d382dfa0fc8cf7b6d56fe91807811182820cf1c9c0681b94538ce3a09c01b239c56ad48732668e9e581ad66710e65e6a11e1af4e2e842d0806323bbb7b2d784274b292e502842cc122435d971fdf9868936f00d694291492c3d56ec6c57d33947d4dec5ba8c418d2dbdd8b87f681d765467e8d406fc2f3035cf4191d395dbddb4eeac4000f0ae8f157baf17e07febc195a6dad7f8cfc0b6a7d94dec5260b4234e3b644c5a5dc1d6b48b1e560ecb6e223d17c49acc3b90e5872da266a7cc4cab45940ca33bb2f20b3dedd1bfd06425742e5a9cd42e07cf37cf0926044465c80bb815b162259e71ed63097cc2abfdd4f0183fe01cd94859de3440e179dfdf2c2cb223b26b88c61dc3fb2dfeff643d03c952e13b6a145e4f59941cd70340a389df3270d9784a437c882d1a47020e964dd725e2c92b83333a070d0202963545ea941ac8ae70707384c694073bcfb6d95d8820162ebfbed2ad86d1654fe559b32c0b4c22da47fd256888a11ccd3a91ce486880e6773d976e09dfdc26e6ff2258feeef2f25d0110a6fe773475f3a416e31681db7095f916b6a9671c54e7a5df1bff30ba8b903fb3cac23272fdb0e829c8694ffbbd0713258c9febfb6b3d4f776e0e6c78f4844b9964630dad10e83f8d736e10bf23b15ea12c4514e0017d1c5fd0953a25443edc77a3cf2fbf7ed6a77d46c93adacaf4b08d9efd11be9257c302bd79bc18bf94cc5c7f827a9fc25455907ad9e1ead9d6fb7a5a8176d39097f10f6ffb22ffaf5344baaa25e911aadb7c20ad203396ed8bc632f304098834eee7f1807d70318270a54090dcffac88b325eda038fb6811ceeee9fb7d0ad36f5b9589a354374ab97f8bde278b8aa928c14c64978dad6ed242b8ca44cd442848525c60d92fbe01f0eda1eed74db6291bbf25c595aaa99d703639ed27797146a3400abb0c99c2a43333ed66bf7b47089f1c3f66c09076546936fdc056db47d71e91380a202951cefcf1a7fb3a70669546ba289364b51eaa3276435c5ba44ac6502fbc6d3e3e18ecca0735dbf693ee6dcecdd32ead28816b6bac24de52f44d781cb3fc4900c43460c3cbc8102184e1a9cf1c329471f94e8485127ce1d06be8e00d9c90238ab2773961ae854b2a26ff77db3f25602d76ad761903fcd413a7e0fa18e888cc5339f8d200afeaefa1c955f2e55a0f8c32c605f79c1e5241a9c7f2d19bdd4a142330d950250b2c9be620d6dfbc6cefb4fa1d62af2c55665f605514de01917b508727896748033a906f567b9ed7986edc1a763db54532d7a427810a304d697b43af86707a92a1a04a2efe4cad9a14dbfe3148d3890b38f38fdbb3c7bf34ce9d480c1f60b674124af0e6800a175f86aa6e0615e74f39435d658abece9078689f6a315180b49e59550ec46db04bb64f0b56ecb22c620687c0f6721fe637c2af3be4532e704473cf19ddc9265fd0a197ccd6c83a69c9c57388f2cb89021d9296936b1ef4349a1ac82e687cac4877fb39e89a34d06c828ed0105351b588a2373f0f515c51969ee8eecdf5ec1c2c0fb5d40cdace7e945869471f578a0661f4eca6bdd96e0512ab4b0353d8f33e61aa9b7f84ba39c8761b2690cc0e7d7c574621bedfb9d8812773b68778b10c654a7f483064222e840a5a825db0ed4bb1a3f97b347790f6f6e320ed94409791ca7ca32c2b3c67d0d585436151f93365ef8a480b0bbe77038bb80109434ca0b68e5ee75f80bd839c8e9fd968982df483d93b7a5bef1e975a6d54a110a76cf6d297c4b7e773e62c5da1f637c3c9e86823864eb39795aa7a65fab15a2fdc2fc0f3889193ebeb3c438ba4db5153549d12e64107b0cbe88e60c984e848384a89cafb0810d12749c88f3672c3f3d6a67371a1595772a56c5705eddd6dd591e9d2be83f9c107675ead5b5df4c7c576c3f2c4f0d012c5a5701ea9a614292a2403e1a4f9b55475e924bc989f97ef3f55084b5c73e80ad952c3d2d12eb4a0a860ff16db8d40b32e7fc80b0370748a30eb9357107eaa1f27ea6bc018176f130bb61c7121f18d30772a2b2e60e308a3216c92576d18c7ee3d054c579feb78fac00fd33f54abca49ec4f17d859a506ff53ca205d896fbc699ae6ec424e9cb0be7db69607cb54c7b9eb7cbb5355717ec9e90c281894a90bc44f8fbc68057a8bb3d03fd050f8e7fe3855070262c6b37a9a45d1180e82367ac59e3fea1933b4514cdf3573e17524241ea3bee1097a24900cc39efa4a2efab148e36b0a2c02ebcffc689f223ec2a7d51c61da3d60607a6a5829c701117360eba98939069d71d6ae8f45c0043a8bc95a68a1c82d77a8e71be6fdd1bd84e8cc95d4fd08ef9ce28a4175a4338b981b9f6a90b4ac04388161f99d8b745b535c0382834770e83fb3f7273714ab5fe8100d76fa61291decb10de6113882a20bbf94df8e3b959c2936f13d24541a1d7e095bb5e72e02ad7372c773b5ae82a758d25a3d5de5bb57ac21af4dbe00642ba55c7b44685a8a07a8a3576e404de85249349a363b597e1ad943965f1201376c50f8c9bec9c34f8f992c7c6eb856e2842425ff8e42229f43969435e16616d7b079fc12dfe79d631868811c5dff955084704dac309feaaf3b4dadd02eae78146879478add892f2811da137125402025c1a94115a95e3f31d030ad8ab22c90d922a8323d33556afbbd29828cbc8d4b764218ff5f18bdd91bea75486fb5e8f9c4b221fbc396d14522bd821d44a40332e82c2f625b2a76f14d2fc6a96fd9f27b15528ac9459d01df44104b30d3475a997a7daf2cb1b66acaca6551b68b7f9790232a039226099309c0505ab5fffee46f316fdce1a0c4bf9bbc3aa57eeba2ccacaf0d1fe1c7c542fd1c4b778ddcd364132a80312f49d760e1bbfdc96a232484a50c571fc148e0fcd6a52b24d1a3c7a39b3e47185fdc9626bafd858a4a1b1c9cedd0b959d03a6277f871b9ed942457da7462a79347e3dd5a26780919efdacd8ef911ec035af0974e07c1b339d9e2fe216c6075ee68a1e81963a17aeadddccae5db3b0dbeb6e4392582588ef1b2d0ac111b0bb088ddb35d409e9425c2796ce4222815ec675adc30a36c3cf0037312a41ed929cfff1087303cecbd782fa77235e1a03bb8e8e5398334f91ac7565212dd111bb75f745f9a0bc1aebf94df692df986062b58e3423e3b837026d8282b607586dff885f0605ddb7d7caac96550bc9d1c32d9130980c241d3e84b83fdf6eba08b94e1d878c166145bfbaf3a73e85434ad23c9c1473187829d8706ec725f8f40f5adf1dd4340e1b50293323cdc8d1c2ce6b52048026bd11ce05ceddba741697ef6012724b11ad632ec144b5f30795d33f80c58f77221e916d1323019ee07155e8d29865ffb1111cad36462abf46e5d8f2f9dae1dc8ce678542d13057eee174750d06f096d29797b611b97b811653044000b5ad678f5976bb88efc6f65bee88cdb49554592acb734e2530b651dd33917e53dd82a48912d0702d5f04a589af27160974ff6e1cf3836bcd1c86f43427d8e0dee968e785cb36a365abb3d711f6341e19a15c6cd1f06c951c6a460ace1adeedc4dfc396e0cf62fd18d412e457f38d2f03c46d406b82d225d8b57cde98e7a91797c653298aa49bcc0be2024ce70818c9d2108fa9d7fe80e7f1fe74494cc7968081b0da7f13912c09ec5825ae11a902e3242add3fc4245129afc823765214eeca5959456ac04adaf613b7bdff18e2ca98af3be801a76ccc5f7ca38748245f8d60600475eb05b00f2a648a63f3a33a4abe0f438b02a47498442e074fc3095dd41fa3557dda034c69b4204594298ccb5b7d02c279114afff9b5823a8cafe24a4790cb6da0c4abe39d0cc1edb6d9969c6f1ad39d3af7e5dd394c4c571eeb8a3a4b5543faac13372d4ebae4fea7f6f6c90d8e891de15dbd675c373691f86ac9c8c106687735644ec9d2c0265e2ebdbb054077d2e8c8b9c82cd92964616098d42d8f37c7678b9d7345121c85918975097788bd6225726e18eef9f405ec0e9573243e3174f5a3ca2b084e67f4ef060bfd27e64f23f4ed1a18628d0953beec4b32c4bd7ef6f6b98d5146392ff8e67cd51a63532693728507339f9e3a43c932600634dada66bcd7cef1c535a726b273e383cefd15868a6d11b53099443767bca9e9c8f2ddc37f935b42a944a9b73069624221595ba1fb519c30f8b44b8d35642652df3ccf61f956d05062d94d7a2f96819853e8eda5e62760304e70d48df91d9147d2c2d09cb3ee5a3c02699be12172a0845aa0411ef8b076ef97f93604ef31f92fb4970e5f122ff83db5cdc89f1005c3028a2ca8f19145e52192055c64c180d528e282e1bd5dd92f9f1864f5b24db2d42675b3bfdfe2ce60dd6f4da376a996d2abc1a772044e003c07f56dd5e83109c93a2744ff2b1aa4dc3266431800ae87203a0e7bdbb8b51cdecac4b3a76c2eb508b8511bf777f21034a501177aa2d7112a05e5487fe920123532ecd4f8879f623d67c28f9e37a89d408108870fd0fb773c577de3a52a77c88e02468a05e4357f4bc513697aec37af2949f93f8cdf21c28af5901760c3ae707ee0c9b63792273a9dd935ce690ff57c00cdbdef381b739ee8fb1b9a5c9640baf9b51e59c7fb2c79c20981ac4d36ae831c543ece22a700fd6972830b9277f60743485bc1fdd658c4f4c93363cdaad672f947dcbb31b64f2628715bee5d498f0ebb1a76a6bb76c58fb0d82a036aa23a317a5b6c70d2e2207943f16528b479220cad66543235c6c83eaebdc283096cdf9d3c793c7f2585714e90d7f3b69b0c7c3a99dc6a8aaa257d20f397803a8ddb6c354b92fde84897ea289661b692f268210c322f66394b8833c2b0d8452569d22cba71b7efc5a54486a64bb8a505c18b1c4d9fe3d8909e5eebfbcd8cbe34eb786d4027287a286af4fa6f7504de8e2fce59b33e3f6d9d1545ff5cf538e5db5f2338efbdf8fe728b8db90b8beb1a17d6cf4821e9c7146cf559e6b513d18451c253e639e80f5d50c76754a80f354e6788df979173a2c7268dcea8a23579066395d5a8237cbec9abc92db675fe9bb7a1e9b278e33ab99c74bc581a66838c166a5cff2b72a97aed3b49f82c6d9f97058de8417531855abd8d08dbe7458046899944a6bb311fbf7ad771971b9875f07b10fbc7d87705812e2a93ff148f31028d68690e72219538e8a9f406688218b00b9044a89699e4c75fe68a594717f839257c087ea51b1a5702e339f54b8c95f525503b4405867f4ecac347d347cf90d8aef59c8cda5b5219c857dc400137d715abd681f60ce24575882855caec905f3c302b9fffef8351e5bad6870697a6ce3cc8e3e86b18e9c61afafac14ba8ee0e1e4d14695d61334942254d828d446d87ccbc85d8c081df72ecf7abf65e9cc207508dfd32bee1a1f1e4ad065e646eeb78411fb3051ac3d495798349b3b37127b568431627876309dafe8ed58c67e491d4d18485e8bcd051cba93f68ef4a13a2620fe781d9b72a48bbfef261b5ba371296f6bc14420c635d8911e91290d33ccdb8dd03aac001bceb2848381e46bc4c133d19d115a9146077d657cd38301a5283b22a1aad0b9ef326dc9a67e22861c141b95365d915054521639f6893fba2f5abef5a46a2858cf412703356a0bcb5fc3d7865d7a0c9d4a8a62aa20af9e398d9aa2db8ee61f1028dce6d7f59070b6349a6b56dab31a7babf6736316a903414ec15a6a5b4e50b9546e396622009285f98b618e6f85e02a5dd4f4203d9147e2dd2c6f885f3a6de8f796d37f027553bdd1fc24f400ed74e7fd51213bc86ed5dcda73e8f9e29101d60ac40acef6615eb5a46c9d7eb11a9848049e58f020d0017800f831d60b37b8dd1afdd33846c84a342beffc8a3a439aad040a22fe011c0fe3ec08fe8dab9b5cc3a6eaf69d4ae6f2cb21795d62fddb403edb6de2727d28c99994c2c3286fbfeb089837e149dcbd637898d7de95d053c650575f012bd9f5c64cf134050a05cbec7ad2f0b15512e9289df85c4dff1908ead73b93e2c25a87dfbca7f7fe46860694f51210e465a52a994e5433dc828d263960283b60feec4bccf4f14a69cd27800dfe589053a768a98615473a07270ee686eb8d6753d32f33515fe1ab05460a33d0a771cecaf604c47c44f82528f04bbcc30cc76d1d540495989ab9709a79d881fe3d2b10cc5ad62b10a26de1352e98a824615a6e4326a5046f6e501fe939d84d5be3192ea6aa084d6eca58eebe73433ed4cf32b98be96c72af713d391054b800d57491e42508dcf22bd6f841168209ec7c5e80d8c36b2b5cd277c01374e7402ecb05623a2f7c68d02841419e4e1955bd9db68c307a8712a35a1f58984f199a7b3486c8dddf8dfe53c4f2e2b5198b2aa97c35cac8d891724a7e5d642d769b20131ed305b2236f1e0a157259792cba1c97acdd2cc360c554e2c60218cd3d0241feb216743bcccbc40ca191a4bf174f0579f8006ba03d018915e7e1edab24191beb5b6cd9bba45ffea03464b66ada79cd6e806bbdc616e9e838c6d091fcf7f499c47c57ca288306eafff1c1f45ecc705ce0ca99ca61a6fbd4fb207a71bf8f6303b36463abcd1086225bc321fedbf88e47daf0ae2a974d4681c34e8221d5a4becf3728cb14082621258fa985fe0b048ad1daa92ae9e4900399c38d50f9b27da382b5e141d2ad96d632c422f65318aa05ed1d0e2475f83d1ba884bece9d20641d6c1d9ca0e90976099609c94ff067f39f46ce45960e1577221f34bd28d59c4be3bd5a509f753631c5b56feb965de45a88b83d0376b9b2c81e8385f6ba26ee110edfe8efa79082eae654fe21fcb0eb03e03954e8a2f65cff774638f2251b9c0b72ce3fca9f19ead46884a2ace46cbbee3d99118598b5fbafaee685fd098228f869df50a8adf82d1135cb8fbb70ad62e68ab2d1ab58bac4f4ee08560c1dc1ac8d7529263902f7be171efb720bdb02c835ae386740138aaf9ad526a68db0299a3f96551d4328b701d871f9fdce47bb2612c34d38e5ca8a57e614f195dd57981b2716f5c71e984c7322a0c47da41df4018a66f7ee4d869f071cad9913646fe7eb7e47d716c55953ddd949b1edd27edfe6c5f269efa1cbe09f59b82bd5cc2ae80946f0020ed2453699bb6a0f6df4e9bd46a1f6d92bfbf7d9fe7815806ec505e32f14a7dd7ecf133e6675d35accd7e6e9dde0d716ef913fe4805dc6361fa20d6c53868e9bafc3f4a3222d1ec842d4dec04c351906125a5ec30eb63bf670b332417aa70a878baade5f6c8c828b9926966a0440eb338b5780456c415ea0113eb5ca1c9147f60208c996a978c7a08bb70a496b32338a6a6fd65cb6ced62530a8c60d31e8873cee08df867275d9280d4424e27ddb0408c5053926b4ccb62ff37c8e87bb11ba78d6cc6a033eaf9de0f728046f5c7db40564d7bc456f1fcf331f202f48707f1614f868fb462fdabe9d0dd46cc5b28f014d27d4dd6a3ee60063af57f207b7ee22f636580135313de42d60c0e9a775ebe9b6582f9286cd312d479044e3222dcd96bc2864c8653906acc1c26e2f9ec02065a398bdbd5938ffe9aa65cc7064e3fadb2b0f38434bc607a9d455aef0216d386bd0b8772f5fca09229bd4d9482e9af3df5939d88bf65bff0109681c5339ac2fd3d0520e275e10147a90af65754e6e5823edb2b80ddf2ee786da3a6f952a1f05a27477acd81745e317c7474df7c8f7efd6fbe32ed61613e732b791569d3e48808090a660ddafdbac8697f7e7a569a6753ffb32e9e78dc644ca2da69ad5d15259427f4f10b60b993e657c652cd4518797964ad934169fe0e3bbcd8cf1a1e6d78ebaced655b10847a04ddf64baf3eaac7c33a53776d4687f2bd4b3776778a337e71e0d0c98e700c300366afea6a138200e32d5cfcefada1e20e5ce09656cdd97b7ea1b1a51379195e31ad6888ededc149882301b1e9e9108014c2fd7f6c42d607b0e0fc9f330a06e6f67914084708464605b6e029b994314932877d7a81ce351c86e1431b14c40966dc8988443e1e39b705dbe56ebe148e17d754008725a73e1658caac0c9609a5ccace0dee4faae42aba7ce6867d792627850a1f0d8ee6bd5141b709506ad3be3eb9d9a8e7f5fdb9a1c10d58f4c65965a4e6b25274530bc32b1aec2d97322e893de89004ef57f6694fb7c47c8fbf688640128cb208bf7e74d595364b55ed4236c8e93cfda2be32059049c54410101b2a56ab45e6f7214ac5b782e9d87021577c447ce0429acd0a7bed30ea0dcd26c891be39672f3b6f543b3000c7c2731ee6d6917d1f9bfee9b7ab101ff3cd1f0ca1f9f11cf35251d11e67fa435f3cb0d25ec3cc9024f28902bb5fddceda3af91a22ae5d4e736e17ecb2783cc113af856c938cc7894cb5d6c72a1cead0e4bad079bcd537801a6979063fad054f423ae20e306fd1cb270495b87cb2782056364d7fb2a5fce638c7a43e17d984367071d1e9765b4ec636b6b08d2a693ccdc7a1ea1920903bf466baaa5510ef747301fe3eaf61c6e1ca305b425c41bf55bdabb159d027a724b75a08d655934783ce30894a5dd80cd435f05e383a3528b24cf02f93073a75da1606a852928b7b286a1a66a5aaf417eba60659cf8727d9e09e8d78cd0ae0d15c1fdf8a377879f28464b18dd2c32d5c1bbcc8f0c3daa83cfaefe69677c0eec6394c25b7b1ddb250b264a63e321d96b4d956fb7cc5b8caa0de0ec4659b9ab6aa05116b53bb377ad8b8bbc2009425295c8c90b01409bfe7dff6793ea10ca868bd41dfa5a8c1f55723b2cb0dc34e49abc4c408461319642de68139bb28da65545233da9d2d94acc35b6ae87ffb61899d11c2cb34edd41d8a2aaa6a6ed363e68cb1b1f543ad54dbdaa093087c04f74a8962ef2768d3eb875b29da3af0ec4695cd7e62738c932708c879ee15887d12abd4931bc6fed9b7bd0c76f9c22f41137d49f4cfb1fdccb32de9350108e7c654398b133329459fb24f51de8714457b718e312b12e4ff298da7d113e6cdb903a09bd6ad666e3b7d9ed1f03179bcbf8c7c430c0dfabb481976c07fa9a527383ea4be1af59995c88380467d9c0b55a24ed1b143e68c993db16983cd96d85838857182ca32c37b20de4f808db4e676fdce7953bfbf72c796b90681936b0f33e06febfac6f13e9a4c18100553e4f46a97bec04bac11113be4f102f360ec86dfe600a5b8aa1318624ef7cc1a4b2c4c21802e5a35ef05a104091f2a8ac828e3f1ec72eab8399fce0d5879d87d2a47460109ec5d81c35a2150c68eb96421c9e58dfa586c54fc96990ea9b1a7246111cb9aabb79db0cfa9fa0718d3b90cf149ff65db7d08e8ba9c0386ca570992a332df3b550bd71f521bf418e5bdf1b0662d737a8baf499a26b64213d9a9702414e3a07089650e88c3f8d3a4c7dc35b2ef73b1af1b61d6dac9e2f25c53f91803cc88a7b8685ff7ff1c042a7cedec1057cc5bf0318d1b566cb43e80ab1d0ac41434ba3c46cb7a1e04f48349fb119d0fadacab46c136fa2a512555a033850e9466124026fb2b5d2303011a368321a0319f8e500497c770e84ef3b26b94ceed27892080cb38f0f6eb335f9d2fe05f7138500531e341c30b7c4be4d7c535e861eefb1c4467b0378180e236d7bddb6090133b4261c5bfb136af27b04ec8847fc277102ee9dee6e1a7be217abeadd475e1a5c17387a530949b0671ed9621","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"26e2e7eeb78b933de115a30aff37a8c4"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
