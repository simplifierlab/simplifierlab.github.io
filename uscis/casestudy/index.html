<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

       <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

		<style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #f2f2f2;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
					0 5px 5px 0 rgba(0, 0, 0, 0.24);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 1px solid #212b36;
				border-radius: 3px;
				margin: 0 0 8px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica,
					Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji';
				/* text-transform: uppercase; */
				outline: 0;
				background: #212b36;
				border-radius: 3px;
				width: 100%;
				border: 0;
                margin-top: 24px;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica,
					Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji';
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
                font-size: 13px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.5);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2caeb1a115419fcda43df23ba31d4f6f4b660643808eaa32fe83e800e7e97faac1d1da30c4cd794125019482c9ae9a02df82422f1a9d50a50972b3734bd042e7405980107bd47df4ff23605c4223d4d891662838f7618aef54663cb066187239e2fa02670ef179fe0a61fa1d0b177f45b32919f83bedf3ed9214fdd274b6b5e144d0c6ab59e6282c67a8377e7a2511e8f609c0ee2af834c0e8ff018aabd65432761483aea733a7abaa095c2839f0bcc37ba7e96c3c0810134a8b9ce23004e3c8f797f12fba985ddc259a78d8a67bd7685887f64e0d1fe46234e0535e544e69d4d7192c1c2b59c7eb6785e5b22aa5068734f19eded56d5c64c50e2e15db22cfcd8b218b43d85c1e3a6ebf39c2322e31d7b2dc81fa1b2911665617daef6fdea34051fa78e29fe17d5aaaa8ac42930ee0988aa90c9284736538d8bb5fa84467f80b3c12de257e234f8da05c69d188842953ac4c561603826e429ce01f9754a0a3e768bd7fce9cf66829982bff5e4d8356075722e63aa8e7a80d22d3d2787b47d634cb8dfb9e5452fab77e29cc52f91543821a31781ba7c87246238ef5ca8808d0b9ef43cc6adb598ca4f5add8ce552a8cc47015ec8ff238c06fa7733d5af98639f952e89b658995ae4a76b05d811901635eb08f0184dad9fb45df7e1e0c1ff1846cdab7fb23b516c12aacab71022d0b7113a085dcefa2dc8c193aa93eb6d5ab029d9b6583eeddf5c1c8783439cc8ed73586f55f3fbd7532326157b517b9bd9bace43f57f80e79e02321744a7306d63b4404e000b670839faf40de44abe7f333f7d25bac9bb98b48e00dc155c833892f18d418030ef56a4ac976c1421a7efebfecfd1ab2e221a806d82736d114fb2b457c08cecce74c969c79856d651aa9988a25ff12b4b1c47161b1481bc7e3993a6add999e2e2354dea1008b59a0bc9c4ea6518f9c6345ea0026d2f1f410c36a236ad5781548cc937186811699fbf2925592a1c9d625e16ac1944d687c3973b3c254a63bdaf76e1f9fde28149db7749fde7ac6123e589938acb7ef967571280021b11d7f355aebe6537ce14c7b7d9f0a9af9395e94885cec9358da924a670c03622f9836a4c1357ba98c1ff098f725b20463d45245b042c83795ea47ef659b575cfc4e329343e5135faefca38246267578956bb2c0fe7cff6ad3e66067fdf598eb97232845a6293d57de2e17ce3f89cf3962325694419788707d02307b0b78e3e73ce1df0318e38ddedcf35bf6ef4edce8c15de58d531463986777b0414432d9095534f297ee877a3452ddb51117fc57e0f3bcb4ee8b820ed796a2a137b9f97bfb73ea8b7040ec3fc2b6c68fcfae25ecefde4533ff3666074c40eff14a23f1e50b482c1f43e790ade25bb4ddfe07c4bc14f6c942ccd5aad1a495fda3bd88d6c2f47ed52123c280d8f3f2a73e1156b7db22d0f02398177c51a270d4e6c31435310da499c697bf8fbb56c9f2b7d449beed11f18f2c263190d448f49e277a1f0836ce34a030138834ec69f59199b2cfd662a2861da3582165648ae71629a0a75af80c9b55c884118f5aef677f189aac7e74677ac7dca015344434e6535e6cc4680fbc415132472d179be27b9f0311a6d6432f98336b1b2ba9b83df7e634c8beee41618b47bea173bcd0999649c505c6c5a51666072a577cfbdcf6dbeb0c08c60d4efb51989ebfcb6e5bd19425a0c7b6600a202dd95d040b30538d98753b06fddc483dcf98dc907af591012625732ee19314359babf4985bcb709df1e50ef476b368193f526831ef9dcce794ad9738b9954e1bd9b446515a36fc53d8658386653b69bef8dc1319432fe3bd7224220558840c05dd6540fc77d14f1add41da275e130547819a5b16a867ce6f872d5e0b2e4d59f37d2c2f4ce2f4cb0230f87dcef7817d3cd7716fee90ce0056676e2ead653b18e9c5b02e125acf10228e1ad84a73e60c4a75068cf4584962903c5fa0ec64c8a500aa5bdf26e0261645c3619222f4247676dd9fddf0a420275992b621eafac67c50f8acd970706ad664099547516f906e72eb44c2e804a0a525a03f06139f9653cfe6535039289a1293c370970295edd80317e196e8318b2f8514d8be17c1709136917617badfdc55dff16b4d83cd4678c6e0ce233271910bcef291468c806ced23fe86cb1b75a019830201f70089e97d79f273bff49e5b953bf477913ce44b5ce52cbcdde9484c0fc8f7303c9e4085374b055bdef6bd571c409638e0584fdc953aeb861392e3e359257235badadb4ad1593ed03ce4fd2c91332b76a2a4b73168cc92e6d4c509bb9820b008867673b7e72a1a384b1591ebfd7a086955e785ec66a205d2104037928281b226cbf70359a481cdcbb0d6c5c3f08e4dc8277e9ace281189e4df67fc22fc472429b54a81f448e9862f005ab559d31f49e9320d19c5542ed11d4150f78d971ae362e0dd3d213edfc9ad49fd58dd23875d168eae99cdf51e8ec234835c5febb85ffd87da0d784e865b420f2163a0cd9678eb6893f463810faef3e9a2249b1ffea37f0a227ccced770ec4ca3e66b5d01e7b38d37a1dd4d0ed58bb172530ad1ca7e1c4cb696e90c789db7ffeb1091603f62ee1f1a1ae646a05e081299efb51b4a2c8a9c5d0e57f58aff265546cfaa42c43b1445f75570932b6e1a9a4b071a76cdfecb473f4af69fb850b5d46de314b54f5ed6710c54447ae0b9a66637df5a448c57ba7b2994b958711db43e5d9b032d3794842dc098217297efb5b7fd5d4b99531585bd26c1206108cb7b8f568d09a028d756db4a8e44043d194544f620d6082af50423c3079eef5f9a600f6e4b44c728f2e99535e69f3e5dcdf5b1c30ae9020d34623076dcab532748a5a8b3dc7cedf4f133daa47119a08c2600c488c9d03c6abab5ae35fdb1a5e7f849aa466ba4584a42b49465b75da5e21a08a0b708cfe231b5b6ee4ee05e8e51510d1fcab020c67f027fa252d78eaac73bc90dc5737a9dd9eacda7c918cae597144c6b20c92c7052823d65c8aacc100e7938b52c53bf8f21c16ce8fd6c5231c1cf94fb3d82758f5cdf002dd24cc7328c0455c43c6844c0238c9954d2d9363da8396c3282db7678dabe3336202fdcf964f5d403c819fb4e54d9b7d635a99a69808a9c171416345db4e31257049cb9ef1b51524b083447e0d950b8e005b6aba29dff452c288207c525124199c98b7e368104db62c652fec26ec5385f04062197e7a053e7e0d15723954f015f9d77d13d95b5ba7eaf8da0d4985b0adad3935524dcd05dd088cd37284aada68d647838a55bbadec9daf80677ca1a39be32cb0db36a916fe9d96c86bf085174e980bcf7c13f9b2bfb9fb5075fc19974bc4dbc39a5ee19105ae6ae71922b9ff5ebae18a9e46223ac807ecce01ff5109af0ed83de46d00664f9fc135dbbe4191ac56690a50da780b3b291591847e207ab807cdb018b7b8af77f69ec1fbd641e819334f8c4dbe4fa9b9d1cec569452e0cad3db9bba3f69d9219fbd63fd8aa7e63cb7e06c784f76edd7e94ca879b9368c77d535452eb840a1bb78c5f20b18a635d776c7a7dbf7c156e63da15d51f1b6792cd18b653a069513c4912f6b26bc60e17f784acf8873ae69f844bda1936a16c9665512b3067067db79664269f5d16c65db1e67d04ab3930b4650a2fdd4bf7d8b78cb9cabf262c7bb8a2c83808ccfa84e65e42c6b1b57859b3615cc0071493884305697ad551c02e7c9cbf2b0cc2d1a956750ac62f1d46ec967d868753699e33594678f88dee1ef729333e10f2e18278d72a10ca6b1bb59f0ffe55d204e7a060400cba97a3748af4410dede9138c01dfa6969c6b64e2196c75ead92580d3174d0ba4f8f6977a32b7813e95bc03c242d6fb4293e706d50ada3c49801d9876b290f3fea439ff081a29baf34fad6139050f8f3ec7fdc5948ecff84138c75c9f8cb348f9699f93c1aae054231adf8cc4610bb7e49d29d4fe7ad6f984f5378a6ecb1d433504166d239d04be122bfa10dad5b411a65e0cf61f91ea49bd11b257d6a45b477dac8d50dedfba4383e247223d9a4c9972bcbde4a6633442a0137383cdb8e33036b4df998b65b5fca591645a632384171f090c38bac3254aa5d6791770cba7eeab09048d16b2dc354e7bacedc6d3d15416e49c9302dafca8fa7e0fb54f2fe5cafdf875d5f46a8f7e9136c36f47c53bed7e09d3de050197431876abc56a819fee0a1fdaf98a2b48e499e6493013aa35bf29456b62fd033c308bfc975f8495ab8f246eebf6c441593394a1135d8125587cb59aea9d06e587bffd7603af5a63ad4b48b64692fbf6ccea336f6158f5bf3e4d9553953783e8259fa3ee121cd20b16bfa16fadd1cba56d4b2ed00d7b752438b8a7356b24ed0a5a5eb16919f76b9c95acaf164839f3e6f662d50ce74c08362f3c11cc9e872d2ceb6a15fbb627c89921a5352aa892546c9e7c8a9cafd2fc654583e60ed955336093f8196bbe95110c2afee766dc77522b528912bcc8c4203a6d67fbf26f6a0333c6180d778dec42204dbd9709865385aec30bc450d3d5912e62e32a113bc2e033f3bf60a0f9df6e0827bf25ab1408062af53af038f92167e8ad0e9a015d01240d3af72f38d492f1abc5c3167614c33b39e5c322b129caaaf698349f3f48d03fae9da9be6b40c6fd5c0bfc7217edf74ef304c4c8121eef204671c1fbbf6f8ae6154ca95dfeb62f5630b70b7c1362c55c3616dcfcfd3891090c40c79db68404fd8aa333f29e3c9d6326079a548fea8830837110205d388ac0bc76fccd298b2a2484dc536267f4fb9eb99f552aa60594fec38ba0f29a2e20d722900789e4badd277c9fee73a7c08a25c2cc545cdbbe0debd668e3aa482fea037cdb8fa4707cbdc7507bf050ce2c19c7e582c579955198a1209b61cbe5d752829e59fe5ec5fe4cf1d801b61ddb7899042a0b531c25975a8d6d59f6e566d334cfad07352fd153eaa33a98eecba26264961051043f8fd00bf3d66a29bc5192edcdaeeafcf1ec4e5da67eda49e7162ae861218bf763d0dc37a247092536c3fadbaa03e13d2b5f28210c278e047cb5362778cbfb7af205d9059ab46a2309eaf7b4f1791c01eb0a16e3bcfff2c1363407215b25ec6116119250de70f9bc3ab7f25e1ba4df0c1c858a04c130351d12e5c6447dda70fa1bbf0984d7e352c6e4f3c9b3cbb70f990bd1bc7caeb2fb7a21c250435123b98a1f410674c7d59967345eacdfb8aaec1db12d19bb44c9da817d1ba634d17ed9029c6932916d62d92e18ee5fae5ec8f3128215c84507ac732315f4403f46b43c3bf0f0ce13491b314e393c6fd07cce069c7678cae63939bf7ec565159ed67482255c09649ba061355fc96d9cfe528db64c2b24fcb0f578f8d2d94be9fdbd5818acb1aa9c54f60669f221f8891ba06f7c8472fcaac9ec210a42c9d87be68a0eccb080b8cbea28c87368e11aff2f240f6faca81effdd6501a2c43530669f06f0407f848cd58494e9c76b5b05266b3e5f81327f955d9f5232a60888927f1f9fdb0b24102cd9aed488749587c08cb3e2f68205e510bff50ef4c503080623c8b7fe5f68887a1c3f358cc78145ecafae7d7e9dce4ba6da24376e98ed8481d1ee8739301bbd0a184feef169929f2e483378dcc028b9dd8e73ffdf1ad3cc0370cff62320f714d12b952b8d6914d0cb5043f2fad9ba7204284b7f025c8b66fbf44ae84421bb6bbcceb900d2ef91b9afa4b2a0a6b838d6de83a36735c164f2c61e7d54cbd681c3db5dff8319206c2c2e986ac4a91e038a6605064cb6da8567a3084d62efe3b02ca8043ad1d346de477fd9460dce35324d278bde9eb4339815ddcfe9e468a23993b4468fd13f798129c4cd7e25c8b966ea0a736f0e97b9b07ef22b2609206a903a039875eafae362535d0dbabde86bd692d40243eecdde461c90751f4a2e8a2df2e4defb7f7b75234b9ac957afa4b8c2fa48e64d525faeb3b39bf290ef3e8118a72e7f4aa87372cfe09d0835d1b2fcc7362bbd954e4f4ecab11b293211711e52620acf302b210a957cc1651ff1e6e6acd6a29e4c264833b38331bb67181b9c63f06c43fbdcd908554d9cb5a1fc1c749b23a96bb97d04c1c039047b1d1808a0552e8f5c06fa8f7692caf9c59fa521c163d65fd0e2ecf715177b12621a740836fa568547f20c9ee067c0c25cd354d6ef54c4e0174dfc45723856306299d602667535a337544f03f58c71879f98abb30a5dfd4eaae7f65462499c52448538cd442df4bf7072c05fedd2d65aa1795ef5bf7de812dcf61c226654d88299f926c3bc16d721bc601eb20055eacdf776fb3e9b4801c51f89ade72fe990acb166c1c0fdc3d040dab9d46ac1431ab47debc1665c202faedf65a59cd372ba4fcc56d02f86bc12ae8f43b1a481fcdbc544679b9f3aaaee35c0761d616219513eeb656b58da1ac05c5e574bc5c6f7235d600440c088b8d4630f0c3f7c13cbd4125d68c7a7bb549aaca4bae3b25c1b913122847e383bd34291b3896e148d4d05e9c07f208123fb76bc47cac94e684544e35e50c872c47f02b8d23250736d5567d91e89a8ebe8d384509646226eb240abfa7130ce6ebd7b619d17a30ac1ee1803d288a178a3ebd38df7d2dbd4c03aa2920e64ae78ae51243408095bbd15d3a8baaba8231279cd5a9cded84bb4b7e2731ff037ade5314adbcad8b2d4ff45ffaf79d10b66aa1095152f99411057419dd64b5215b2c8c3fc30e2ca95f4c30eb05fccc671dcef56ff88f3e4e744ae148509f97ae4093a1b09a3200d7a8391b33745c854c9c95a024b6a54f0cc93ab2fdacc9b729e745caa7920efcaa0e7182e14dbee50261779b83294a66ad59923645029f472151418bf984e109485c49801f7f264ccb8feaea30a10944c70bed8ee464a7c2d93db1f97f6a6dd799ca43a9b9270f523b376007c52c2bcc9ccab6cc16185981bf2780bae33ac938254310014d5472d7850aa1b677ec772e7bf5464e5aa3bb28c16b41d995e491e0a4b20eeef3e4c3655488292ba4d759af6b0c00a35bdcd265eeb9c88606de89fa7e0c06a82433aff8c4162789e2975c5965159e72e57264d06efd1a7745b4f2162ebcd7a64e4a8399d49bdf7632f5209c55849fbf6721385912c277f491aaaf98ad2bddf280f3d8ef83d89b48083d0c7f70aee34ba17d9e696d5dacdfc290064f448412cffcdd1ceba8090d41b5e1dd8a023501e63e2460ac638e49596cd208c75e46f989fd1019316795ae40a411fab5be2c571b8ce37642c780deadcc9350448501285b442f5020e780d1cf71a05ccf84a574896afb4373485ab886e512b9ae68ab783c1dee99151603e13d4946708ceefc9e756091dea00078d7708070fd340f986a64810c3f0aa9f605bb7b92fef25f16e44ce843f71c84f871684bf10942db2d422d7969c077d7ae5ea11ee33ff13d6d63554c0d6e7cd19be150eba69f76be66ca67e0793164cc47e92c07b6d328053cfee33932131b1607d0bff9c14db379fd3808abe746f95f2590d81a5a8cdcf8ff24f1b5e298a82d4d5fbc65fdcd27145fa2f23b59e0a94c5856eb77877ff945434ae9ae52eae4dfaca3544465f2a4208a141b981384dcab0e03bef32848861ce46b0f7eb8640df2641becc5191caa62e39fdb4db3ec47a6f6fe67ad6e6e5abc30b6dcb9b5d7d4332728ab692e53d89b96df92239dfa69c9eed7ffd2a7a0356b3faa1a3ae893b22ae1fa761bc362795b9adbc3d38ee0382cbd46ca1158b79bbc581e3eedaf80a33023925ef8d2986138a64e8d4faa600aab0a475c512ac981046184d3c19fe46dd235bf272bb9e1b77a6190ace23e9bbd57af029c9899e1495c131cd226acddedd5a6259c8091618b2a34a40b443bc6fc0aa1edeb89b3decfe3611b0937fcdb76e3ea5af95feb5a151b4f770a5b3abab94d9454cd35e38a9fe3c88a065ebc1bbf138fde1e4da876e94aac691de92c8a4636f8a0e7bf1ac0802f64889bd5eadeae85ef1ed4ba1996fe27730c98f10f94432a7b3f5041dd4c8670997c0fedf6578b97c4d9feb5d80d72051a3ad1e0844abba4ffc2dc9d877033ce6bd3e8b3703cfef63c9c65e593158d8c10c9d34f3686c5d573cb0784b9096c379988792984c8854a867fd77c5c439d4bbfba6c663bd1507b147d558df80328bf8cab950f7e44f0fc04ec7896eedf0477abbdebcf61ac1f6a88bb6a6028e1e9774f4766af40ae915ab7a3ea351a108384301e91a3cc7d5506bda200cf7ee14226c3ae9ea928a2de8f9fb1c8161ea6b689563fb44ec8b28c5fbcc124d75e2bf8dd0cef1eb253508f7d1f1510c884998ab4f56de39cd93339cd51a2e3c5be957e72e655182c22353e2e39464061ce5a0894079c584a022dfe3107f88652dac0f2d48056f1eb201f83efa5a246f4d42255e5da4706d23f3f08cc6884c5daf35579d3daefb204dcc86e3c1d61e41703a8cc535a496a6808a44984ae1acbcd0cf42a2100823f429b7018235782f5ecb94c9dc2d15bd0684da1118a295b52751868e559dc84c64b0171e8663d19fb26343e0524437d4cb9aa7a4c75e06ca691cb457a684b66964440d35182f3f2f28ffb13be442fc8c18e37fba0ccf10677e7bf2368e864660a24615e1ad0fc9681e923bcff50ad257f3829a7d67d2c44180247aa144bf620b0487c2c0b57c985a55c3e70178ade68b50dca40a48d25f226a226a343d20ed41fe3bee1cc935ae92e22a1f91332d6cf7f7a0b1939bcaf5f9a029188ff42d795cf6be016ae091428bfd41b38c00dcff464411ae53d868650998ca0a2e8662fa3af0cd762c5b1f5f9b1acea9f9f110261b6cdc3d5687294a62b0a4fd069d107caa467cf9e73b83a7bd6c0dd3adfe4e94bc73ac2dc23f01452de745264bf67147bafbe7f37a4b58f4daf4df908951a9dc9f5e30980dcfef5d9201ea3277a296dd1886fc6e6bfd3abd162646683ff8167c08c6d3fd9987a55d79a7f6b2077a26420e0ec76cb5301911f2a143bf49906c139eecebf6e96cb2216484b5451da33cb3d637e277e54eb7098792c67a7f4d1f93f17b8d2b27f86e6134986b884fbac652343c06c5edab6c4c1027c274c2fb6a11e6ff3f4633a86bcb699b8c1ea77d505ddd4f1b480d09ab9da090cb945bbf3f2ce084b23e9f0f42952c82df7b3e05df83fcdeaec39eebb287ae55816d25752c6f21711705dec83ea91375e5d537c0e80c028aa2c3912a0ec0dde8da28de0cc672fc9d330e606deb67d5588fe9e4f7f16eaaa7b414aaf1d42b1540c2c0fa1cf73b919912126d7c3b5a026da5a0882a0784b32375b9fc14c091b9a6a2b21feb2d8f73cde27c766e822c9e8ebe06f8f7f1b2228b8d0b49424820fc435316aff97c6c599e4913456a4280481e948ea22402ac3bca2ee5aff69035b8e72ee5a5c8a5e9865778f1f7f0dc1dcbcaad4c6e6e0773714e3c9115e1898b734ebd8f7b7a47d642a3254672149e7b86760f8278269a461db7efb6a30908c28f1b7f69bf98adc23caf3d76c4f1df726a3e472c4e5e6024fdb3e8aae3b1519b38f290f1046dfb57635c78520425c5eabbefdbb1f234e9f1f7a76951e8718a3c78e6debd6a9d6982680454167a133e9d59f2b13d552371d8b826705ab36d97f2cb4637e9ac544671dbee74a11b13c6aeee47109ad08f656025f035dd5d8e9dd73a25fe8afdeaa9b61d8b5f6ac6958190f3602bb38a8a980dbe5f2033cb9ef9599074936c069e4f612e2ee3db3bfed2993433e75120bc3d799a8fa2c7fabaaa6ad247737b3bea341fbe7ffd0c9d151fd35e70fbe9b7c28ff51612c30c9f7d4dcf67d63f904c44820f20a555700615460727ac4ed167b5cf0f205f7f1fab812c039bc0c7f4b1ccb42b528c353af1c1cccf38da082c0a1496731e19f82027ecfba89b77628c9f3b5c273cf771f6db3c603065852b4e7285708c82c2623e72690a294d2e8fe05551e5ab8835c177ce9e7671d762ca10766346c8e4a1c16dd3c94f49a6bd68fb997a3bf0f2dc03cf9aa22605b4ea2a1e3d890264b01da67a3b71bb91ed243f630c18e47b00b99ca8d195dcc282693bff434cbdadb769cd4cb1ff92eb2dfb0f5d4e9782a3d644f707fe934ed1e44e4dde86284f085b2410087c156d168f6d2eb7f77e051f567037fc17fae4cd0a210fe46b790ee4937a8cc0e108fb74902888858a2e059edcf0c63721bd58660b956eac9f563fc2a356a18533191a9fc07171cd261706a0e09008bdff76a68ed576b6f89785f2ce50b52e45eb3a0a52ce374c13e0c7fdc1b04e7848bd79e5db3659319e1586a0338734be08f7787136974d2e6f0d9677f877faaf587d62a1fff16e1c76ee1c509312c898f8b1d2a7afc620eabd27dcedc2c58e6233bc38c68cd53f440c5d20febfe3e1ca49dbb7f5e8b44bdf91b3d50b6127d59263934b2dd7dad51090054b9e063532706ecbacbb372bbc015046d97754020ff776b95cbf609c1ee7a5db25500eec3a474de9d971883c69fa3c7f9c29f14bc59d9390970a82116fa0c524b975c2d285a783a334ab30540e1702a7291d86a76601fd907aea6a2dfac57f51f40cddf9e38ffc6c03471d86b2c7a8dd276c4e391f9bef081f079886f170afe4f44692e85e3024576b3287c818444dddd6e1b01819b948cbf16551a953f94c9aa7622f8b4a1a1da37aeaa971c4ae93964e38eb91c071b96314ee5f28989990b3c957bfef8af2c72af4e64206d2d325767caed71fa62651737b5b8ebf8dbee861504e283c7a19019c5b55d186b7f192f7eddfcaf86953e0f0c9c9e1c9af59e74c0fcdaae4094325b91d3c5c71ab1b9e3a696e2f706125a10d204777bf08a12c3216fb71775834c888d7e7f75ea8ae899bfba9bb033c2915922941fe779812e6dad5e28d881cae89a8899ba8122e0ec8250e474bdd71b70574c63d1f0cbcc2d5b27cb16e68483411ec328f045a9bf9a680624f78f10671c2a691d70b3a5583d4f6153a964dd44ea0e6f6101b32883d18d5a2e1484ece2367de67748f505a386b519939d891f40f8a200f8556e1c7eae61888bd4fa80ea42cef952846d63c268d33123ab248872a82b3f324debbd910ced7d5f62e5f34e5b3841eaf8b12268c4659c64b13229f9d2f4373096ec1aba6d1d254b7855f222853e89c753b6da8b488ae50cd33bab1304996f706198dd1d8b5deb3fdc0e1c9570b58274b8d93b49831342f155210902c4dcef1b7fb2fb4a58114212437a65a83e744b69b0624fd7740080e0de36853528d9bf9da57407c0df86ecaed3aaa95bcd6edb74a1b4509b4eaeb8fe5c6635db587725291bd39ba99489a07470c11534af43234f4be92cca1cd0d6c624f1f684836d3db27d8e56d220eef022053283d399832b929c8b655907eea61e0769787e77444d82394704935f2d66e2d55e9c36f904561ff95608452b63561db38604b10d3c59e9c43fe1f15412ef7027fa43c9022949e984ab8a5a0352bcec3ee4e6170a421d90aea365c0d714a33bcc2d04c6b36f46541d13ca2f3f0973385f5a220e417095cc952f576f6edb91908b18c0d1d2856fd18c14bb50478956c7a5ab175d3f1aeb87525837c02c581f0ed8934261856662bb97c8a2bdcbeccd939001fe474291762bc14545f74347440454c2db859b4c279d85dfff3d14293ee79355c660c2a11ba8573a32a9939cce95b760c262408dfaea84c16f52e408d25faa63ea4151949b4ed57773d2cfc44d016dd3ceed82847d3a2e32d6808e7a6b33bba7efdf8cdcb7c721ce7f9b400bff0bb7f1f03b3f9ed63181c4b989f1295838d92dcf17ccbc68f8b63b45a4eb22a3ec5dfc9f929b52fd88808dcfd4bfd38abab51ed204264ee74fa96db593514310f24434fe1c3f42547aeff913dcd8afc5fd51ca7bdc34eb0a40943a87c3f15bb6556bebf1821782d0c036a968d70dbd636a532bf7522b0158716946999f0eb4fae733b11b4882c6995752c197ba8e17d31b23a96ac8569697e340ec698c12a676b587ce7bb28fffaa6d7caa85c067a2f76e4489abf609e73971cad82c20582bff416ad245cad3e3d4603f873d9eb4f45f9580cd0ce8631589b2ffaf024120d2c1d27725c531c1d6e5c41331f60dba93d748fcca2ff12e8a4494673427f0499c792784e435d8354812e235b2661967dd0409107fe6afdb065bc2c0789ef63ec6c19872ea47f07e106c6e3f7671b7629017938e1b8a6aa7d4e3fcfbacc582796d807f4fc310f65f2285509f881a6b357db528b3f4bcb128ffee7f05d4e7050946c63f7e5241fba474258ea9f0b20ec439379a8ac30baea2abb3923c10f64cda5ce3ad01f7265078fd22edd872532541ab48f07a059367d96df0407fbd01369e46de29a98ad22cb75cc2712a5ab6825737c9e544bbd7e12ea67f0914e6325d39e6dec614d7ce42b8175f7ed93049aa6255741924442f01571aa3c6e4a8ea734cfdac73876e17ce6e32dc6fef73570f68b3514b37d0c6b545c91e69825a5cc413bb8f2625ee3d14f0cf9cf70d55cef40a10c55cbb73c71a8408e4e39514bc298217b867ed89690e129e60f1bbdf4776ba050736a0a4f4b8eb54ba10383945173299bcd282181cbe7b5d3bdffc7f212582f71c2a1d0d35a2c63dab4e3161237d95f37b13ac0915dd12b7b9e28eb9f6df0901e36df5d2b46547a511424005ee771f919df8ebed6f07c6fc0475ae976742a6ad406b1651bc8ad66b40e170bfde781d9982210ebac007db994c3bee41dfc6af7377ce9b1a08b397a2385733f3e7831e45bb3820633cfdc4a578772fa10ada63c463174e087a60d0d8a8d165db75c0ec3eb9abecc75e907f56236b2ed4dca10bd1df303fe97d1c843b2de71861c0fb8ae86dd3d771c79b67b46a14a2fb46e14780148d6babcc5ba8064673ca89fe8d5a4fe982aad8e1eb1d8e74b001d9938968c542cfe01c8ed472d568d342f69fdf5b26cff67247f04eb99027d51e2dd89e958dd4936918f3996cb24292bdf608ba9d9067452dd2944f20889dbaa03a01b490d85e82606b26bb6e3b9efa92cb11ed0610fae500c469043c258ba3237178233d7005af82267843943464444c638d3b3639cbec7dce5b6fa9d5e21927f3273b6128ab935d10322c039aff30ee0a0998d58d85744d5faaf3e1ab34e527b941ed13e1d05a9e6b5e482c46d25b83d4ce3e55f62061ba8817e22d1f9fe907610fa29d9d524a9d8fe07de5cef4956da4c776c647870f01643fb2964c796eb547655c59140b449a0398500e379b668e5180e924442204d7ee9de3751fe114c829aefbdec6c69866e77437a959509b8cb5f94d4070396163d0d09915df123189d1be772c0c1b6f72c0b90db8c34ee67381238f01be6f4887ce7897217063f1622f34a4fce213885c6ad8ffa6f3035d8613416991974c40488ae47464baaddf37c527415be20e7c37d66d3e684f051da8125f3088466a2a44087205a818f71e6ab43e00ac0d77b9b0e1af27f567ab81b9144254f11cf148e7e201311cd53fe53af85b9e9e71dd5e642b01f5f28fd9fcf0412e7dbd52798215ac5c9a48b5439ec0e2ce3ea716f9c9799960495d9a14e3988af5c1d8c284b355a8ad456851ad0b83194a31f9bc5bf8403aa60635065542b7e6cf02804c8f983553cdeb87282fa86871e31a151927f471745d47b15323364133649f0b88cbbe9fb6c0d14151247540536eb37c7fb9d92b574678e3a10e390ce8612374971a19d487fb0f726c447fa6a162353e6e00397fdc1ec4547d9445aa3a0ad306ee077150704370bd8d4f36337202e7387652f8aeeedf7f9d6dae2f09565969edb751637d8e533ef131cbf9af873b8043c24f59359f449cddbabc00ae9735317a87e1a6d3ec923692cbb5373c61da1f72d7bfc97aaf4a54e3d3f898601b440237b79d6bae3c53af7778f262565ea8e56340f9a3b6d69096d9fce38b50435074a0e5e983f1f5e949e04e75ad0cd6063e05c95fca9ff9355f6ccabe91f0eed96fb1793de0344186bc174f558ccde50e29b95e64d58b73a2f83f526c56de848540f319571e7d1c2487dd77b9a27aa431dac46bd70e20548a4d6f0afbd457ea48dad48e261c9f8dea280d6f3b0ca58801c75a9317cbc92b3e078b6bce1132430f019c630f620d0ed9ccae2b59bb974fa7976a85987b8ad43dcdc6d082cecb8910d1afadf372ccb99d0ba7769acae4c7c708c86a1831177a8026d1c2603d722b26e26175d3d93adf089c3ecd568bc8643695cf671b875e306e173be6590d2403bec0811b0134a63f758bb43c2758f21c14f3d2aab68efc49099eea86d5aff2908790d7cd77f61f819c670b419d14bdf6fdcfae4952125be3e4ede91b52df77157b954de8b38a4b02a57897548a634ad758fb818eb5fb0fdd87eadce1b4a152bcc3309797c32854b5e2743b74ea2e03738f278acf58b9cb9d8c7c8edf0cb177f73dc0e14c594ebe3fbcab0407b964084c700a78084bf2a250d342ea4f0f2b588120519bad2bd5ea153b38aaf4fa08b7f9254e85246373a04da6ed9e4238a45f06e5f15be50d8b939e19e8cb88aff2e41a071c89388bb9345a5dc7c76dcc7890cf903964583fd0338f1fd556a2d7a34bac96c81a1df95eb868f629b6f2e5574d477116f9b48e4193ba76727e5bfe95a72dc95cbb9e0f758329389490457c29f108e3ba08081896233d1afe82ebe9d600579c4e1329aaf269e199f05f10095f532de6c719d0e0dc81155b7e109cfeb9a8f191314046c391928ec94ef6a4a1962e5943186c399616d520756787b2f2840c4037b833195a4a0d67b9d479758d75d8a936d059e82d609a5b7e22e9191ef4ea07253528789666673bf1035439744d52e81491fef96ed872ef1df22e2670dad13b0e6fbb29503dc4194656fde528a9bb116c799a7f59b6c80ea618ae90d9ce917d972a6d0a5d58211b2cb6c682d3bcc87d1142a2ae664dcf8200f4e05eb00c28a37759f54dd88fb55f31253df9a1cc9832e3abda275d56634d3e2cae8ae1d28b54099699555be4c3be25c7eeb266b9699394498833360571c3bfeb62816efe5da967faf80f53ea6557a76ced8b0266e47bdad562df83281f938cc2260639ec45484a3efc6c70a7634115b3609b48dc781558465f703c9b91fee67754d5550ff0284b69b41b869916cf2340b0fd591a3cf2ba60f9568781c026567580bcc4999db6581509740060db70c48def8fc0bb0b4a99202588cbbd664d3179431e9d86545e057aca1a918ca8584e1a8f23fbd7437016e138b179f7c7dc6e7b6af963ffeadcd8dfd70eee4fc346cf5bcef553b2c67fe4e4b60a2e5928510db7db7a84d0ba6ff0a5fdab594e968e61d369124e1ecaee70b62960efb6c1e275271c10d140dfd0fc469304301a98822c1f588ad116fe9da56945fab78122e5ce4f47b21e3374edd2d71febbb869360b9e383114e7ba67548b34512976a29f905bd8203852560ea47349c5c95a7902c9be9031a3543e59990df6ed62a7aa5853fcc57a0057a28cb4d5ecc618667df311c87944b237311237932fa720ff6e966c8a69a08521e5ec12bf4993698e2ff0bf8c82c06153e1e69369385b05d349790846c2b55665a11b2ffda9d0caa2486a013f103ffc1f038b5c292f16e6f28b72eb8b098a129c364727ea9e8dac6aeafe6a0b7252afe2ac3ffd72db3b6f4e541114a3c07a02c4a9f0384c933648cd2bdf8f079e4aa6f3b0b3c53aa94af060b8abb8977f38d06393c1f558b6d2c6ab0d2c7792a7adb47bcbcad3e2ce194824ff0ed4229852483e997d67c32427c52a97628181262c58533b131b0f5aaa38c4416e1f7181fcf271cfa8e108e7a66b70cac0287daa2e07014c826e9c671624026cf1abde4a6309539400cda8648c5367a672f2c176fe9b9a464b9ad6bed7827742449ea4933fe5cd88bfdbedd8a0883a34c6536e7a8c5aad70873a7f17b2537a26e3c4f49ebdb56a30ee015f92dae44063ca53bd14a20e20d391085781afa6db4d11480cba0228d688d07cdc70673347d275da59d06a4a1635dbcd84aa9d033f1988a919d4edbbdf35e53d80edd9f4e53b94585a03d89d762c058aa7721897ff9a56b3191d5c7b1aa3ce1ae7bb00cee95f7ec0d27e68ba24d08bb0853527ca10999c5fcaac2bafb8f176977735630b944e5f3ec51d33fe9a37b3261d10f97a6126285be398e7b819d61dc9f6ac31f5699f9e4935b55507f1ed2b5413aabe73d452b0d783b41835023e9e93e1d8c1b422e571276d1e95cb1bca2425c18097a3a2024e87554e638b2e14afe008e845ef3712b5ec99ebfda783cad87e33379e35502bf9c5676fe5f23e3047e10b9647e127180f90b5af980d5ec77c3e74fdf7c426c30b680daea8317a21a2574d986f30c7673f3945c4c867a57d4c07e79de7b7b19ef6b4a662e5cbc3159297e6b3363bd539905d1b5655f32522be6c4bda396c346277b61e49c868cdc8dac908ef8397db6b4efabc1ac7cbb14823b198a1ebeb701dd0e56e3505199575349824c907458662478040077c884ebf2fa3f0ccc0b48d16f6d4358a22d65e6e71fbb63bcb6455295b62ccffdd62635860633b2b89f568317b38696fd870d955a411fe4dbbb398f659d85b6413704b4da1b7dfd946f5210a554fef3c2430d1b34db66b91b7920d68b14131031663ede6c2dff68b2df84184cbc0b3e24f9e3d3d5190840d7298374ffd97277bdebadbbb64443003bda022b3dae30ba770591954a7994d546468c253c50cd63696ae2aa16c332e818cd64c66d175f19ad4b6ea818ad691d19b42b35f63b8faa4d6f7b1bcd8c42db5778f23d7533481006ae114f7ebc83352a4b2ba8f306a5807f234d150a506f3cd6c77c161276d9b01f57701ea667209a437490e3e02bb2be0061fdfff0096c1d323b63db80f4306f17779204fff0f9bbbaa7ab8d4c1583e0895f89e56adf4b8d6e4f768ff2f80579e3bba398359beb3ec6931c853b7753b2829b5ba7c3c93e05cf22f1f88551e6deb33919fdf955206cad0ac08a1c9d4b067adcafb71da3fc6b3c7abd50701ccc0cd7bbbfc72b11e246d4020f9b138c76025853aaa4815adbb4c0ec7aaade734493a3d753ec3fa65d727807eb41da643d7beb47836de78a899eef102b21b761b9206408c0511a226de9672377b27d2c6023d2fd7dd696f4b48e8afa093a9a334c3d8e51d29a3ba4e19811514b6573049532b01c83db578e085accf326a7865fb821d25df87c9ea2b60cc755837350444281d2a7e2f8916e16d6a82551f077ec20fa0e7c043d3e2d3e75f599ae5f3175f9d5fe46fa1fda6451779982bdc469c243ccb1b7256f1d41411d0d18bb7792571130e4f983e22cdae731894e38fa890bdd51d55b000d102e6f3928475f265ed6b0d6a10a72fd67eb6c97578bdeec189cba2c717e65b9566833a043733a9317f1608370698f09b90e4ca060a988d2d1dd802172d45cc77489358845c8e5da2062a3d2ead1864b57cefca910a8463bac3e286c16d66de6edf893c5de44101956b58fc21d5df87697ac375adb508c8123f941de8897f52e476aa6fdbbb63aac02031576e8554e3c52a22a4bbe7d85368ddeb4a6eff71aec83ab1fae421f0b817add61ad40efceec0d4c085ca95f1c83f37a14ad7f81585118209c1281c72da70b248d04ece0017eec6c10b9f26f689a1b1bce4230746586fa9e57715a3262f38ff86e035971c92467eaa8e140a14a56c0b527e1c4bbb482e417b7d3d8be5e79c3317fed03b9d78de2037e828ef640583a781506521dfb4fb8acb665ad090735fdfefe1d1d5ef9e713210baa995a63b111639779c809d2cbee5654c2d919be5df30f516aac4c31ba43fe8354dbf3599ae66e9ca9c3462756de58438ae4df163c4617d18858a534ddeacd81cf94ba5da7699d4a08c026c064a4e1ca665c6feb9271282fd60bc0780796907048105cf2b327cd704299fabc239c6f6a7264108b23aa3fa2323f809fc4a73c18d34446affd1bea44e4895e732dc772b1750a7f575d0ad557f9fc67caf88070ac0beab30e9078091f4c82c605c74804272473a3c8b38bcde4c127d57b025edbf5f264897c72719f14aaea9b4ba8e835a9e8224e5747a2a062228733e2a572f6680edf9340b82e8e5e8fc191c36b0b3090d6e60016b7b37f3a66e7e8c14451e96e3a6b8c8414f05fea7dc08ef69e48730c28ce5a929ab6898ad1f8811ebeaa30de19389db556f6b1140e6fe77483491dbd8b75d57182de3694aeafde606321306464fda5146d714ee8873900e4a02fb81d1cf6ffc84e5eb45da187eb74f45f0372b091e15b5a977640bf1b255f8504652e45c6000a539996cc5b274adff6f3b296a410ffa4770378ab89f28cfd2aa731258933e7d06eeb3ec165e90cfb85b2a1188e807a976f2b5029456cadc72dabed6289d1291c05e734f51d1cffb71d66ee1bc21582dceddc7f03164d1fbff467d183777d6b1e6292ec3b79c091086dc445ad126c45ae619b161cbd80072d5617e9be2b6ebf2abd8f138df9834ed6de121770df2bb18aa8227a208fe580e1f","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"3de587488e3e39ac62d6caac8f98734f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
