<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

     <style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
        
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"226efa7c9e5c7dc99da3805260932440a6fdc792aba7c289613ffb42c7fbfb3eb27048c5e6c2eeabcff5a59087bde3ea59dd3c19be426e13cb041aa3d248d39a2984bdfd30ea1d2032aa2b05c1403c660ce261e6c9023d0f82ed4d09372b45d57ad386e374d03d32d6788f43c02df4cb405013a8d85469bdc39e90c41a99085a30c8807443537fc280396c6f7b69abe59bd912c2da635f6d04ded6cef59870516a1a972c423887dc77eb4c2c71ddab4f7a749ea4eaaec2f0247f36ffccff0c07b578f5d009fb859766da11c5e78db6235e67d07aeb7f6c5f24babdf74bbe1089af47b2f0e65154495a8cf79d59e1dee89712c7345e231d5a1126f64af4a783956cea4ad7fc01f895a3ecc90106bcd6a01bfd03db3bdae76c0ca118ab51b33ea84c394cf39644e984d44b6131545c20a370c8f720a4983991c69b9bbaa5b7e182096e40d6c781ba88df1cd6e0eca771f20c3e282c1d4ac353efccbf71e65dc0b2d18e58755841e1da3d935cf8bd647b111d9dbd5a07b969d7fce0c63330bf76aba57c3f9cea6480b042ec99d8ad8f191be6e745ec48a32418db1529f21ff0e15def65a277340ebf951872aa0c2f24bfa5359b9e39c3cd6c9ea6877345c6ffb908628dc629b3690e59b1f927002a14a6cdabe1c39f9205dd040339a51aa725d75c7298d2b98c333498f976a8cf75cbca38ded59a0d38f29d4c6f9ccf532ee93af46113fff5d112e777dcd33fec2ed82d1e3769bd347d03dcbced7f28fc55f063376b953d1e4b7a7174ee8bf752cbcdf30edc16ebe82e5e41e8215b987fdb47f62be56fedc93209d654c03db39a5e02c3bbf0759531be7d225a20d9945071cd59ca5129ff45a00099e014f1d749147a663cf511b07bde9795428c4c395fa3aaed059b1aa453b5a0fbe12deac40d58b9463fff407240dcfa29725fa691cb0a5819e83eb5bff58433acd92e6b28db28c343d7769356898f95e536d8cc6beed62da21f63e5eec1c780b11e32c8ed0ed15f60ddf42662f5fcdea1f5fd4d4a54b9ce1de33e651730c7fde15897db2e510ad2c341c804d23c727f0b60d1973a45b48fe3424a08795942f8e7204339be0cf0d5f5df71972754a847baf85c15bc8af0117b6749dfff52b341ee3c1d3863ab604d171549470629c656c54e2c5b15eb058ed02bb31598de99bee03c3e6341e66851d18e11787068396df1c0e4ebbb29efba7456f3834c3e43b35def2692dec3932b70cdaa9b8b27abcd197ae37aa43b4ff0e4857fa381498c3ef728838e829b050228a2b002aea72c71890bbf44511db0489ea8c9cc913cd2c726c14a6b8eff9f53eb7be7bbec213125916def0a9208fb4b73d4ad8c6ae12c92f646d2b4a9a23443d15360996a493f8f1ecfef24572fd73c7731a93e8875d1eae2d8721fffcfd20a579377ccca2ea138dc630ec3a022bc3201254509d1db3524bee2ffd65d37f466a86d5efe1d9234adf4ef2a5ac78669019f0269cb70d15aecd88f8a2702d4b41ea926242e128fe600181e59c900374d320c7333d8ff6f43e3a5bac65fdbf09766288c6ce40890438ab9616b5b7e9e434540b6d516b9037bf351755a9617799da7a9ef975cd3cfcc2223de27bc821a334119998205695d432f7b947e9ebbe71d72b48041ec3c2d151ab989859157f60310b9f421e5fffb3201001c035fa6d9ea89fc410c03951fec7152b26d4dc1b55f0fded3ad6c8269b21776d6516c3e9fb570b49e6835ac73138a983321708e8ec8436fd8f2e0d917a5c47367b2a7a3c4692777cdd428c6944ad22de1bcc9b173a80c6e74624a8a2760780c70f3f93161fb6a3f46d12960493ff3355d926f720af092bd428dc95b29f48620aad1d4d32dc1e659df972657bbc080f60530cb0e07a6cfa51a07435774081110a2847ecbb79c7d6b245632ce74c32e98e2b60a69ab38788e04b5806fca6e5257de279b399e4aa80f1e936fb97e6eb4dcb8c99c35eb52714c1ce3d6a339a73759f2405fabefd82c455d0cbae755fa2a315d93463b4d1fce38f997d146065f09d0fc3a6ff53a03c821debe1640727469702ced8057ee537bb0ea27bbc029afb24c47691febcd404205a5b70ec7e1f19a8efbdb3b268505a12b7da662d693601d729e3288d23163cdb11291636aadf714b28d7ea4992617f57f16b3577de2d18da36e91d3ba761578324152b514a436e15edc5b842d03d4f128849ddadaece764d70b21a450a9e3da6b1f95ede07a9d3a6874bb385c0ac723bdbeb9f0c4244fac590fc3c139a469f5e313d3a6dd8fe994fd39587aecc1d123571c70876945dfcdbd34d53b5c396a67e404d955c187037990e3047e5ef544a5a459469215a87628c410142a3526f47b58a86e54f6558fff0d21beefa3928a0f05c016da148d66ddd8fcdc1242fe055345037f1253054679c1d884a07d7470c6c0085d00af65fafce1d8664de4a077170ec633f7f4b2e17be14f01e47b9ddd2ca4b3a64d15eebbe6e992ffe5aa9cc332a4d2cae597c01c654cd3985e26fda33ff7a1ac93d6ad78c8b4359a66530652aff20f52adcbbde791524b99dae670039d00878b1ac21f90b2340ec59353c2b2e8c8343d00d9bb3271ea7b5ff3fe6f55aebb8962652cc6a9b31122d8877bdb59f14db6cf8afe039155ce35bd4ebfa581923bd99a44fe4340a388a12b40812e897748ab79052644f991b2fef8acd7723a2909fa32b7c22b3b51f1a2941959159eb7174e289b3e4bb9f9d18ae6017ab6b033d3d84f646d5df92a96e3d004cbeb84fdf4a8918fdb266f377d6ac9869dd2756ceb0d1c50ba2644552d5f53f5becb1a130269aed182948b3cc24f898ca470442d8ebe5172aeea75084098acdfb80e4b9119900ea986e1e533c107a06249dd289fa3b5139fdd620cf6cd02de01690c44d080a19207ff9d5271d66a7d0e7a39367c7a3f1a1f8564e3cfd80cad4422f5b12e187120d9d043f97a9899f0ea150d2a73a207de8a0ec3ca566d7a9486793989f42b806cc6370fe8c6aea3a5487295c78936078172df53ac10d5c580d958a20727f89703a1863e86bb0d0aa773728ce785f167941fd46a66d42f395c04695589002468d0c7bae4dd5e5d846daa389c9ea02cd5dbb068580b4cf7fd86c68f1358b329d1cf0cf895d33201e8a5ddf35be9ce4f5d4880dc695b84ca04b69ec343397ec99729d06e4ec8a215489c1980a38800aa65d1ff38ff86f49c268375c5414806915181d3fa05cb3cdafada623b5c7acc0c9f9703c5c88ec1823a6aff2e1ec3d22f678437c1d34842667703cb3e231f983888466fe2250e948c330224c0d0367235039a0e6aa049ebe5817967f94bd656a9cbcecbd3123d75d131db7f653e60491d44bb60cb7fb82cab97f3b87371986733de886b13291ac3fcb4b4fe903a8f0c450dfe0813a0ed4d94f84453f35500541245ab6085ff580c84cac39418d3f7592d6e5683156a5ef2b1b8ed033a36b302320a70b959f8da1421f7e5aab2b6a0499da9eafe5706fd9b4b6d24259f8cc0452bddc83dc6ffcf617a1b9a7915af4b6b40ddb5d69522c8c7cc4d358df6d6e694a1efc312a2f118edf828426516752bd46e1ad8848e178480301b1ca75e311665ba3ab1f1d9840dacc131438250eb6adce3389cc60bff8bf99d54e4d28b011ffe0d4dec8c0af4d894bc8ab46a81f65ac6e1619f8616ea64ac688cf19236ab7fc29a0277b305145b2e17fc4c1c05b5e5f8fbf6b4a71e8d31e44316b11f2ee61a7ed3ba25e439d6ca4aae698197e09614a9b5d9cae9af2d1ee8e3bf9e1d793a4f3c76255b191eb190d2d0af505a2c85aa975a8ea944ee5aa0b009089166238f2de47b053fd5f939b48c3a638a2caba75d2422ad7cef923b4ad1e65a41e93a7f1c7599eb327ced3fe038dad89bcf38666a4bf121930b5fed6860564a597d671781bc882d8d849f88ce242e5b45a6d5c7823c3a7a677e30b25c9a5906e501e5be316460cd8c0704ad6fc8c9a0b82a5ee46d03aef37ae76d9d82c78a856f62a3f17fdd23b20aa18d208335e0f9b3cef8f50209a6ddb80f8b2321b31f60c844faa8b2271fb1403fc961b1104cc3921e65671d1e236f500ad985c6ecddc18daaf4e878956a805b6f494458a93e0ef9fa90eab51872c78c776d4fe3dd78366104756e2f1cbc49c219cd4c7757b4c7bf1cc55685810cc8c55deb73b5a456a34b4897bc98b7a812b5c2c33a19f368e826a44753051f7fdbf264b84e07eeff571591f5b6d16b5082b964a04b9d31dd8ec01c0d8f4bbe5c16ded89b19b6c41cf56058f96549c8bb39e10aeedb5c273885a1cad6d7d322c1106f8d8b927a9262710f705dc63c2f9792968a4857119f51828dfbec37121de51ac890a246edcfe85a9dc0f06b755db444c59d17fb7b6edb26be417eccccd13f9cc19bd284434c7734993439640079cbead48666f4fa3570e48ea8d6af745f93d7173daae99b8d8948803fe75bc83d1e85150f3cab21dc4aa15c0f937c5ba563bd6b855dda930f806762e3579f60132a0844ddc54eff7cc393052cc0ab7cc957acbad563a6b58e735a8f3e94ae91ea9acddc1f71540767fbfbc28726e592ecf53dfa8e3e87a281bb58b10cf1d401aabd4887165c91d57b474ad4d1fa11cbdebd1d26e7c89e3c61169e4c673f1cb6bd0c0ce90b60f09ee42057eaa0e806612a4d46f200a165b25c03c0d1530b18af6ea90e323ccf2252ad9a995e7bee475923deb6f57f1420d8ca0c5ae31ca3ecccf9c9e354351e45129dcd11da0f70ce2b73d43814c698f09a5a6ff422eb77231ac4ef77354f944656457a650c2eb70d8822e01eba36d46610878451925dc4e98765b5b064668a8a6586d9beaf1a5e185ba7135693bfb3a2d07edbd733947acbedd1f4ddc81cba05b637525dcd544902bd87e91cb04933ba3ad3e6a4a20566897369ad51dd006d6348bf94d6167895c8ca81529f189783309f84ccc56f2e55a337e1f6d1f948848e31830df29384ebff8bb07ef64a41686bd3365c38f564a9902c6d8e07e0f717f7dae07cbe258527e8ba97267673ff125fb31be20c229be35a0b1b36f62601285e87399fb49d7c1dd9ee52aef89e8303c490b0f761619a65d92b7deacb26d0faa3d47d3d1040e6c046e3cfd1fe8d8fe4f1a7a34fa3a1de672eabeca758f9e05f2f629942cef17797459ba1b21082f1d802e77d5c8c344fc12ab733697a6234172fecc9c26215aa50139182846cf69ee864878b80900afdecab0125599f39ae00f59c2ba467c26c27f8792485cc92c4d5457da29a88bfa38f51f3791d9e56b07eb6aec9730ac5d9f94fe85eb2544287495d4596abd8b1e6f229dcd6cb182398df72bed16502bed0a99be06f3a6f2c925769ff1e997bf6f3f26542c09e1c8bfa002972bf153ac155ded20e804f1e6cf0b01076428be77dd6f2be0df4666a6a25f63c70d7fc9612b4197cccd8873cc27e13438bc5e26519d6684b40ec765cafe3d409bcaba43c1adec96c379336b8409dedad89a6b8fe60b53688e9968d569b9048a72567ec8b589f0caaaa20e4ab5496b39aa82fb4f05079f9f8c0ee797056b2664735b7b6582a4ea24dd9171b5aba396b98a4059bc0779b7ea62d2dae4e4f507d57799fb2b373498dd669f78754d5d0d20dd0a91cf8216ef59053c968f3e2b047d480aa8d8b92b3ab0030451f3f9c89cba9a70a10e4c33955421c0ad6eac78d2955f9e819ff0c9e2d5c6d38e6c14e388be744ab487bab4a747ae0d09303e97fcb6de150b8f03348e078a6896825cebe8acd3e9cf1c3f469a9c898da76f521e861feb0a835e3676ab9189d768a319796eeaadd2c2e1c76f963242b48091872af8a9b3538f970405a3c47d4c3871531e82be142aa189d05c4c8aa48b40d91c473daa03d11a890474f5e46268718b7682be26d52a8379e37aa4b93d8974b61ccc4c192ad7c3372d00bf07ab6d694dfe178eab4a505214a3396f0ba2e08e691befdc4944e684dbd0f8a9c36ac0d39df200fa34e13d7e8dfd4d1ada39581690e12df07221c116a2ad60706b48cabec513917c15954c5645375028c7534ee2a117397ebcb914c78dd858ba08929a909b79985c5c8ba6ce33723128edb9917654611c6506f3809d5d2319f2c4c4d03d81f359c4ebe30dd6eed97094b9596872f633d1f1be7a7c74f941ceefbe84830ab5e8e3a3a9cb9e132e9fc49d47d14e542257349eb165ac66e962a7e98add5e554e63a30ce9a6179e0c3d733204bec16565f0325956ba570d90e22ba989d3a2616944ac7fcba421c7198915d2a3c8b574e9280ac3b2583f5d20d07575f9087d856e0dc3513bf036f5b0f62148e9fb58d81d6860d4de6bf3f79ce44764042ffc10cd93fb1953b5001ec113e512905ebf6ed8a3e1d4c9595b6d94526ffb25c5f499b22ba13daf8a6647b0a3e9c332363a2f13ce98a02f6ca3b6d91c925b800dac48dab86fe30c01c82e539e59d2c9fd0b90bebbb1e0ca0bc0e73a5f6557cc24f926c5930392307f06c6f459426608c47e6a6d4d995d616409986fddae4c086a83e5dbbc4cfcd57c55176df19a2214cbbd65ddba1733550127515f41306879e93f8a2d110eaf873c99e246174bfaa21c6c2e488dde9ed0ffc94c5d3628ba2f21e2ee82b62420071c79117585c3f101161542af051a7f8b0350b78f4d10e815314c701414b9c4a940ac857f50290964303fa5439de09681fcfb98ad2a6a2fb992b1766cb8abb4adc87ad3a77e615c1d527b1d7dad60e35935492fda68d11f67c331b8f9e54bc355ee73453b6600b3b2a76983f003eb13221df39926e9440f7e8304a5f9cc1de8069f621c6d73a730de39ce1be2f459749364fc92d80713c4cf16e6276a8e1bd2f2204e298c64b3dd007d84c9f25700d10229a9cb91f2c34e3162013943913988e7643c82a894927efcc2bf628a2b7bccb722cd5b4818694696ca1578d8d130b060870caea7745de26eacc0d8699e658d046da074ad663bd3e35b7ae06c180e13ae37c430ae4fb36aa21d9dc914464889c5797f5ea259cc376763a116a0797726887e4540c7d2f9cf2fbb27d47c4992c2eb79215235d65bb34762f5143e4ba76af8e817a9f6105cda4a01e2e63b67a5b011979626d87d97a2994ec7ef7a4e34c8f56d11e5c02acbf7b8b4da42df76ff0c3e04e4ea442950a20e6134ea115c73eb26bea0a9c6f3f9f3417e66fdd045d4682976d0de1c0cbd937f099236a9c2852537512847aad91c81fad68c07651c30ab6c95806cd448791b92a6da62181ab0984ec1e367e833267bce37c7de6f55b2bfa7862da68bb6f077f0d08c16011a5b788728cacf6f088aae75385602e7638da41eff77b88a5f0d187f88db10a458aa15c4609d2a66c8ab59ef6ff1aabcc250538301dcf5e3c81260b980f71512279d468d0bb787b4ab0691cd67e934020013d1ff21ecec9608a2f2adef51400bcb04a54b4720531ee3d6b2f51be86c1366a6669fd77de2213059df482be5ae38074263950f3a7966f39767fc716c206f6534c7d6aef40914c10c7948609043990304d2ccffddc9876092043dc652a6010e560dddd6c3007060aab92af924ddadc82fbbf9b855ceafc83477d95349d13f10549f1ecbc98c6faeb84c43c87bd098d19987ff143eccaad67d310683f67f509f394be7830e365ebf07266510dc59cbdd7a9f832f89af1fe89d37dcbb002030e13f765e5568839307fc3fb778edbc551801fcf2793aefad97410d3eb45ab56252190b687b0ba58227f72c680ff305d88544147091b6a6ff9f755063fa1dc9b3740da182d92657be84d642635239137e9786c890b139f52dec036e84454c0cb07e40d80eb2936a400b8a73096c24a52e8f169ef8896434c3cbad4130002589208f0160b9e080566331b97b6d8c8514d05ab7ee4f33de39c08ecdd294cf4f6806b40875a8826d43a8f0d19a8dc9fdf6b2a6a691b969eef028f40654d952dc849f0cc54e610b71524da2005b864fad7063a94b51c91e4fef642b06ec2a7915adb67ae5909fad0b548cd984d8684432136fdfc1be319a60688e47780f88393523aa6525c5bca635402e25f2b51b9220b1d7cc4f05e7a0a7a6d96939d846ed764fb2d1a7f4e46d6143f821deb0bc51727ccd30cb440cef8d95e9b6bfc711e55cf816d6b8be172c0eea776fce28c23f7d956e9e2310ca1de5e4ffe7060d991a0efe479d0e5cd61ac4c85fdab5379868309c14973b1e2bb87f7b5bf2ededa163f899093dc8345bb8e0973875d834e8dd5e6cfdce7a41b47e3c3aea84a253a842082401f0a79aa1e9275f7cda24907ed931d43088d045abd8e4497b9f7f9f11d632621b6bce63434c51446e369cf46c94c41e42a38eff5351913a677a156cffc7b6cc2ab5a8b1797136688a3da73bbeda1bc141918531596822dc07e8ac301efc877c6c589b109b692f76af5c17970e51c62ff46cd4e9404632ce61822546a57bc32bc761da6800d41a1eba8c9275a3d63dc2ba02beb2f5200b32833bfbc0b457f1cff4efc38216e4a23510c1ea2fc95cbb581a5143e3fed870d3d25b06512cb76d2471d7de44b395a2fbc47d51f5767cae97f8f163f39ed677aa3398dee33531aed947d79689f564ded7cbbf26783fc9634cb25e2feca255d8d10435f5d04c3e14e52a4b3c3bc6131e5208199ac6865f4fad42ecf4c45516e381144703ba5955fc337e16aa94257bb5b3c592640e3273a3f71e9108921710175bd9d92b93af4faa962dca22f5baac05da75a5fe93efc60af80087417b02fe850a59ea893735ea3c91fec569e70cbc47372af9d3a6251a8e65d9c8d1f2b6240a71b7cb5ed410756dac6a2f42e9a804846c1223649dfb9667395cd121e2ad1a5a354295c3f19a241ea0b45bdeb797cbb65aec351dabd77dbd7ab16a163e39715b9987e9ee9cc1e4215f5758b7b550e7ed3760ebab82b2e25f567f14d4db24c5667075b6682486356d33d3c6bf0187f78d2cb11ddfcc580c945dcbcc7859591f2b699b3267a100db59350d60cd66e81f0523a625de834b549d239ea507ce187651213a9f4d03f0ed322100ff53780e16782947031477aa4d0e64d5e5278775059d0be710cb3252ae22c83b15fc9ceae4c4b2dd2fec06f5e878e5bfc9e8276b1a59e3a6c09f5c1bfbb4fec501bd7ba4ae80448d0291361787cbc5d91b54a07eab96a5bf72986cfce45c90d3a2d16dc716049da81728daae12b8fbef310f71ea7b6dc668e72420906a6bd87325455bef06d27e06ddafa39e0060f617b9f6d527af2c985004a0a3ba2f7964edc22ce5f83306089002a20554e5a988bf922e0e4508b8d40440a1584b79988ed02158090b7f467a70fa5e7271f889d2a84c7e02141ec27c3ae4458de5284d3a638a7df657e0c3ae5c9b0236f6a0d38d7555f262428664dc7b032bb578d5602be9916665d18eaf47e846bbef8063e93f0e42add84a4969db5ec2f18f560ab49a3c27f5de369cb7d71d6d0c075529052267552a3e5c196a6da18eaa04f5e9b7b699011b476df3bfc22716fa7e1708583a4622c154081fdfdf22c65b6753f492032d7582316646b348e6d975ace1dce1293583b34a97cff2aac88b72410e0513f1b351263c24a51ac5a369e77fb94d0524be133014e3a040dd3545062c6edda2c32eadf682b8b5be42336d3daace89de1c95193d7d9ea78c7a6e3c98e0b4e8fe25750ee0e17e545affe94186c00797858244e5801e836fbdeefa86f913afa48a48be7189b965b828116bf3577d4360f7da3ce4ae2f326d66d7eedc64bdef5a21e6e8b58a64e39a1fb523510c0991c336bb6e1537cd564433477c6d8009fb675389f4945b006fe5d1c6d9e6a80d356f24d9d96bb3ff5b2bff157bac26417621cb061c952cfc99cea33b5f3ba1f726031d92b6c64d7b48c4fb2b1e1260616eb8c324c936f7bdad6e67c7f06549f0915bedfffcf5af5cb3dd93607e761ff449113f50184fd53d7f7b0f27a9e0150723f29e297045e37cbb2f5ef74020585a65138889413fb2e7c21e1c69158acbf0984711023ba02599b6d86426ca4b9550930dda657e14972e86e0d2a376376951e11afd709b99836df4f733ef8e2109c39a42ec5ac93870966bb421a75efb35e5f33a152e57200c9fbb2a9a7d0c8d892bc46c5c8b0c93425b952c8ddcb9b8d8bde565cde34dc621c8eebdfef62d9ba173baae5c174bf1d2b7fc5b01986ab14beb052ff88bb757e35f03d80f7a9e19b7c23dbab1ed45e863d3663cea78fa9bf4f618b3073f724175441af3adcc91639c8c2cada1e3221c0dfd74803ea6bed659858ef7670e24201e9d49032b9113b1b78e2a5ca4ff0f83dfe6ad8bd27c08820199cb21e43fdd322b608934eb1c639827d8f77d13fa9447dcceef34b27173f27b035682b09434a4f6d4cb51372c47710007a95e76342fd16ea652a37f7734ee9b6a8a2f5aed2f1a5c65363194582d1a658fbf0d98180a705324916e9085fa57bd6fa73a75c77749ee70d746bb54f9d415fd1d06aff273aaf7f3b521e0e6ee935249e80c8b9bdc348dad03469b9edf10b0971d260a545ce7c3ad21ad548b56f0d3e138d6b7a5427489ecf79033722a7012639e6428b5c64ab1390fa3002afd569468cc0e8e8e8a05893aef9b199d51c02cd7bee7b07cac69f63acacd111a57bcb533400134068c88386eb07853b5a516abe958f079224131d1541345f7a511f1d5ae9b7e95cd8707ac5d66b48e3b02cee756592ace6ae9805a0930eb5a12890e93da947e73cfbdc863fe71f2f91236f31e22f44207fa1e2ba6554a2b280b9bdcf178d7ed0cfe91488337219b1097308701b38e87e7b8924780c5f09a52f81e9a20e73028818f27aaa32c0f86f7668db441d6a07d49b81d28755de53ca457ae5352c68426de162a877f52ec3eafa9cc77bc4fcb8ce572e692bc87cb0853b62dbbbb49a496d4a174e167af6e4ac3637a08cd4617a1417b23cc6da8ce9993b61e601440efcaa2ea306a0b7238f682717ce598acc15ad4d607c2f5e4b5541ca9907e91ed42a0abc1728583c9a83a0db04762af70efa8fea37b072cc946ff828222f26b9bbfcbe0db1a73fa31795178e73b3184321e93c1a53346722caa09362810e2d8fbe75480a0a30a62bb40d50be92c22f7a691e8d0b2e922c7a7533b4f92e0e13dd8dc4012a72760f8a2e25170afecffd6176a23623d1443216c6edbb4ea8d28cc5c8010e097cfa7cfc17a78a17b9790820ec19fb22a8ab250240e19924203af4d0145188a052c011748296c8f84e174b1779ca1b55a009fb26e23c1a02ecb498febfde19ede5c33c33b2b88efe58c8da9f472443705b61d725bd28ab8b1abde147f65d1d68f7b72b50be677e38b6f1d5000c8c06894041bb669cff4ab1f012786021a7ac5aa22cca7b40677db9ff03acd4c5580daa1efe0747512bc2ac8b64ab95b69dedec4883266e6b4bda0045b8ccbd03c7cac9029415c67dd24de178b22baab086bd8ba57e74d7d16bb16c403391b1593b2cde08d1ba1cbd6b19027eacca9dfc53a219910e05f2fa5c914a98e96aadbc74609f06c33243748a4bc9b0d2d7a8a03e9e8348dfd1ed077d3ab9de39d6a88a6cef728697d68048ab7c83658e9ea2c265f37a56e5e279863d57b5aee526cf17bdb4ed5b9494c06d20a5e8af56e27d1252eb982a2564226c1bbec498ee08d0388404d0056d2ce821d99c31ee05ce58463bb6ba7177d0c874530f0698696a4f17096b03894acaa7c70e497bdbe3e0ad48f51c66dfca3286a17e324fd06ff64d49b55cfb7b13f4c16a2530d07e9fc0ce6978266ec5dc9c9e92a74e56ca8c14bcebc2975427dd48550fde278133cbd7507503c73d45a817273f17f1b9a3e8c1c14d11921caf5d9ed1bb6dc9e4b145392c023578436744511252757fa79f8d80a896336764f8b8ffad31d32c617654ce8a391fab907d330cd69f11d8ed2833f3b6341533545d3b66a0866787f4f8875a54d5656de133b32e6d2ef0032ba5beabe41e3757e4a17c67e2f4453a8685410dac24bebbf64146460688289ae9c93fd628833a0bcfb7e107aed43aef3b77bf55f4a445ce94464f17907776f9a7e68a3ab347a92caa94fbe170a91e0f8c208d630a5798d329eff80b2483cabd40ccfb45283a2abad0de417ed65ca7773a2aeee62f7733023b63d9ccae951529fb274e1701237feb7e5dbd0ac632d2634bc5f9a7389c64056f9b94a0f432d39c04a8f0234db8ba021961d45211027bd17997aa7aae5c599e7cf079f8efe373308937e68b16dd810d00071d3d1468724bbdf4398430354875227595b9946af2b7bc2df7f5754b3d65979e5921f60903a943e38107ca906d604e0615fc01beed25ee1ee51e7ab765d45b1e1a1f271fa40892131a644ab7b84265c3dd0eca2c6c2274e03ce031f736919de6dadf0a981b031ebba5cacbf133101a3c1cdd4ad8865e37ac634b80841c93f170f789b90a831706c3b096de8ddae5585d0cf20ab8a9b74541cd44951aa1b5e6fccd0dcd43540c510a13a47ee73ed2353a9f45f07073b64ba64174f296928223a12556fa25baf47aaaf3b42206004fe54b0d42fecb29bc38dd0af66b7b544e3031d70b0cf2407d335f9e290e2e3a4299bf60f592a5f4beb93dd15bb42a8de550846d1e41598af25cbd8b46d3e4f8754a534412ca2bbe91659c86a7bcd312a674e0870a2734fc6abd3d207e2877b526d425a789ae9b60b2e05cfa290575aea414390bbb8e7a2371d89dbaf22340139abc1f552218ec4d909bc406dc39747b8acec2108959233afa17a1d4b0035d9fe7808072e9055d1a7587348705f0a1cd18baa25004dde27c45fd139e1504b2697b26b8c0c8220a923c9709034fe242ec6ed48588f723a87cafc0ded9b098b063d78ff13fd64bc999eafe1b9569b23d1d5f4ce097e11c5b9d7e683c312b6761d15ded187c805a315d480a5ca003dde31939e93f0137cf11477f8c1190d47e9191d1997e86a2af2d4abd7dd38b17e6bc81616cc9185406e08407c3abe8b201c68e0100ba802934af45b113886c44760e45aa13d79634465cddc105d303ba6dcd397ae206e32e6e1e3f99bf2e2af2198852b2c44af963d2d0ddad166a47ddbbbc2ee8f400b00f945d7b8191b0d1968ffea105e72bb22a87f960cb8543b9ca1245ea674201c43a1d72b24b7a4dd4d265577b4253eeda4cda2003c4a625870f4de1f8ea86bfb5a93659d553599d61fb9bb7f67bcc0dabd05a1301b5894fa0de6a05d7b85a23b4f6607d09b8872d5d936e6852360389e2dca2ce8403f64a203e5126998db2587672187d5df0a312f1d0c3954966c7e1f7163900c61a2b5dc3363f5f34515b261e53990b14fc1f1aff361696b5aa85c317b6d58d45e5799ec57b7d872f300d0e42376fa68b66a02b42a56a2f81af0f291617898a23ea6f3195a613fd66d3ef9c83d78f3f25a926a43273e188573ac6d146255190d4eb6e4a97302c1d194754add03e1963f501df5f7f4bb4d7c0d16b6b612037e346af7a7d38f6952b0c46b96ba0417580246babb5108d030f02502e76e3f4fad0b01d127d604ee641d10044da4440b5d385561f1bc2a48aaf072d0c195566ba4dbd4c366817378179bc6ceab24a58638b13a8e42ecee0135bac6bb61340d7a5d31d264aefa5a533887944d8b9469220341e6ccf77a3529a423aa2e16922feb3ea3a86fb6a2b400322a4128d837862f05ef42e9574d1231f4400381015c5566c97a4dd670489f09b8e3e094e93a2bc005899a6f336241c4a13011a5ab0344a175dc07c918e78776bf219db5c632b6cdce60471976f00ea3cccbf75f57165c28d90b02c22990277e8c289ba7da6e86562a39e164cdb5696ad70d17a5bcb631abd73859c67d9650f340141561236dcf95519a8de6a15ea74c990a2ffb46b964f05c7c5774f1c1c689891ae4a82fa4bbe0a8d8073ca26781351d2656b5235ee8313e4a11ae988187b793ce58892bfc18a6349dc0122dd4192d3d4c28eaf0eb0173612683291b5276ae3142806c691f4771c0dfcebb7e077e858bcf5605a35131883475c917232b53b53e302a07a83de2bea2e166da80043c512aaf188955f2a87890c6785eca1491b3df461af347e923551c417328e7da181b3bea1c6aaad959f96b2ef41a08e0f72386bfdf64341b26a86d333859acadfffe1af7516582cd0c806ffbc5f7686032a02f95eda0b36402d238d0039918bb93e362068790f3dcea66f652a21033c22d6640988a8d83a8f7da33c2c17451b87de4e3c3b69e87e9c13823366d1f96a876947a58412eb2e9c62c3118b3d3bb0799937ead53095646b3c3260569d5d82b0668b18489cbe62caee2e99a99332f4e6c2eb51e07700c874c2eb8041cb09557af045cd5d36d285fbf7117ef7e3b35ef63444139a9e9a9546bb1008e27a1db9946968b4515a695eb782a498770aa5bce63aa1a22f0e935516f3cc794809e3b8b69b18cb77cd7d00081b5e9da59764c17e112be8b466a647484ffb7a67a1c738b3d942b06d0422ccd1418a1adadad5cb0948b93299c7b0589be4e92d5353f7e38d84528cba0bd965f0199c6418b99996bedd75d09946dc5730b39ca300880c73748ed19e2fb0528106870172293d1711ded46c2342276d46337316c9dd7406457d7d07bec0876283a26484ff36fd00837911dfaad5fe4aa1c238d6bc1335b8e4826be6738845bee7fa226e6209e66fd34ac13d25bb6a72015f2de6d25ef4f08b20e174a5743ffdaf0c30d0d30be92e5ef86e81e91b23cd5b0d4d2eb2fb900d99daa750a63e5c95b687172443b5c05524a7d1f1412921a0c3b8a27638774b18387a34730b204ef7fc97cf824894a4640a08858a06db6fcbb0e92b9e45b8c501816c4d74f8af2452ab0677daa8d2fa0dbbee4af8bf76a40fd2d563978de7cfe357789a1b9e3171ceb3cb4f203fe59b2c504532a881df54f5fbe12dc5774730c765075e021f13dd1aa078550a2f8b40745eb186de19c3d840a03a37fc9e59d122f15092d8c2e74aeef772bb2e24d50a781e1fd38160fe6281f2d88aaf403639733efced61131a1a6772e931ca20c04ddf80b701eadafa47b907cec36cfa0d25e63279f79bc3eba476c7e24ac0ac320bbd8a6bc008bab63cb7cde1242d616ec0e18d7f6945b94764ed60d2e90ae03240dad5d0d7b532f116f85ee08e5740c40284f128744332a5e99af5f51242feb9e849c7146c535ced91c2d4a0e3084e4117fe27bc33d33eb75663eddc7aa59b84d5f8433b9dc1d9f3d92776dc1c79b0f72820620de6290d4bc97637a1397ac57936660ee6b9272e9660b761406713b7fa01638fdfa59f5d1a98100c3092a67368f87f7b036eb52039cd1f3f5975f82b5cd4f6a58490b318c1c515b36a1b4f38ae075ee0a68b0bb94dc9454cf06604dfc4d81fedea6731b086c442bbdf73cb8a40b5319bd8417f6b70b48582f0d92d6e2edc70c4c0cb0bc7b48f0372c9d53e7b1442c2efa9a6816c871c785cf74b6e95d9c3c79c78cb9c77d78d2212b4c38ff7758e36a5d0405bad43efc128913c74f1058ec586d51fc3b211afad1de4ccb4ef8f7d6a1df19012ae8f5fb41e0acc60e058fa679578d1166c5f6b5570ddb17db4bc4fcd25ee64af138cc52ae69c4355b500c0d1b87bf27795218cb3bbb0061ecc73d2cb7e333a68d5e498ef47b8d5cfbcc0ecc48c928516d90264202ebbaab24d10dc5475f51cc5abf574177b18f686f6eea4737ebdb57fcc93da6827b00aa75b1ebc63984f93fa8ae47b422811cfa118c3d06a907c82176264d25fe64b5cd3369ccabd71fd7bd8df285cae8fe20a354c128e02b5fe4472aa558b60f6317ecc5471edf0025b7b53d0489ee648061022ea86911d39b060aed0c8d110d4d86cd34df0be0bd030a55021ff0c6c85653ed8b92ed188b391640c076c12f9c63589b7a4f801aec273eaa22f1c5f32748156d56840d2b2027afc39e41992abb18858c5373e74f33fe306985d25f4e971010e5798f9b1872a8834cec9466be7289d7432f1dc81143ee21344d61e180120eeb645f2dc1b696763fd24a93d840a1ff58f4d305fba1693e001806c956d51daa700c0a3d28776106d43f12f90c30eef90633911849e2fcad6b98565745289d60b2b653c2d849fc0e8b462484462478867d418ca2fbe5d85d259b4df6e56e3eea4b1fb618a0699a912cf3b9e001c3da2f87c9b9875d2e47ab183cf5e2826bdef2fd12316e210d8e3f16e67e92fbecf18661411187a851e97787ee475915cbe0c985fcb9f3eeb8d838d2fda92168fe67bdd763c5df0caac410ad8cef0b3d44aec1028ecfdf76117bda256ea3019c01346e15a2824412151bf36a299f1d9232a5b36bc5874abeab8f35cceeb977d4f82bcb4b679fe9fc831734caef2a445254ca12c7f51452dbfaf38d86dca4fd89f278b42c0fb083bb91e9af07bd995bffb0617c7ccbae15e7fd8b53805e4f86256faeac647b330e5594b90e7cd158b3aebd1391c38d6ff61d4459b13e856c09928dc997033e60f88f2ef11f6290f66eed45c31b12e12f9bc3a87f58b9feebca8a42ecb23411cdc400802dfc65d2f77c4fed545a316e59521900457ea579240c0f99918973574ca6ac953de41f02ffaae7120141ec2ddc69878650d6d7577513dee6a315084e7921947fb57a4179597692ab8b675f0ce583f41a4e2a1ce7ee24707d0b7723efb4497466006df18aeaee5708c4f3718e46abc1101c7000f8e3145839470a79793a847a060885e8f037d85862db15a145276f41a09527184e89e3d472e1d00845fa0a32edd1b4c404f2f2ac6a28c79b7165193098c39bb5355531ebf3e42806b40a96cda8ab72225165e9537bddb7b55d78acbfd8cf3390526103907c7da48f72196b4d3a57cb2f117d9d5d04a06d1b09cb8c40620330770ae4e61f286eb12a07e3f66fe04679e7f057ec58b869dcf8e66ce42f4b6b533aba74753eefe255e3d3a22ea4c0db94c4faadb03f3173d4908c75aab34228d6b40a4e2b5325fd261622ef5ab27ccc8c2adfb7df08111d8f2c83bedae5782e0e4f4a39e8062f7a0771d41b86ca1726a3b7979390224d5831caccb2198d22a99a345056881942825c6c08b57d8898f6e0579628bb5c2e0f06d8de90c363e58c0d88ca30cbb0a1e773ac2753e5c2ecb27ab13a597afc80ab8fcd5f96f453b55697ca906d833d848cc666efe75f5df0d764914577d974534886f552088d5e0a5da9d4e3e91d73e392849beb475446a4b4ce6b8e6794ec1aca32cf7733337f38b213454c45ffd84f1cc11636e8ddb4c13820c5ad97a2bd27470eb17ab9a5b6f149367a374fe5b11c2846d430f4d837128109d56c9402dc9fd243bfc6cd91808e3c9bc5c1d3d9785f0d441946d458430ed06bfb8558ae468a5509285f0bde57cae70f75c57cf153210026ae9a883498ca70d23e1142b860473eda2749ad302114c8cc181838f6d09608cccdfc5ac0f8c968d30573bc29b47c1ff9e4607d5ffaafe223bafe3ba846402ca51958b371e07c927ce8c3a22bf9e6ddd65edd5619beb0c0dfc5783998aa2d59e4e52ed0d8878fe13947a06f9fa8d6d66c6dd085cb59d9a6ff89a71243f81c9e2e89ca569c4726c08166e3083a38dadd476be659ab584720f90929387fcfb53d4825236c7319960c15620d5b0b8cd7a70139b47fd2b34534aa22123cf29a532753a3708dadd484c6ff29001e3492d5fc16ab211edaeaa67495158471600d99428053ca22073d5f5bdee69d74f06570de3a2484d82732a035c310fb42b64a1b670ddcc48cef91c4cffdc6e322aa22f15c0210bea0e738182fb8c73d5a7b2ec063268f92f2c2db9988a20531e49cca97023f7a90c620b4f846a11e1d08c983a5b9c3ab797efb9621c1765998d63012e28a49ff277cbb66e64689a68d21645f561db9cfa2aad1a705c52df36e3a4a6c6594d1ef9ab32058af6e914b3d2180af7ab406095e819fcde96cb77fca331faee41fd0dca909c77024ad42766d046cbcc403884d3d5a050594bf43b3424bea91166180165b24be157cef3118303ecfa23895aa0eea078b4be48294b8fc986041bd4c95aaaee05dadad78052d6fa42dde8869e021a3162c7d7a539d949c7b1699603f82e9d36ec1054ccd0e616928043fee58898b67043d559d7c806a4316da07aff768354eb443ac7fccf3bb6295280308ac891c9a2c8e2f1e3edb4fd94bf487a1fb0a07c8ba99fdb23497fb58f0a83ef045dbdcf04c5d7eb60ef0a27a0da04a64aa764be6078d5ad70d7428f43eb38f521e473623d31094c517d1083aea5472ba702f2dfe6fd317fdda23cf6137531e891c3ef30badacbbc121482327c6611b0e99598fd2393f79a62bef3536ad879295c22e267f46f58deb0da25d4027763bf1fa02190e2bb123f39faa2add7c8b323899f02488de466c757eab3a42977a38e7fba217ac5252cd4b9a75e5c26d443ddcbd7348680fc1901a74417dd3ccc96ee0d8395986abbb9109a378f75279d51091401a5222b2defcdb932d797c130cdbc5fe38b84516ddd9ac803f58dfedc6f0e0f2807bd86d298231c5d05d5675f65db70aee6dc005c4b9aea42d3bbbade078a8b84576f800007083df0f415f8968bd2480f6c717f7d00730df46c58401c6729725b112e48fc8a309efa06752e84974eb4fdde172c6806a168d55cf1788ddb63dd12c9a3b62d9fbf75d01165d4cf740a651b9e1adc99b29bba6d87442f7fb7ab95034b469a503f4949adda55dd060c17cbacfc466495e6badb43b3c87b675be8a56e95073e4f55c35ad921800be9ab96bead2a62bad2c16738a5bede0e273239cc4259df41147da36bb9308ea1a8dce8a88ccd5e0627a9bf72ec14641df173b653807af5b56886bd768df5c781c83cc4b392f9b7dd8e4c4a83b731a8ba0388da46aae7347acb2210f647e39997d704ff3655f3703c08031d738a0af88e8681f873caa41c03db39a331efa03ae6289913ac9736b73f0cc2a9e3381a978b2db81e3f06e3248e3e2fd0c9e394f658c2fbdeb4fd13f8958919c32bd35752d68fd1e87c98ca21e7824eeea7d0f5357593508ca276f20690a5bbb300ef84c157b0b5f1857200be82495ea71d341e91709e712c36a9dfaa735ea890ce2128bdcac6999026d2285d62f1820330d0f915d3dce95f19015442f4ea9c4d16a1d2a2befc963a6c2dd93f4029aeabc0dad2da4ede03826a067880ea421d833cd93d406d34c431e01e9518557b7deede1a248784c92b649a1b41c42964af1d7d29041ea889f72a68a9ac32954c7b7ccc7053dbbfef60cfcd71e707db4941d70507abcc834cb9e786a16adfc13ac0579403ba94034e96dc8d2e37640898cf9cec43e4c26102d92a53874c6af2a468ce0469d61cf7f8b2a5720256d58002f295ce075cfc614ef5afe86aa0c910b8e0939d7cd229cec279888a3dee7c9cc5972a98a4a4a16e2dc9ce6acee902c2ef5083991975656b7bc44e9c7b301f50824483ecf01753a9a47d28e0f7ac18eb1c7c449d59c745d344ff547344b58fb5728709993dec6b4cfc5338f07b07f4a552a14dd3443cbdc0b7046c9b5f4a281f73eac3ec507408f14288890039837ab5356aaddbe40ef13deef8456d5e435f4a3d3ec6ea5b5ed269357887d1e85dc92b676c6a67b3d19b08a1981219b2fdaa0531691857afb78670998bb1bca231964f006506bfd9b56e7ed2145e3adbdc","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"6caceec87eaf11b211cbad448db9cde9"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
