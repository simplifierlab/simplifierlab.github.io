<!DOCTYPE html>
<html class="staticrypt-html">
	<head>
		<meta charset="utf-8" />
		<title>ðŸ”’</title>
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<!-- do not cache this page -->
		<meta http-equiv="cache-control" content="max-age=0" />
		<meta http-equiv="cache-control" content="no-cache" />
		<meta http-equiv="expires" content="0" />
		<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
		<meta http-equiv="pragma" content="no-cache" />

		<style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #f2f2f2;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
					0 5px 5px 0 rgba(0, 0, 0, 0.24);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 1px solid #212b36;
				border-radius: 3px;
				margin: 0 0 8px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica,
					Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji';
				/* text-transform: uppercase; */
				outline: 0;
				background: #212b36;
				border-radius: 3px;
				width: 100%;
				border: 0;
                margin-top: 24px;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #f7f7fe;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica,
					Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji';
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
                font-size: 13px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.5);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
	</head>

	<body class="staticrypt-body">
		<div id="staticrypt_loading" class="staticrypt-spinner-container">
			<div class="staticrypt-spinner"></div>
		</div>

		<div id="staticrypt_content" class="staticrypt-content hidden">
			<div class="staticrypt-page">
				<div class="staticrypt-form">
					<div class="staticrypt-instructions">
						<p class="staticrypt-title">ðŸ”’</p>
						<p></p>
					</div>

					<hr class="staticrypt-hr" />

					<form id="staticrypt-form" action="#" method="post">
						<input
							id="staticrypt-password"
							type="password"
							name="password"
							placeholder="Password"
                            autocomplete='off'
							autofocus
						/>

						<label
							id="staticrypt-remember-label"
							class="staticrypt-remember hidden"
						>
							<input id="staticrypt-remember" type="checkbox" name="remember" />
							Remember me
						</label>

						<input
							type="submit"
							class="staticrypt-decrypt-button"
							value="Unlock"
						/>
					</form>
				</div>
			</div>
		</div>

		<script>
			// these variables will be filled when generating the file - the template format is 'variable_name'
			const staticryptInitiator = (function () {
				const exports = {};
				const cryptoEngine = (function () {
					const exports = {};
					const { subtle } = crypto;

					const IV_BITS = 16 * 8;
					const HEX_BITS = 4;
					const ENCRYPTION_ALGO = 'AES-CBC';

					/**
					 * Translates between utf8 encoded hexadecimal strings
					 * and Uint8Array bytes.
					 */
					const HexEncoder = {
						/**
						 * hex string -> bytes
						 * @param {string} hexString
						 * @returns {Uint8Array}
						 */
						parse: function (hexString) {
							if (hexString.length % 2 !== 0) throw 'Invalid hexString';
							const arrayBuffer = new Uint8Array(hexString.length / 2);

							for (let i = 0; i < hexString.length; i += 2) {
								const byteValue = parseInt(hexString.substring(i, i + 2), 16);
								if (isNaN(byteValue)) {
									throw 'Invalid hexString';
								}
								arrayBuffer[i / 2] = byteValue;
							}
							return arrayBuffer;
						},

						/**
						 * bytes -> hex string
						 * @param {Uint8Array} bytes
						 * @returns {string}
						 */
						stringify: function (bytes) {
							const hexBytes = [];

							for (let i = 0; i < bytes.length; ++i) {
								let byteString = bytes[i].toString(16);
								if (byteString.length < 2) {
									byteString = '0' + byteString;
								}
								hexBytes.push(byteString);
							}
							return hexBytes.join('');
						},
					};

					/**
					 * Translates between utf8 strings and Uint8Array bytes.
					 */
					const UTF8Encoder = {
						parse: function (str) {
							return new TextEncoder().encode(str);
						},

						stringify: function (bytes) {
							return new TextDecoder().decode(bytes);
						},
					};

					/**
					 * Salt and encrypt a msg with a password.
					 */
					async function encrypt(msg, hashedPassword) {
						// Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
						// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
						const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

						const key = await subtle.importKey(
							'raw',
							HexEncoder.parse(hashedPassword),
							ENCRYPTION_ALGO,
							false,
							['encrypt']
						);

						const encrypted = await subtle.encrypt(
							{
								name: ENCRYPTION_ALGO,
								iv: iv,
							},
							key,
							UTF8Encoder.parse(msg)
						);

						// iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
						return (
							HexEncoder.stringify(iv) +
							HexEncoder.stringify(new Uint8Array(encrypted))
						);
					}
					exports.encrypt = encrypt;

					/**
					 * Decrypt a salted msg using a password.
					 *
					 * @param {string} encryptedMsg
					 * @param {string} hashedPassword
					 * @returns {Promise<string>}
					 */
					async function decrypt(encryptedMsg, hashedPassword) {
						const ivLength = IV_BITS / HEX_BITS;
						const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
						const encrypted = encryptedMsg.substring(ivLength);

						const key = await subtle.importKey(
							'raw',
							HexEncoder.parse(hashedPassword),
							ENCRYPTION_ALGO,
							false,
							['decrypt']
						);

						const outBuffer = await subtle.decrypt(
							{
								name: ENCRYPTION_ALGO,
								iv: iv,
							},
							key,
							HexEncoder.parse(encrypted)
						);

						return UTF8Encoder.stringify(new Uint8Array(outBuffer));
					}
					exports.decrypt = decrypt;

					/**
					 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
					 *
					 * @param {string} password
					 * @param {string} salt
					 * @returns {Promise<string>}
					 */
					async function hashPassword(password, salt) {
						// we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
						// iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
						let hashedPassword = await hashLegacyRound(password, salt);

						hashedPassword = await hashSecondRound(hashedPassword, salt);

						return hashThirdRound(hashedPassword, salt);
					}
					exports.hashPassword = hashPassword;

					/**
					 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
					 * compatibility.
					 *
					 * @param {string} password
					 * @param {string} salt
					 * @returns {Promise<string>}
					 */
					function hashLegacyRound(password, salt) {
						return pbkdf2(password, salt, 1000, 'SHA-1');
					}
					exports.hashLegacyRound = hashLegacyRound;

					/**
					 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
					 * remember-me/autodecrypt links, we need to support going from that to more iterations.
					 *
					 * @param hashedPassword
					 * @param salt
					 * @returns {Promise<string>}
					 */
					function hashSecondRound(hashedPassword, salt) {
						return pbkdf2(hashedPassword, salt, 14000, 'SHA-256');
					}
					exports.hashSecondRound = hashSecondRound;

					/**
					 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
					 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
					 *
					 * @param hashedPassword
					 * @param salt
					 * @returns {Promise<string>}
					 */
					function hashThirdRound(hashedPassword, salt) {
						return pbkdf2(hashedPassword, salt, 585000, 'SHA-256');
					}
					exports.hashThirdRound = hashThirdRound;

					/**
					 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
					 *
					 * @param {string} password
					 * @param {string} salt
					 * @param {int} iterations
					 * @param {string} hashAlgorithm
					 * @returns {Promise<string>}
					 */
					async function pbkdf2(password, salt, iterations, hashAlgorithm) {
						const key = await subtle.importKey(
							'raw',
							UTF8Encoder.parse(password),
							'PBKDF2',
							false,
							['deriveBits']
						);

						const keyBytes = await subtle.deriveBits(
							{
								name: 'PBKDF2',
								hash: hashAlgorithm,
								iterations,
								salt: UTF8Encoder.parse(salt),
							},
							key,
							256
						);

						return HexEncoder.stringify(new Uint8Array(keyBytes));
					}

					function generateRandomSalt() {
						const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

						return HexEncoder.stringify(new Uint8Array(bytes));
					}
					exports.generateRandomSalt = generateRandomSalt;

					async function signMessage(hashedPassword, message) {
						const key = await subtle.importKey(
							'raw',
							HexEncoder.parse(hashedPassword),
							{
								name: 'HMAC',
								hash: 'SHA-256',
							},
							false,
							['sign']
						);
						const signature = await subtle.sign(
							'HMAC',
							key,
							UTF8Encoder.parse(message)
						);

						return HexEncoder.stringify(new Uint8Array(signature));
					}
					exports.signMessage = signMessage;

					function getRandomAlphanum() {
						const possibleCharacters =
							'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

						let byteArray;
						let parsedInt;

						// Keep generating new random bytes until we get a value that falls
						// within a range that can be evenly divided by possibleCharacters.length
						do {
							byteArray = crypto.getRandomValues(new Uint8Array(1));
							// extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
							parsedInt = byteArray[0] & 0xff;
						} while (parsedInt >= 256 - (256 % possibleCharacters.length));

						// Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
						const randomIndex = parsedInt % possibleCharacters.length;

						return possibleCharacters[randomIndex];
					}

					/**
					 * Generate a random string of a given length.
					 *
					 * @param {int} length
					 * @returns {string}
					 */
					function generateRandomString(length) {
						let randomString = '';

						for (let i = 0; i < length; i++) {
							randomString += getRandomAlphanum();
						}

						return randomString;
					}
					exports.generateRandomString = generateRandomString;

					return exports;
				})();
				const codec = (function () {
					const exports = {};
					/**
					 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
					 *
					 * @param cryptoEngine - the engine to use for encryption / decryption
					 */
					function init(cryptoEngine) {
						const exports = {};

						/**
						 * Top-level function for encoding a message.
						 * Includes password hashing, encryption, and signing.
						 *
						 * @param {string} msg
						 * @param {string} password
						 * @param {string} salt
						 *
						 * @returns {string} The encoded text
						 */
						async function encode(msg, password, salt) {
							const hashedPassword = await cryptoEngine.hashPassword(
								password,
								salt
							);

							const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

							// we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
							// it in localStorage safely, we don't use the clear text password)
							const hmac = await cryptoEngine.signMessage(
								hashedPassword,
								encrypted
							);

							return hmac + encrypted;
						}
						exports.encode = encode;

						/**
						 * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
						 * we don't need to hash the password multiple times.
						 *
						 * @param {string} msg
						 * @param {string} hashedPassword
						 *
						 * @returns {string} The encoded text
						 */
						async function encodeWithHashedPassword(msg, hashedPassword) {
							const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

							// we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
							// it in localStorage safely, we don't use the clear text password)
							const hmac = await cryptoEngine.signMessage(
								hashedPassword,
								encrypted
							);

							return hmac + encrypted;
						}
						exports.encodeWithHashedPassword = encodeWithHashedPassword;

						/**
						 * Top-level function for decoding a message.
						 * Includes signature check and decryption.
						 *
						 * @param {string} signedMsg
						 * @param {string} hashedPassword
						 * @param {string} salt
						 * @param {int} backwardCompatibleAttempt
						 * @param {string} originalPassword
						 *
						 * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
						 */
						async function decode(
							signedMsg,
							hashedPassword,
							salt,
							backwardCompatibleAttempt = 0,
							originalPassword = ''
						) {
							const encryptedHMAC = signedMsg.substring(0, 64);
							const encryptedMsg = signedMsg.substring(64);
							const decryptedHMAC = await cryptoEngine.signMessage(
								hashedPassword,
								encryptedMsg
							);

							if (decryptedHMAC !== encryptedHMAC) {
								// we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
								// remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
								originalPassword = originalPassword || hashedPassword;
								if (backwardCompatibleAttempt === 0) {
									const updatedHashedPassword =
										await cryptoEngine.hashThirdRound(originalPassword, salt);

									return decode(
										signedMsg,
										updatedHashedPassword,
										salt,
										backwardCompatibleAttempt + 1,
										originalPassword
									);
								}
								if (backwardCompatibleAttempt === 1) {
									let updatedHashedPassword =
										await cryptoEngine.hashSecondRound(originalPassword, salt);
									updatedHashedPassword = await cryptoEngine.hashThirdRound(
										updatedHashedPassword,
										salt
									);

									return decode(
										signedMsg,
										updatedHashedPassword,
										salt,
										backwardCompatibleAttempt + 1,
										originalPassword
									);
								}

								return { success: false, message: 'Signature mismatch' };
							}

							return {
								success: true,
								decoded: await cryptoEngine.decrypt(
									encryptedMsg,
									hashedPassword
								),
							};
						}
						exports.decode = decode;

						return exports;
					}
					exports.init = init;

					return exports;
				})();
				const decode = codec.init(cryptoEngine).decode;

				/**
				 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
				 *
				 * @param {{
				 *  staticryptEncryptedMsgUniqueVariableName: string,
				 *  isRememberEnabled: boolean,
				 *  rememberDurationInDays: number,
				 *  staticryptSaltUniqueVariableName: string,
				 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
				 *
				 * @param {{
				 *  rememberExpirationKey: string,
				 *  rememberPassphraseKey: string,
				 *  replaceHtmlCallback: function,
				 *  clearLocalStorageCallback: function,
				 * }} templateConfig - object of data that can be configured by a custom password_template.
				 */
				function init(staticryptConfig, templateConfig) {
					const exports = {};

					/**
					 * Decrypt our encrypted page, replace the whole HTML.
					 *
					 * @param {string} hashedPassword
					 * @returns {Promise<boolean>}
					 */
					async function decryptAndReplaceHtml(hashedPassword) {
						const {
							staticryptEncryptedMsgUniqueVariableName,
							staticryptSaltUniqueVariableName,
						} = staticryptConfig;
						const { replaceHtmlCallback } = templateConfig;

						const result = await decode(
							staticryptEncryptedMsgUniqueVariableName,
							hashedPassword,
							staticryptSaltUniqueVariableName
						);
						if (!result.success) {
							return false;
						}
						const plainHTML = result.decoded;

						// if the user configured a callback call it, otherwise just replace the whole HTML
						if (typeof replaceHtmlCallback === 'function') {
							replaceHtmlCallback(plainHTML);
						} else {
							document.write(plainHTML);
							document.close();
						}

						return true;
					}

					/**
					 * Attempt to decrypt the page and replace the whole HTML.
					 *
					 * @param {string} password
					 * @param {boolean} isRememberChecked
					 *
					 * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
					 *   expose more information in the future we can do it without breaking the password_template
					 */
					async function handleDecryptionOfPage(password, isRememberChecked) {
						const {
							isRememberEnabled,
							rememberDurationInDays,
							staticryptSaltUniqueVariableName,
						} = staticryptConfig;
						const { rememberExpirationKey, rememberPassphraseKey } =
							templateConfig;

						// decrypt and replace the whole page
						const hashedPassword = await cryptoEngine.hashPassword(
							password,
							staticryptSaltUniqueVariableName
						);

						const isDecryptionSuccessful = await decryptAndReplaceHtml(
							hashedPassword
						);

						if (!isDecryptionSuccessful) {
							return {
								isSuccessful: false,
								hashedPassword,
							};
						}

						// remember the hashedPassword and set its expiration if necessary
						if (isRememberEnabled && isRememberChecked) {
							window.localStorage.setItem(
								rememberPassphraseKey,
								hashedPassword
							);

							// set the expiration if the duration isn't 0 (meaning no expiration)
							if (rememberDurationInDays > 0) {
								window.localStorage.setItem(
									rememberExpirationKey,
									(
										new Date().getTime() +
										rememberDurationInDays * 24 * 60 * 60 * 1000
									).toString()
								);
							}
						}

						return {
							isSuccessful: true,
							hashedPassword,
						};
					}
					exports.handleDecryptionOfPage = handleDecryptionOfPage;

					/**
					 * Clear localstorage from staticrypt related values
					 */
					function clearLocalStorage() {
						const {
							clearLocalStorageCallback,
							rememberExpirationKey,
							rememberPassphraseKey,
						} = templateConfig;

						if (typeof clearLocalStorageCallback === 'function') {
							clearLocalStorageCallback();
						} else {
							localStorage.removeItem(rememberPassphraseKey);
							localStorage.removeItem(rememberExpirationKey);
						}
					}

					async function handleDecryptOnLoad() {
						let isSuccessful = await decryptOnLoadFromUrl();

						if (!isSuccessful) {
							isSuccessful = await decryptOnLoadFromRememberMe();
						}

						return { isSuccessful };
					}
					exports.handleDecryptOnLoad = handleDecryptOnLoad;

					/**
					 * Clear storage if we are logging out
					 *
					 * @returns {boolean} - whether we logged out
					 */
					function logoutIfNeeded() {
						const logoutKey = 'staticrypt_logout';

						// handle logout through query param
						const queryParams = new URLSearchParams(window.location.search);
						if (queryParams.has(logoutKey)) {
							clearLocalStorage();
							return true;
						}

						// handle logout through URL fragment
						const hash = window.location.hash.substring(1);
						if (hash.includes(logoutKey)) {
							clearLocalStorage();
							return true;
						}

						return false;
					}

					/**
					 * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
					 * try to do it if needed.
					 *
					 * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
					 */
					async function decryptOnLoadFromRememberMe() {
						const { rememberDurationInDays } = staticryptConfig;
						const { rememberExpirationKey, rememberPassphraseKey } =
							templateConfig;

						// if we are login out, terminate
						if (logoutIfNeeded()) {
							return false;
						}

						// if there is expiration configured, check if we're not beyond the expiration
						if (rememberDurationInDays && rememberDurationInDays > 0) {
							const expiration = localStorage.getItem(rememberExpirationKey),
								isExpired =
									expiration && new Date().getTime() > parseInt(expiration);

							if (isExpired) {
								clearLocalStorage();
								return false;
							}
						}

						const hashedPassword = localStorage.getItem(rememberPassphraseKey);

						if (hashedPassword) {
							// try to decrypt
							const isDecryptionSuccessful = await decryptAndReplaceHtml(
								hashedPassword
							);

							// if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
							// the user fill the password form again
							if (!isDecryptionSuccessful) {
								clearLocalStorage();
								return false;
							}

							return true;
						}

						return false;
					}

					function decryptOnLoadFromUrl() {
						const passwordKey = 'staticrypt_pwd';

						// get the password from the query param
						const queryParams = new URLSearchParams(window.location.search);
						const hashedPasswordQuery = queryParams.get(passwordKey);

						// get the password from the url fragment
						const hashRegexMatch = window.location.hash
							.substring(1)
							.match(new RegExp(passwordKey + '=(.*)'));
						const hashedPasswordFragment = hashRegexMatch
							? hashRegexMatch[1]
							: null;

						const hashedPassword =
							hashedPasswordFragment || hashedPasswordQuery;

						if (hashedPassword) {
							return decryptAndReplaceHtml(hashedPassword);
						}

						return false;
					}

					return exports;
				}
				exports.init = init;

				return exports;
			})();
			const templateError = 'template_error',
				isRememberEnabled = true,
				staticryptConfig = {
					staticryptEncryptedMsgUniqueVariableName:
						'2c61618d081767f06492a80af3ab16c95f07d371abe8d3770cde2fbef12793d6643faf4889c2cfedd24510538fc849dd1444bcdb0452a0ae456adf8fcc64f5850dbc49118d082b4d1dc9b2666ae7ebf63cda4536e102742e52bcb2cb7e6fa7110a129c64fe24007f89d8e052d9e4b3b013d5c51c89b65a9f9d49673c011d8b155cb60f4f205732408d74ff12d9b040d3bfcc7fd61cdaf2b4aa115b59f71d69b204b1b1da54aebc2dbf53d4055c6d4451c4b9b607f0b9438108cc77530129d4427422382f3b208876718a2a568e70ec53a2fe4dcdbe08447b5f44bfba0716f450f0836f7f7840cad1239627724610cc2e16f10f5a8a782ac057e6c825e39e6d4e119941b694bdbbccced8004c75e23cc2bf3a6af4b69f4dab32acb6118efdfa8f111177edf2685e7d668cf433ea8fc84241f4d8e2ca4cb4891cf242b22f50230e33b74bf72d4a43e7d40ae67b452f64c07fec6bb9262c5fb70187788b80fa7b5be2493f0cebe589f4eaa463425de5939e67fb93335d3ecd2980cb745d9f9b1b3d6b7d3269e99255590b17eff066e4d8dec0ca10d042cbb40b4480c4abb8dbbe2876216a13479182764586d1ffece513972f18e2740503e9a2f8daa98518f00d0c8b965daa229b836d07261ab81ced87a2954206749cd7b873c67dbe610cc491836c321f20d862695b746f3f31a60834a2d76e1f716cb87261b7418f301369dc853104cfbf72f24e443c709c13e07d5e25d45c958fc46a5af759ac5d688724b483afaf4f043495b24c9b7502ac4754d217fad39d7bf8bb2f16a8819a4a76691b1576204c517c8fc129787f113f2533dc63b34b4178080e3c74251a5ae23058ae91742179d58c5a89b7e861d9ce804f42f163cb7bef9acb3d09019d3846d43ec884b59a015a7f5470563f67e9973e5cd40bd569e5302f13a9856e61b1acf93ecd9510aa93dd60cf6b88176b6c30ae978d47a5f401e039b539b17a3b331e83967a094fec9a47d4676e4860717f74bb82aa6c4c5882b7ac5a0bc5bfaf7d29928d3d63a3182a7191411448e95418cb0d48bafa8bfff6f881fb0c0e5fab99ca533c2ee511541834486552e7d9796fbf5e4e18cc2e6a59646bdd3e4482dc0de223c1658fc6ebe219618083fcb42439d9f80f0018a3bf783a450cee58e09010f3a02658ec63bd866f09b9f96a7ad1c3dde04131f4e11b831042851b2d53358cad1be71df26bc72657ac4ae0b8eb8af15c3fcf8ab5d7f9ee7327184d5ad93f124646bced36361bf078393043757f6345ff2cca3c8458c407b10edfac3e80a2e05bb15007dd832c3ef19bce99f8286ab953e652e5c52e3a301acb04e8fd68d91bb35e758b179f9d0570197852e5d9890272c0b020ea08de77c8dbabb95b774268597d1fba3e8c0945af26ce51e8da9bddf6f8b8cde7bfdf0c349bb087a2773a4285d94034109655baabcbf8c77e10b3ddb3bbb30c64c5c1ed2ebf61562912d0aba135107a85d7e89b67ddd534344ae0a7b69a0beaae969b6dc5ba96aef7848b17360d90e1f99bea87f050f358b4a45cd20dfdbbf5aed1daefcc2829414c41af9d2f6c7e34773f522c0b203a87b6ee878f0ff7a969f7503188cfe34591e9a4c80869b3517c500dc5fab5771563c8ea5c9f5b03f7b9e12c0baa95ed045bc871faf5f15e7bf1ac27a942bdc0e99e921c33ebe040fb31ec09a775ef3e2a4dc2650556ee42fff40695b580106c9d46017f3789b4aa76693a6b543f8ccf3a2b6a1bc4669349301533a25f14af9bbd0f2cec6336f84daf94fb72e6891f124291fa7b09e07ba01d31eb3c49b355f70df4d0f3a525b4b16e1b94fe46bfffc91de070e0dd57619146198c7120373a45e8e4b48e74742df8f4b046aec96b435629c18357e1d620fd22059bca7fdef830f2992cd5d3c16f9fb862d0bf7dff6cd9225327ba03343969145a2e3e802f15e92012aa57f0d1486e8e1f3e0fe0bb694f7b865f19fb72376a3e34b9f22762e7b051bb2a69aba02fbdec49d084ddfb30027c99e64bc1df462af87f83bfe2fbf982a9fc05446bd6727e0062b1f82834812035a046440502e8ceff9ba5bc044734958e756cb0074d94aeae42c5a256607c31dcf938f41984b56b95a27c51062af410b6ad9b90eaeeb41328195d25eaf164409521e16b25fdd5f68b27f67d36d3914f8898da74251c53f27e98f14043b0da16cac07fe0752b68a27bd2fa820027049c2a3c9fbc475e1039996ed9c1982c1ec889da3406a4830d084b7e64904e7cf12e72249c2886de1c37389ea05ef3c46cf100f0e4ccf43149848fdb437f63ee91c0a8fd531269cb6caad1fc8edafb732d5322f77b80b0159f2e25fce8fca488e3b769abb9a30259d0399be88ec84227e249087db56d76cde3926a85ff471f5d568cc4f0a6cffcb6e9c29eed8b55ced952898b4acc2844e30ccfcc93e5ca612c8d93d97256befa478d03d21e0a5f9f1753cfeb871c9bde2d7b0f639db469d502c132f365103af9c4d2bbea4b2f6331652194baa7abe0dbb10f72eee81deb12791f247ffdc00c70b8c905fbfc78d6b2b29f8fbf0219015ffdbef8346813c6a8532ec5bdb21cc12a88b4b0b2b8e9f0506397d179d6c826f60546a5721473b6713b22f4f87f7c29c3383908d4e83514eccc7e5b6feb77726fbfc85470b9dd92758e502c90c2c071851b553007852950a61eadae9e4bad3f859f71e0d5275c80e2ea7c1cf7643e27d7ab755a1272280fc6e3687f324485d6912938957ddbc29c675d80bafc223a335002c58bc469472e1ff85e6632a5256a3a59ab70289d7c2a02592e1193f32432b4d86f9735e45564cab98f3c2b9ba3fa8f2f4a13efc8483b097b9360ed11d2708f0d7472ef39e2dcb98b5be770beab24215a3a60f890eb6cc4d3884a84457079bdb9e86ee1d726c59e751f65748d5f3e072e4384da7fa97c1e316a8994e22110ed7e7ceefb9b25cc22992eea754a4192b389762e3e51483a0cb48ff5bebb87724dfdc14161e909030371df5d4bdf563feabde42dbc95a9fb51169ee6affb17b6c07afacdda966d04a0de0446f06a8db6cd54231ef89b07d172e19444599011c0453377618b2efea25d95f958ae66bb229a64459d3e4fe1e0a005d8c80d4a85c420d6509c1818abee5d859f29d56cc54dd59366724662540a80ab9b7f8fb76178ff068f1463da5d4d52423bb30daa838bbfab86d7dbe055654b463cd4c8a93613acd63cb5b65cc312dc4451da5b47984890fda77e18df53e7b5ab67d44402335bbb5fb3071a925bd3c9aec5bb21bd3e3cb462e0c7fc6c905dd0f96672d33a7cf2109dc928b60a4e8c1e5ebcce0d2ab07ed28b863a5a0d91f2f36f44cf39c5e58a421c205a0720a0a071d1b25f3a5588336dd09807746877de6ac37413623b480b7ea09faa1a009d3edb3e0e114d6e695a0cf33783e20b0584c0851ebb2c5c257cbb2e88d5f0ea671574b518410c51b34946b02769ebed9f28b26a9b356d12fb6133fa1d615613c08f4ee7d5f4b89357f01cce7406d023bc2720b6729aec802de3b56fea910268668816a9c8612d2f233fe3b0a1a836096263c6eb0761d5f40664f7a08aff7a56a943d50b5c9a09b4d12adca79b617c4a5beb85f8c2cf0ab2684685f2741a7cc4f2607af9a9b11ac4b6924a893241788d588f17d046eae8ee4798a29c3ff2915a81ff5b4186609b2439cbd4e1b597906f416d8b9ff06857740fda6a2d98d90be7cd057df6b23afd7da0c24b8cc2cb4d7066b6f5138ece1cc4272dbeb964ac45544bad077530b6122ba8b5bee553498711942efda959981a92a0dbb91ac868d0163e836a09459ff69b793ccf41987b18f24e38f2bc95e587a7ff2fb2f0f78d1171162a2094969a5c442a8faef6b10467913db7e09642e638862450a7390a4331076d07a2f24d7e5960c0f5795feab7cf0ed25a931b5a3609576a368ffa76eb7c990abd4ccd7e647ea98ab610efae37643bdf9de045ee9b1c29f6836c522c82431494b7ae8153cfb726bd8b1125a13c6052aeaf18425c6663e5febdca9c3fb0d587ce9e02d99efddabb91be32d8871504573c768409902592631e02116cad861f0dba3f6543f008ccb2260c9996edf0648e31f02959d8c1098d129f6ed52adff75bc83c6e92b37176f8b8816661f65a1735369f890abe4b0b7667d893dfc0242282ecd5c51087b657b808172d469ef4ee238044ad2d949d69bf9b58193d1f8709543578a24676abbf18db94b9cbec9ea6700a73de3a2732fc6a3e7a330ed1f992890d0c70996ee46b76ff39f1629f21c6e3f2edea3b47f4afb2f4ea6547cb8d6e27eb80bb534decd931c9c26a96e316248882903caa55694b1fe9b7695433246d2d0e9db78c5695867902499c7e21b94289bd37b9750fe799fc7933ef980f52f74324cfd90e1a25028bea057a430652f08b45c2a64141e5e381608649437a5bceeacb2d1267d9f5e1ed7a1332250c111ed931a14d29532ab44f4c4255ae8a94cb106df23c256e22bce46ce5b1169bddd11f44e18cb1d942528af4a4fb079dd6b38100f1b00937d75a3873aa6486ee65ffbe45ebee5674257eed2bef5f422fa8aa7c548afdc03263a792481a209f9e709475c76e4a7d01c95b0eb279b7432d49cb66b3d8fb73f9df0583931c86a16b49bb39e9bb22744386fe2f725f01ff2462bfcebd1adf68a63c127349af3a86b7fe4e967a0ebfbd7b29e6f6de2725580bf86300da0d84f9800cc5f0247e7ebb38d1233719aea2c5f5e903a47ed9de22e0d088b7472499e2b28a89cb059fd00b5c2f07931d4f275087576f65082512dc154ab286d9b2b36a2abc26081279b535c6657887ef9a6d3a73bbe8882736605d7d046293cb7ca97c39bb2597bfee06e05a02ee337ffd3508c6f6ff7d82d09514e602aa118f36ede8bb489beb4b1cc7a079f2c27ab123c420d5fff1a50798eeff65c7907d14b53487676c5962922e30ab5a74eef8fce4a57136689308d0a7b850810f85391027828ca2e5021b9646c027d72403f417859717ee60dd7e8feae456cd2719408b3e2895302f16dd29e2c02f89b07f895a00425814f09e85037d564deb4b36242cef3e18766e0d413329473c4dfbb09b2b3b4b22c6243eb103c87bb830b7be086e9f0d38bebb19c4c46e713e7407ae99509566e956ddffcd2cd97f42c55967d92a72e1810065573ea1799fce310c83ef8ccf3b9c85766f12635e0a666318f1384cdeec20cd177ea06d4c90b4d9a969363962d45c9c4fe5fc55e56e511f7215d4f0d1cb50c2a7c1f63ca6d8fec7dccf96e70e88e36f7d4fa0fbf46b5abf5273cfc713fde9df264605f8bb6ef5d300cbb1646bf8c945c0d0b3afb6afde9217ee26ccbfa6e2218ae431d2da197f8e2d75001f638ec7850ef92db4222ff443d7e9aa208860bcc6e41ddb27bddf049dafd84ad903709bba80e478383aa9cfa8bb1b90ec5a0cdabf6f8572f9921a04e78a569228585188007b219cbc9fd2344517af139ebf5bb0844b658f121ba80967d2fa0d9d38c2c9e125c7b4542f8df2b9f87961cb07cb8373e2bb372e08dcba81ee0d48cab5fe7f4f47df88d0fcb35e519937c2cd4da9013fc4e8c54b1ea2d4878120432da95fa0334c8268488a9abd389a59b21b13ef97d7b42a75d58ae551a41da08bdd716515f991e745a64c16728d980d56c9055ef9dc2ff4795572feae0c1e6ee3e41be330380de4b2e2f7afc46c273eaeef9002a56e1e23e46f2003ff6e21aa73787e3cfdbab205a4cb1f26ae268cfeadb2aea31539c0a2367f86b8f5fe0c553ac963e793501c1b051883fbd62142d5258908cc14a1f6f6a800063d56ecf14aa3c339c897e7837a4fd1ba36d7a9d2a77f3a31f63eca2e52378635cf30a6410238d030860cf44406a4ed4d383db11a30037c5c54fee7787fb6aa275188d059ef54e1b369474af19d348e87904b82e3f9dab93eb614a1f192208808674b66687251649fac778e8ea51a968394e8f051e728b7cbb0d745ec1cc72a4826db79b149017ddc4561deabdf28fc488494dd432b586174451da139371a6adbedfa1e4ec6c60b1d586a99a7465f153faadb32455e3166de8e8a47169dcc9c0548a7b337bebaac3f239369f6e981c7a31579cce81b71b57367db789cee6758eb2566abfbecc62adbdc9b6835f5e210366d831e1637c805c79f813c8993bf628c9e980d7b1af419dca40cad4d67e9907a74cacdec96cc80913932002b39bdc2994e3d4ef5eda6587ae4786e572736d8fb331bcc3ae86b02af4d8279e4bdf154bee52c09f8430c4d817d298498149bd6a73449a38a6ded2992d9c60e302b1646b2c06e5fd88d30fbcf926e27d637111e7d91c59cfd811ca6c01f7b3838b222d5fc72d9a1176a5763e62baf59b412ebea91aded18f59aedd06e8568ac5e593c3e8969bfbbad3c7f874e0a089cf25d5cae823baaa3b77fb282dab5d2bffaa84814aaa1b5bbae751b612369e7b081ef8ebdc5087bda3b05f82d007ba08ea9a930dad8d56f4b015eb3e3d0f5fb530f2d11ce7fd7b7c62fcb9587e4c708222530621a939c09b13b5aac98e930258ba497ef08122a5180218aa613bf66d35935dc3eef7fe46130edf3aaece4e7838d1f5ff86ea2adeb5f5c2f85cdcea8a817d2d532faad3064a67e26cac277d05d01b7c6002a5fe55b3c995fb5fbd8d733543671df91fafee73fb6409481d68e063aad069ec39025813492b621abc6431971fbf1f5b2ce3ee7fd81a9af7fac87a4461a75b5416b1b1991a89704376751f14ab49546b248b2fa7eb41fa30b8fea33a9a9bfdd7fcabf282bae97bfa20c010de56ca87c2bc04a76d9b167f459936b24c12a5c15a6c666c60ed9d593a0471e34be3d272ecabf18d3c60da9538d3ed3554e3f9a1019d59e9a26e8aa5eda9f590a8de2fee3599749d4349c4d5690c58adc5b683bb41d324ed4a5b2ee5e0a60d08f062c7309d2a385c675c1c0b96080323f7ae6a22ee745fbb910c6795f8d401657b82fbd43547b5247306367f20c7d7d4d10f49538152d9258222566d25fd6614f067ff6fdde45ef9242c4c53b6992bda09455553e23c00326cfae7d9229706d7e3ec2f9264f48589db1a23c46a178890195bd86f1ef2508c01851857973e4cd308fef4a211d89df4ce0e1657bb41cb179c7081cd3ce0e08cabd020fc54c9fc824d15ec5ccd78415e04616cf1de045ed843c3e6cd91ecef1623834b80de6d5e3a2a9981c1d34489e19c255980be715e1997eb393dfb682d557e9ab86db46d11406ac65de093c6a8b22d16ed72e97d4d4fd7129a29814c85c323ad3ddc560129587544dbc7c19b79f4f9df9cc9d9da679f8374f1b7d0b41bbe7457f4e23862b51a709f8abfb04a89bbb578a97ceca1e7a8ad2671774b20ecf8ebb0b85bbd6295ef945ac84d8d0e26e9b6122e9b153d84b3b196ef5e2106a0ac08cdbf125e7177236cf618569a1500076aecddafb9e886a6df06a1e0bf9c8afe3f984e452f1e731b856fb9083136dd119aa858ac1beec50e416a249e5e85f1caa8479412c3f',
					isRememberEnabled: true,
					rememberDurationInDays: '10',
					staticryptSaltUniqueVariableName: '2e8c820ed018a779d5bd2477cab98b2c',
				};

			// you can edit these values to customize some of the behavior of StatiCrypt
			const templateConfig = {
				rememberExpirationKey: 'staticrypt_expiration',
				rememberPassphraseKey: 'staticrypt_passphrase',
				replaceHtmlCallback: null,
				clearLocalStorageCallback: null,
			};

			// init the staticrypt engine
			const staticrypt = staticryptInitiator.init(
				staticryptConfig,
				templateConfig
			);

			// try to automatically decrypt on load if there is a saved password
			window.onload = async function () {
				const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

				// if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
				// replaced, no need to do anything
				if (!isSuccessful) {
					// hide loading screen
					document.getElementById('staticrypt_loading').classList.add('hidden');
					document
						.getElementById('staticrypt_content')
						.classList.remove('hidden');
					document.getElementById('staticrypt-password').focus();

					// show the remember me checkbox
					if (isRememberEnabled) {
						document
							.getElementById('staticrypt-remember-label')
							.classList.remove('hidden');
					}
				}
			};

			// handle password form submission
			document
				.getElementById('staticrypt-form')
				.addEventListener('submit', async function (e) {
					e.preventDefault();

					const password = document.getElementById('staticrypt-password').value,
						isRememberChecked = document.getElementById(
							'staticrypt-remember'
						).checked;

					const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
						password,
						isRememberChecked
					);

					if (!isSuccessful) {
						alert(templateError);
					}
				});
		</script>
	</body>
</html>
