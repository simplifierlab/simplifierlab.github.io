<!DOCTYPE html>
<html class="staticrypt-html">
	<head>
		<meta charset="utf-8" />
		<title>ðŸ”“</title>
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<!-- do not cache this page -->
		<meta http-equiv="cache-control" content="max-age=0" />
		<meta http-equiv="cache-control" content="no-cache" />
		<meta http-equiv="expires" content="0" />
		<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
		<meta http-equiv="pragma" content="no-cache" />

		<style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.1),
					0 5px 5px 0 rgba(0, 0, 0, 0.1);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 15px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				/* text-transform: uppercase; */
				outline: 0;
				background: #1a0000;
				border-radius: 3px;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #1a0000;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #eaf3f7;
				font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica,
					Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji';
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.5);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
	</head>

	<body class="staticrypt-body">
		<div id="staticrypt_loading" class="staticrypt-spinner-container">
			<div class="staticrypt-spinner"></div>
		</div>

		<div id="staticrypt_content" class="staticrypt-content hidden">
			<div class="staticrypt-page">
				<div class="staticrypt-form">
					<div class="staticrypt-instructions">
						<p class="staticrypt-title">ðŸ”“</p>
						<p></p>
					</div>

					<hr class="staticrypt-hr" />

					<form id="staticrypt-form" action="#" method="post">
						<input
							id="staticrypt-password"
							type="password"
							name="password"
							placeholder="Password"
							autofocus
						/>

						<label
							id="staticrypt-remember-label"
							class="staticrypt-remember hidden"
						>
							<input id="staticrypt-remember" type="checkbox" name="remember" />
							Remember me
						</label>

						<input
							type="submit"
							class="staticrypt-decrypt-button"
							value="Unlock"
						/>
					</form>
				</div>
			</div>
		</div>

		<script>
			// these variables will be filled when generating the file - the template format is 'variable_name'
			const staticryptInitiator = (function () {
				const exports = {};
				const cryptoEngine = (function () {
					const exports = {};
					const { subtle } = crypto;

					const IV_BITS = 16 * 8;
					const HEX_BITS = 4;
					const ENCRYPTION_ALGO = 'AES-CBC';

					/**
					 * Translates between utf8 encoded hexadecimal strings
					 * and Uint8Array bytes.
					 */
					const HexEncoder = {
						/**
						 * hex string -> bytes
						 * @param {string} hexString
						 * @returns {Uint8Array}
						 */
						parse: function (hexString) {
							if (hexString.length % 2 !== 0) throw 'Invalid hexString';
							const arrayBuffer = new Uint8Array(hexString.length / 2);

							for (let i = 0; i < hexString.length; i += 2) {
								const byteValue = parseInt(hexString.substring(i, i + 2), 16);
								if (isNaN(byteValue)) {
									throw 'Invalid hexString';
								}
								arrayBuffer[i / 2] = byteValue;
							}
							return arrayBuffer;
						},

						/**
						 * bytes -> hex string
						 * @param {Uint8Array} bytes
						 * @returns {string}
						 */
						stringify: function (bytes) {
							const hexBytes = [];

							for (let i = 0; i < bytes.length; ++i) {
								let byteString = bytes[i].toString(16);
								if (byteString.length < 2) {
									byteString = '0' + byteString;
								}
								hexBytes.push(byteString);
							}
							return hexBytes.join('');
						},
					};

					/**
					 * Translates between utf8 strings and Uint8Array bytes.
					 */
					const UTF8Encoder = {
						parse: function (str) {
							return new TextEncoder().encode(str);
						},

						stringify: function (bytes) {
							return new TextDecoder().decode(bytes);
						},
					};

					/**
					 * Salt and encrypt a msg with a password.
					 */
					async function encrypt(msg, hashedPassword) {
						// Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
						// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
						const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

						const key = await subtle.importKey(
							'raw',
							HexEncoder.parse(hashedPassword),
							ENCRYPTION_ALGO,
							false,
							['encrypt']
						);

						const encrypted = await subtle.encrypt(
							{
								name: ENCRYPTION_ALGO,
								iv: iv,
							},
							key,
							UTF8Encoder.parse(msg)
						);

						// iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
						return (
							HexEncoder.stringify(iv) +
							HexEncoder.stringify(new Uint8Array(encrypted))
						);
					}
					exports.encrypt = encrypt;

					/**
					 * Decrypt a salted msg using a password.
					 *
					 * @param {string} encryptedMsg
					 * @param {string} hashedPassword
					 * @returns {Promise<string>}
					 */
					async function decrypt(encryptedMsg, hashedPassword) {
						const ivLength = IV_BITS / HEX_BITS;
						const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
						const encrypted = encryptedMsg.substring(ivLength);

						const key = await subtle.importKey(
							'raw',
							HexEncoder.parse(hashedPassword),
							ENCRYPTION_ALGO,
							false,
							['decrypt']
						);

						const outBuffer = await subtle.decrypt(
							{
								name: ENCRYPTION_ALGO,
								iv: iv,
							},
							key,
							HexEncoder.parse(encrypted)
						);

						return UTF8Encoder.stringify(new Uint8Array(outBuffer));
					}
					exports.decrypt = decrypt;

					/**
					 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
					 *
					 * @param {string} password
					 * @param {string} salt
					 * @returns {Promise<string>}
					 */
					async function hashPassword(password, salt) {
						// we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
						// iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
						let hashedPassword = await hashLegacyRound(password, salt);

						hashedPassword = await hashSecondRound(hashedPassword, salt);

						return hashThirdRound(hashedPassword, salt);
					}
					exports.hashPassword = hashPassword;

					/**
					 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
					 * compatibility.
					 *
					 * @param {string} password
					 * @param {string} salt
					 * @returns {Promise<string>}
					 */
					function hashLegacyRound(password, salt) {
						return pbkdf2(password, salt, 1000, 'SHA-1');
					}
					exports.hashLegacyRound = hashLegacyRound;

					/**
					 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
					 * remember-me/autodecrypt links, we need to support going from that to more iterations.
					 *
					 * @param hashedPassword
					 * @param salt
					 * @returns {Promise<string>}
					 */
					function hashSecondRound(hashedPassword, salt) {
						return pbkdf2(hashedPassword, salt, 14000, 'SHA-256');
					}
					exports.hashSecondRound = hashSecondRound;

					/**
					 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
					 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
					 *
					 * @param hashedPassword
					 * @param salt
					 * @returns {Promise<string>}
					 */
					function hashThirdRound(hashedPassword, salt) {
						return pbkdf2(hashedPassword, salt, 585000, 'SHA-256');
					}
					exports.hashThirdRound = hashThirdRound;

					/**
					 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
					 *
					 * @param {string} password
					 * @param {string} salt
					 * @param {int} iterations
					 * @param {string} hashAlgorithm
					 * @returns {Promise<string>}
					 */
					async function pbkdf2(password, salt, iterations, hashAlgorithm) {
						const key = await subtle.importKey(
							'raw',
							UTF8Encoder.parse(password),
							'PBKDF2',
							false,
							['deriveBits']
						);

						const keyBytes = await subtle.deriveBits(
							{
								name: 'PBKDF2',
								hash: hashAlgorithm,
								iterations,
								salt: UTF8Encoder.parse(salt),
							},
							key,
							256
						);

						return HexEncoder.stringify(new Uint8Array(keyBytes));
					}

					function generateRandomSalt() {
						const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

						return HexEncoder.stringify(new Uint8Array(bytes));
					}
					exports.generateRandomSalt = generateRandomSalt;

					async function signMessage(hashedPassword, message) {
						const key = await subtle.importKey(
							'raw',
							HexEncoder.parse(hashedPassword),
							{
								name: 'HMAC',
								hash: 'SHA-256',
							},
							false,
							['sign']
						);
						const signature = await subtle.sign(
							'HMAC',
							key,
							UTF8Encoder.parse(message)
						);

						return HexEncoder.stringify(new Uint8Array(signature));
					}
					exports.signMessage = signMessage;

					function getRandomAlphanum() {
						const possibleCharacters =
							'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

						let byteArray;
						let parsedInt;

						// Keep generating new random bytes until we get a value that falls
						// within a range that can be evenly divided by possibleCharacters.length
						do {
							byteArray = crypto.getRandomValues(new Uint8Array(1));
							// extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
							parsedInt = byteArray[0] & 0xff;
						} while (parsedInt >= 256 - (256 % possibleCharacters.length));

						// Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
						const randomIndex = parsedInt % possibleCharacters.length;

						return possibleCharacters[randomIndex];
					}

					/**
					 * Generate a random string of a given length.
					 *
					 * @param {int} length
					 * @returns {string}
					 */
					function generateRandomString(length) {
						let randomString = '';

						for (let i = 0; i < length; i++) {
							randomString += getRandomAlphanum();
						}

						return randomString;
					}
					exports.generateRandomString = generateRandomString;

					return exports;
				})();
				const codec = (function () {
					const exports = {};
					/**
					 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
					 *
					 * @param cryptoEngine - the engine to use for encryption / decryption
					 */
					function init(cryptoEngine) {
						const exports = {};

						/**
						 * Top-level function for encoding a message.
						 * Includes password hashing, encryption, and signing.
						 *
						 * @param {string} msg
						 * @param {string} password
						 * @param {string} salt
						 *
						 * @returns {string} The encoded text
						 */
						async function encode(msg, password, salt) {
							const hashedPassword = await cryptoEngine.hashPassword(
								password,
								salt
							);

							const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

							// we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
							// it in localStorage safely, we don't use the clear text password)
							const hmac = await cryptoEngine.signMessage(
								hashedPassword,
								encrypted
							);

							return hmac + encrypted;
						}
						exports.encode = encode;

						/**
						 * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
						 * we don't need to hash the password multiple times.
						 *
						 * @param {string} msg
						 * @param {string} hashedPassword
						 *
						 * @returns {string} The encoded text
						 */
						async function encodeWithHashedPassword(msg, hashedPassword) {
							const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

							// we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
							// it in localStorage safely, we don't use the clear text password)
							const hmac = await cryptoEngine.signMessage(
								hashedPassword,
								encrypted
							);

							return hmac + encrypted;
						}
						exports.encodeWithHashedPassword = encodeWithHashedPassword;

						/**
						 * Top-level function for decoding a message.
						 * Includes signature check and decryption.
						 *
						 * @param {string} signedMsg
						 * @param {string} hashedPassword
						 * @param {string} salt
						 * @param {int} backwardCompatibleAttempt
						 * @param {string} originalPassword
						 *
						 * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
						 */
						async function decode(
							signedMsg,
							hashedPassword,
							salt,
							backwardCompatibleAttempt = 0,
							originalPassword = ''
						) {
							const encryptedHMAC = signedMsg.substring(0, 64);
							const encryptedMsg = signedMsg.substring(64);
							const decryptedHMAC = await cryptoEngine.signMessage(
								hashedPassword,
								encryptedMsg
							);

							if (decryptedHMAC !== encryptedHMAC) {
								// we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
								// remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
								originalPassword = originalPassword || hashedPassword;
								if (backwardCompatibleAttempt === 0) {
									const updatedHashedPassword =
										await cryptoEngine.hashThirdRound(originalPassword, salt);

									return decode(
										signedMsg,
										updatedHashedPassword,
										salt,
										backwardCompatibleAttempt + 1,
										originalPassword
									);
								}
								if (backwardCompatibleAttempt === 1) {
									let updatedHashedPassword =
										await cryptoEngine.hashSecondRound(originalPassword, salt);
									updatedHashedPassword = await cryptoEngine.hashThirdRound(
										updatedHashedPassword,
										salt
									);

									return decode(
										signedMsg,
										updatedHashedPassword,
										salt,
										backwardCompatibleAttempt + 1,
										originalPassword
									);
								}

								return { success: false, message: 'Signature mismatch' };
							}

							return {
								success: true,
								decoded: await cryptoEngine.decrypt(
									encryptedMsg,
									hashedPassword
								),
							};
						}
						exports.decode = decode;

						return exports;
					}
					exports.init = init;

					return exports;
				})();
				const decode = codec.init(cryptoEngine).decode;

				/**
				 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
				 *
				 * @param {{
				 *  staticryptEncryptedMsgUniqueVariableName: string,
				 *  isRememberEnabled: boolean,
				 *  rememberDurationInDays: number,
				 *  staticryptSaltUniqueVariableName: string,
				 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
				 *
				 * @param {{
				 *  rememberExpirationKey: string,
				 *  rememberPassphraseKey: string,
				 *  replaceHtmlCallback: function,
				 *  clearLocalStorageCallback: function,
				 * }} templateConfig - object of data that can be configured by a custom password_template.
				 */
				function init(staticryptConfig, templateConfig) {
					const exports = {};

					/**
					 * Decrypt our encrypted page, replace the whole HTML.
					 *
					 * @param {string} hashedPassword
					 * @returns {Promise<boolean>}
					 */
					async function decryptAndReplaceHtml(hashedPassword) {
						const {
							staticryptEncryptedMsgUniqueVariableName,
							staticryptSaltUniqueVariableName,
						} = staticryptConfig;
						const { replaceHtmlCallback } = templateConfig;

						const result = await decode(
							staticryptEncryptedMsgUniqueVariableName,
							hashedPassword,
							staticryptSaltUniqueVariableName
						);
						if (!result.success) {
							return false;
						}
						const plainHTML = result.decoded;

						// if the user configured a callback call it, otherwise just replace the whole HTML
						if (typeof replaceHtmlCallback === 'function') {
							replaceHtmlCallback(plainHTML);
						} else {
							document.write(plainHTML);
							document.close();
						}

						return true;
					}

					/**
					 * Attempt to decrypt the page and replace the whole HTML.
					 *
					 * @param {string} password
					 * @param {boolean} isRememberChecked
					 *
					 * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
					 *   expose more information in the future we can do it without breaking the password_template
					 */
					async function handleDecryptionOfPage(password, isRememberChecked) {
						const {
							isRememberEnabled,
							rememberDurationInDays,
							staticryptSaltUniqueVariableName,
						} = staticryptConfig;
						const { rememberExpirationKey, rememberPassphraseKey } =
							templateConfig;

						// decrypt and replace the whole page
						const hashedPassword = await cryptoEngine.hashPassword(
							password,
							staticryptSaltUniqueVariableName
						);

						const isDecryptionSuccessful = await decryptAndReplaceHtml(
							hashedPassword
						);

						if (!isDecryptionSuccessful) {
							return {
								isSuccessful: false,
								hashedPassword,
							};
						}

						// remember the hashedPassword and set its expiration if necessary
						if (isRememberEnabled && isRememberChecked) {
							window.localStorage.setItem(
								rememberPassphraseKey,
								hashedPassword
							);

							// set the expiration if the duration isn't 0 (meaning no expiration)
							if (rememberDurationInDays > 0) {
								window.localStorage.setItem(
									rememberExpirationKey,
									(
										new Date().getTime() +
										rememberDurationInDays * 24 * 60 * 60 * 1000
									).toString()
								);
							}
						}

						return {
							isSuccessful: true,
							hashedPassword,
						};
					}
					exports.handleDecryptionOfPage = handleDecryptionOfPage;

					/**
					 * Clear localstorage from staticrypt related values
					 */
					function clearLocalStorage() {
						const {
							clearLocalStorageCallback,
							rememberExpirationKey,
							rememberPassphraseKey,
						} = templateConfig;

						if (typeof clearLocalStorageCallback === 'function') {
							clearLocalStorageCallback();
						} else {
							localStorage.removeItem(rememberPassphraseKey);
							localStorage.removeItem(rememberExpirationKey);
						}
					}

					async function handleDecryptOnLoad() {
						let isSuccessful = await decryptOnLoadFromUrl();

						if (!isSuccessful) {
							isSuccessful = await decryptOnLoadFromRememberMe();
						}

						return { isSuccessful };
					}
					exports.handleDecryptOnLoad = handleDecryptOnLoad;

					/**
					 * Clear storage if we are logging out
					 *
					 * @returns {boolean} - whether we logged out
					 */
					function logoutIfNeeded() {
						const logoutKey = 'staticrypt_logout';

						// handle logout through query param
						const queryParams = new URLSearchParams(window.location.search);
						if (queryParams.has(logoutKey)) {
							clearLocalStorage();
							return true;
						}

						// handle logout through URL fragment
						const hash = window.location.hash.substring(1);
						if (hash.includes(logoutKey)) {
							clearLocalStorage();
							return true;
						}

						return false;
					}

					/**
					 * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
					 * try to do it if needed.
					 *
					 * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
					 */
					async function decryptOnLoadFromRememberMe() {
						const { rememberDurationInDays } = staticryptConfig;
						const { rememberExpirationKey, rememberPassphraseKey } =
							templateConfig;

						// if we are login out, terminate
						if (logoutIfNeeded()) {
							return false;
						}

						// if there is expiration configured, check if we're not beyond the expiration
						if (rememberDurationInDays && rememberDurationInDays > 0) {
							const expiration = localStorage.getItem(rememberExpirationKey),
								isExpired =
									expiration && new Date().getTime() > parseInt(expiration);

							if (isExpired) {
								clearLocalStorage();
								return false;
							}
						}

						const hashedPassword = localStorage.getItem(rememberPassphraseKey);

						if (hashedPassword) {
							// try to decrypt
							const isDecryptionSuccessful = await decryptAndReplaceHtml(
								hashedPassword
							);

							// if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
							// the user fill the password form again
							if (!isDecryptionSuccessful) {
								clearLocalStorage();
								return false;
							}

							return true;
						}

						return false;
					}

					function decryptOnLoadFromUrl() {
						const passwordKey = 'staticrypt_pwd';

						// get the password from the query param
						const queryParams = new URLSearchParams(window.location.search);
						const hashedPasswordQuery = queryParams.get(passwordKey);

						// get the password from the url fragment
						const hashRegexMatch = window.location.hash
							.substring(1)
							.match(new RegExp(passwordKey + '=(.*)'));
						const hashedPasswordFragment = hashRegexMatch
							? hashRegexMatch[1]
							: null;

						const hashedPassword =
							hashedPasswordFragment || hashedPasswordQuery;

						if (hashedPassword) {
							return decryptAndReplaceHtml(hashedPassword);
						}

						return false;
					}

					return exports;
				}
				exports.init = init;

				return exports;
			})();
			const templateError = 'template_error',
				isRememberEnabled = true,
				staticryptConfig = {
					staticryptEncryptedMsgUniqueVariableName:
						'4819c5944ec20d7d329cbe74d2ab282257a07587989775bb36c1a3e944a89aaf71b394fd5e18681fa85d1202b0a4d325d3e90df55f041d464b3f5c2504387d73f3c40a73da79c50ea088790a6f93f136f333273de4311f227890c33211f7ee92a4e13b0f1e312a5099f277b9b569e576096ec6915399262ee29c25896a54d777852ba9eedaf1c1d1a92b10b4cd85216c97f4bf209ea316e04666437db2e2a5ca0c9584ce96dc9c09cb5d8b65178f2ed00131349c631b49ccf551908f5f0d01b82a5dfc3d516d7de9eda4ba4f8e9590485f357ee3286e967719970d39bc1d789d3002a5fdbbefb9f40f0fa95e59c0af4c365fa6573b52a194819f0f57650469037f0fd0c742ecde26a4ca5ffec43ca6c944b1c7cc8f1307146d358425433a553bb6866cc91d46fde4053e5336c87b980ecfbfd98c20c6877c68a960949595a64d752122c38bc90bd70f59091f14aa3290f8007457bf43b61effba92762bee81f0b111403d17f1ed6e2fe637f7c86b4e59059636c0cfbfa81ca3987fe9d600e4ef1d9cbe92d22748654aed5a1b1d57444ee6f634e56f2de42079648f78bf43eda0aca91eddc393e6830abb44c41ef01009886b20461edde220683d6b11c7fe8fd164a1bc6cd62bb40fa8b4d0d6290d38cac6d08874b0b0c3f2d35442c5694b956523f87067d293807915f3d8db6d786de51b13c8de674f93f6b33f42e4fcecad33a8f0bdfe57e5f23281472e57a94268e22358003bd2f82bd08a6f987e3baeb77db6e57c0b7722cdf4c7e6cd76458b9223855c0c37bdf4407c088253285031520d5e73c0cd4bab6837fb8ff156bd89300a14b6b22c3ad993f1002ab1124371b528588e62cedb56d0eb1fecf3a3cdd486bcb64bfe8ced4696235ba95b7a15c2698c4d6023ce40a38f68a3d07b529e112455623937e68219f362e68b4583c1ac373259577a3c82311ff30da128872fa044fe64b90da906ae4f00ba63de49b81158d260cbf9b1d37efe1af7b7d70d8923aeeab66f86e6269882ffb8e540bc07cc8a9813157ae22c36de5625476ccb2d272448d8adbdf8767612780719c90ebb3a802ebc004559e0b8f5b320b1e2a08aad0cf228544308c27834bb94bcc1342b2b0efe915b8ff80557f7afe07f653b596c9ae43fe31c95eba1fd9804d1c621140e47844ddcb74c4730298e4bab74542a38206529288af34419605fe8e24ef7829ff8d51611ab39574d287fef343504e2b60107e051e05b123c296816725efe97e32c3b008aadc26021d5365611d26ed19171c162c061da4808ca74d0a378d72847a1c1bccce7cd9171d745c2b331d9da5f5f711ca7276639ad25d0c174107a1b50e2ac97575d836cb9e03569d390dd106bf901a459cf227e88301ca837738e82d53344397c8688ec71fa4b3c3812ca297f55cf33b5b8b4bff98d29506aff2bc97986384649e9d0161f7f7b3f6ed30cb0447d055830e36cd602d5e580044bc5feff1cb3cc6c874f1b7edce3a285c7b7e3d0f3d6e60d65b7ee224a13bfc9d1ac83f50ee4ca231cee39d00a9e94423f52d1a982047ef5ecaee10063220eb736aa2dad52f2d31a641512a392024827931e9cfa217e845720cc133248684f977d4c0f4bcec246de28c809ff1f1c6c589fe93496e103b4d7f6754fa7890ea8c1f0702434b400424352dd0db70c15c2d344cd6f7d4d390d6917402e0c894be360040e795130f4040a23e2e37583ddcae9c6f227f4912cdf2ab575f865275e0c1f5dc57418052dd1988902f70ef93c070c87810d3e752072424ee572a485dcab39e26be55a214540624a29b66bfed66d510929fcfbe30e9408374b7e15bc618ada53e4a278623ed349b4efb99fb4e9d26d545fa1a4ebba875052123624a328d77aaaef5c6906c9fe058187661dc5c0c20b7192fae29c5a98f5b5b09fce4e20a5abcdd7d2fef7527b3c13528e10629ba8abc48c48589d5424a52e7d93b083b6663d4a3e0740e9659d5a1a2dd97514d3bea43ee22d3c8ad16e44af871fbddb616561aafbeb36fa081426b0b6fce5b8ee686bc71017dc6a1c64401cf6e6deb9f8b15484e8aca95c81cd58c961d51c1d65aa5796fe37ce124bffe8d91831b87bac8eca5b4b21a18e1cb65d76953d021cece44c2cc8f99bf23917d9cf5dc9f9d3948badf871735257ade3fc0d69f5c89d201244d90731c97192933f922a6a3c0346c90091fc7918392bbe2fffd2acd1466a72e46bb329b8e7b6439cdcb247da0eeafa78c403b409a64af4c864ee497f80756cfc41d6bb799529b68743e3e34411878e02ed9d81f07ab4a991bc6bb466acb1c558210ec8914d6b9c5c9a2a2b578925a21a1fd8fee1517a4cdb461b68d8cef31da7e81ff4738ae1921cb277cf789404d725bb7038943a34fcc517cb5245fae15e1b398569b6adcc921d066786fc79e8c72b790099f778b1d1beed55ebad9a812b744f1c958dd9b2ec25538ed33f128dbaa0038e7d19e2f9ba4140f956ec402be8e7895b84b3b6ec',
					isRememberEnabled: true,
					rememberDurationInDays: 0,
					staticryptSaltUniqueVariableName: 'ca25962a7e9f117f23b22b7313b555bc',
				};

			// you can edit these values to customize some of the behavior of StatiCrypt
			const templateConfig = {
				rememberExpirationKey: 'staticrypt_expiration',
				rememberPassphraseKey: 'staticrypt_passphrase',
				replaceHtmlCallback: null,
				clearLocalStorageCallback: null,
			};

			// init the staticrypt engine
			const staticrypt = staticryptInitiator.init(
				staticryptConfig,
				templateConfig
			);

			// try to automatically decrypt on load if there is a saved password
			window.onload = async function () {
				const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

				// if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
				// replaced, no need to do anything
				if (!isSuccessful) {
					// hide loading screen
					document.getElementById('staticrypt_loading').classList.add('hidden');
					document
						.getElementById('staticrypt_content')
						.classList.remove('hidden');
					document.getElementById('staticrypt-password').focus();

					// show the remember me checkbox
					if (isRememberEnabled) {
						document
							.getElementById('staticrypt-remember-label')
							.classList.remove('hidden');
					}
				}
			};

			// handle password form submission
			document
				.getElementById('staticrypt-form')
				.addEventListener('submit', async function (e) {
					e.preventDefault();

					const password = document.getElementById('staticrypt-password').value,
						isRememberChecked = document.getElementById(
							'staticrypt-remember'
						).checked;

					const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
						password,
						isRememberChecked
					);

					if (!isSuccessful) {
						alert(templateError);
					}
				});
		</script>
	</body>
</html>
