<!DOCTYPE html>
<html class="staticrypt-html">
	<head>
		<meta charset="utf-8" />
		<title>ðŸ”’</title>
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<!-- do not cache this page -->
		<meta http-equiv="cache-control" content="max-age=0" />
		<meta http-equiv="cache-control" content="no-cache" />
		<meta http-equiv="expires" content="0" />
		<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
		<meta http-equiv="pragma" content="no-cache" />

		<style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
	</head>

	<body class="staticrypt-body">
		<div id="staticrypt_loading" class="staticrypt-spinner-container">
			<div class="staticrypt-spinner"></div>
		</div>

		<div id="staticrypt_content" class="staticrypt-content hidden">
			<div class="staticrypt-page">
				<div class="staticrypt-form">
					<div class="staticrypt-instructions">
						<p class="staticrypt-title">ðŸ”’</p>
						<p></p>
					</div>

					<hr class="staticrypt-hr" />

					<form id="staticrypt-form" action="#" method="post">
						<input
							id="staticrypt-password"
							type="password"
							name="password"
							placeholder="Password"
							autofocus
						/>

						<label
							id="staticrypt-remember-label"
							class="staticrypt-remember hidden"
						>
							<input id="staticrypt-remember" type="checkbox" name="remember" />
							Remember me
						</label>

						<input
							type="submit"
							class="staticrypt-decrypt-button"
							value="Unlock"
						/>
					</form>
				</div>
			</div>
		</div>

		<script>
			// these variables will be filled when generating the file - the template format is 'variable_name'
			const staticryptInitiator = (function () {
				const exports = {};
				const cryptoEngine = (function () {
					const exports = {};
					const { subtle } = crypto;

					const IV_BITS = 16 * 8;
					const HEX_BITS = 4;
					const ENCRYPTION_ALGO = 'AES-CBC';

					/**
					 * Translates between utf8 encoded hexadecimal strings
					 * and Uint8Array bytes.
					 */
					const HexEncoder = {
						/**
						 * hex string -> bytes
						 * @param {string} hexString
						 * @returns {Uint8Array}
						 */
						parse: function (hexString) {
							if (hexString.length % 2 !== 0) throw 'Invalid hexString';
							const arrayBuffer = new Uint8Array(hexString.length / 2);

							for (let i = 0; i < hexString.length; i += 2) {
								const byteValue = parseInt(hexString.substring(i, i + 2), 16);
								if (isNaN(byteValue)) {
									throw 'Invalid hexString';
								}
								arrayBuffer[i / 2] = byteValue;
							}
							return arrayBuffer;
						},

						/**
						 * bytes -> hex string
						 * @param {Uint8Array} bytes
						 * @returns {string}
						 */
						stringify: function (bytes) {
							const hexBytes = [];

							for (let i = 0; i < bytes.length; ++i) {
								let byteString = bytes[i].toString(16);
								if (byteString.length < 2) {
									byteString = '0' + byteString;
								}
								hexBytes.push(byteString);
							}
							return hexBytes.join('');
						},
					};

					/**
					 * Translates between utf8 strings and Uint8Array bytes.
					 */
					const UTF8Encoder = {
						parse: function (str) {
							return new TextEncoder().encode(str);
						},

						stringify: function (bytes) {
							return new TextDecoder().decode(bytes);
						},
					};

					/**
					 * Salt and encrypt a msg with a password.
					 */
					async function encrypt(msg, hashedPassword) {
						// Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
						// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
						const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

						const key = await subtle.importKey(
							'raw',
							HexEncoder.parse(hashedPassword),
							ENCRYPTION_ALGO,
							false,
							['encrypt']
						);

						const encrypted = await subtle.encrypt(
							{
								name: ENCRYPTION_ALGO,
								iv: iv,
							},
							key,
							UTF8Encoder.parse(msg)
						);

						// iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
						return (
							HexEncoder.stringify(iv) +
							HexEncoder.stringify(new Uint8Array(encrypted))
						);
					}
					exports.encrypt = encrypt;

					/**
					 * Decrypt a salted msg using a password.
					 *
					 * @param {string} encryptedMsg
					 * @param {string} hashedPassword
					 * @returns {Promise<string>}
					 */
					async function decrypt(encryptedMsg, hashedPassword) {
						const ivLength = IV_BITS / HEX_BITS;
						const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
						const encrypted = encryptedMsg.substring(ivLength);

						const key = await subtle.importKey(
							'raw',
							HexEncoder.parse(hashedPassword),
							ENCRYPTION_ALGO,
							false,
							['decrypt']
						);

						const outBuffer = await subtle.decrypt(
							{
								name: ENCRYPTION_ALGO,
								iv: iv,
							},
							key,
							HexEncoder.parse(encrypted)
						);

						return UTF8Encoder.stringify(new Uint8Array(outBuffer));
					}
					exports.decrypt = decrypt;

					/**
					 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
					 *
					 * @param {string} password
					 * @param {string} salt
					 * @returns {Promise<string>}
					 */
					async function hashPassword(password, salt) {
						// we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
						// iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
						let hashedPassword = await hashLegacyRound(password, salt);

						hashedPassword = await hashSecondRound(hashedPassword, salt);

						return hashThirdRound(hashedPassword, salt);
					}
					exports.hashPassword = hashPassword;

					/**
					 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
					 * compatibility.
					 *
					 * @param {string} password
					 * @param {string} salt
					 * @returns {Promise<string>}
					 */
					function hashLegacyRound(password, salt) {
						return pbkdf2(password, salt, 1000, 'SHA-1');
					}
					exports.hashLegacyRound = hashLegacyRound;

					/**
					 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
					 * remember-me/autodecrypt links, we need to support going from that to more iterations.
					 *
					 * @param hashedPassword
					 * @param salt
					 * @returns {Promise<string>}
					 */
					function hashSecondRound(hashedPassword, salt) {
						return pbkdf2(hashedPassword, salt, 14000, 'SHA-256');
					}
					exports.hashSecondRound = hashSecondRound;

					/**
					 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
					 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
					 *
					 * @param hashedPassword
					 * @param salt
					 * @returns {Promise<string>}
					 */
					function hashThirdRound(hashedPassword, salt) {
						return pbkdf2(hashedPassword, salt, 585000, 'SHA-256');
					}
					exports.hashThirdRound = hashThirdRound;

					/**
					 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
					 *
					 * @param {string} password
					 * @param {string} salt
					 * @param {int} iterations
					 * @param {string} hashAlgorithm
					 * @returns {Promise<string>}
					 */
					async function pbkdf2(password, salt, iterations, hashAlgorithm) {
						const key = await subtle.importKey(
							'raw',
							UTF8Encoder.parse(password),
							'PBKDF2',
							false,
							['deriveBits']
						);

						const keyBytes = await subtle.deriveBits(
							{
								name: 'PBKDF2',
								hash: hashAlgorithm,
								iterations,
								salt: UTF8Encoder.parse(salt),
							},
							key,
							256
						);

						return HexEncoder.stringify(new Uint8Array(keyBytes));
					}

					function generateRandomSalt() {
						const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

						return HexEncoder.stringify(new Uint8Array(bytes));
					}
					exports.generateRandomSalt = generateRandomSalt;

					async function signMessage(hashedPassword, message) {
						const key = await subtle.importKey(
							'raw',
							HexEncoder.parse(hashedPassword),
							{
								name: 'HMAC',
								hash: 'SHA-256',
							},
							false,
							['sign']
						);
						const signature = await subtle.sign(
							'HMAC',
							key,
							UTF8Encoder.parse(message)
						);

						return HexEncoder.stringify(new Uint8Array(signature));
					}
					exports.signMessage = signMessage;

					function getRandomAlphanum() {
						const possibleCharacters =
							'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

						let byteArray;
						let parsedInt;

						// Keep generating new random bytes until we get a value that falls
						// within a range that can be evenly divided by possibleCharacters.length
						do {
							byteArray = crypto.getRandomValues(new Uint8Array(1));
							// extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
							parsedInt = byteArray[0] & 0xff;
						} while (parsedInt >= 256 - (256 % possibleCharacters.length));

						// Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
						const randomIndex = parsedInt % possibleCharacters.length;

						return possibleCharacters[randomIndex];
					}

					/**
					 * Generate a random string of a given length.
					 *
					 * @param {int} length
					 * @returns {string}
					 */
					function generateRandomString(length) {
						let randomString = '';

						for (let i = 0; i < length; i++) {
							randomString += getRandomAlphanum();
						}

						return randomString;
					}
					exports.generateRandomString = generateRandomString;

					return exports;
				})();
				const codec = (function () {
					const exports = {};
					/**
					 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
					 *
					 * @param cryptoEngine - the engine to use for encryption / decryption
					 */
					function init(cryptoEngine) {
						const exports = {};

						/**
						 * Top-level function for encoding a message.
						 * Includes password hashing, encryption, and signing.
						 *
						 * @param {string} msg
						 * @param {string} password
						 * @param {string} salt
						 *
						 * @returns {string} The encoded text
						 */
						async function encode(msg, password, salt) {
							const hashedPassword = await cryptoEngine.hashPassword(
								password,
								salt
							);

							const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

							// we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
							// it in localStorage safely, we don't use the clear text password)
							const hmac = await cryptoEngine.signMessage(
								hashedPassword,
								encrypted
							);

							return hmac + encrypted;
						}
						exports.encode = encode;

						/**
						 * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
						 * we don't need to hash the password multiple times.
						 *
						 * @param {string} msg
						 * @param {string} hashedPassword
						 *
						 * @returns {string} The encoded text
						 */
						async function encodeWithHashedPassword(msg, hashedPassword) {
							const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

							// we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
							// it in localStorage safely, we don't use the clear text password)
							const hmac = await cryptoEngine.signMessage(
								hashedPassword,
								encrypted
							);

							return hmac + encrypted;
						}
						exports.encodeWithHashedPassword = encodeWithHashedPassword;

						/**
						 * Top-level function for decoding a message.
						 * Includes signature check and decryption.
						 *
						 * @param {string} signedMsg
						 * @param {string} hashedPassword
						 * @param {string} salt
						 * @param {int} backwardCompatibleAttempt
						 * @param {string} originalPassword
						 *
						 * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
						 */
						async function decode(
							signedMsg,
							hashedPassword,
							salt,
							backwardCompatibleAttempt = 0,
							originalPassword = ''
						) {
							const encryptedHMAC = signedMsg.substring(0, 64);
							const encryptedMsg = signedMsg.substring(64);
							const decryptedHMAC = await cryptoEngine.signMessage(
								hashedPassword,
								encryptedMsg
							);

							if (decryptedHMAC !== encryptedHMAC) {
								// we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
								// remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
								originalPassword = originalPassword || hashedPassword;
								if (backwardCompatibleAttempt === 0) {
									const updatedHashedPassword =
										await cryptoEngine.hashThirdRound(originalPassword, salt);

									return decode(
										signedMsg,
										updatedHashedPassword,
										salt,
										backwardCompatibleAttempt + 1,
										originalPassword
									);
								}
								if (backwardCompatibleAttempt === 1) {
									let updatedHashedPassword =
										await cryptoEngine.hashSecondRound(originalPassword, salt);
									updatedHashedPassword = await cryptoEngine.hashThirdRound(
										updatedHashedPassword,
										salt
									);

									return decode(
										signedMsg,
										updatedHashedPassword,
										salt,
										backwardCompatibleAttempt + 1,
										originalPassword
									);
								}

								return { success: false, message: 'Signature mismatch' };
							}

							return {
								success: true,
								decoded: await cryptoEngine.decrypt(
									encryptedMsg,
									hashedPassword
								),
							};
						}
						exports.decode = decode;

						return exports;
					}
					exports.init = init;

					return exports;
				})();
				const decode = codec.init(cryptoEngine).decode;

				/**
				 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
				 *
				 * @param {{
				 *  staticryptEncryptedMsgUniqueVariableName: string,
				 *  isRememberEnabled: boolean,
				 *  rememberDurationInDays: number,
				 *  staticryptSaltUniqueVariableName: string,
				 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
				 *
				 * @param {{
				 *  rememberExpirationKey: string,
				 *  rememberPassphraseKey: string,
				 *  replaceHtmlCallback: function,
				 *  clearLocalStorageCallback: function,
				 * }} templateConfig - object of data that can be configured by a custom password_template.
				 */
				function init(staticryptConfig, templateConfig) {
					const exports = {};

					/**
					 * Decrypt our encrypted page, replace the whole HTML.
					 *
					 * @param {string} hashedPassword
					 * @returns {Promise<boolean>}
					 */
					async function decryptAndReplaceHtml(hashedPassword) {
						const {
							staticryptEncryptedMsgUniqueVariableName,
							staticryptSaltUniqueVariableName,
						} = staticryptConfig;
						const { replaceHtmlCallback } = templateConfig;

						const result = await decode(
							staticryptEncryptedMsgUniqueVariableName,
							hashedPassword,
							staticryptSaltUniqueVariableName
						);
						if (!result.success) {
							return false;
						}
						const plainHTML = result.decoded;

						// if the user configured a callback call it, otherwise just replace the whole HTML
						if (typeof replaceHtmlCallback === 'function') {
							replaceHtmlCallback(plainHTML);
						} else {
							document.write(plainHTML);
							document.close();
						}

						return true;
					}

					/**
					 * Attempt to decrypt the page and replace the whole HTML.
					 *
					 * @param {string} password
					 * @param {boolean} isRememberChecked
					 *
					 * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
					 *   expose more information in the future we can do it without breaking the password_template
					 */
					async function handleDecryptionOfPage(password, isRememberChecked) {
						const {
							isRememberEnabled,
							rememberDurationInDays,
							staticryptSaltUniqueVariableName,
						} = staticryptConfig;
						const { rememberExpirationKey, rememberPassphraseKey } =
							templateConfig;

						// decrypt and replace the whole page
						const hashedPassword = await cryptoEngine.hashPassword(
							password,
							staticryptSaltUniqueVariableName
						);

						const isDecryptionSuccessful = await decryptAndReplaceHtml(
							hashedPassword
						);

						if (!isDecryptionSuccessful) {
							return {
								isSuccessful: false,
								hashedPassword,
							};
						}

						// remember the hashedPassword and set its expiration if necessary
						if (isRememberEnabled && isRememberChecked) {
							window.localStorage.setItem(
								rememberPassphraseKey,
								hashedPassword
							);

							// set the expiration if the duration isn't 0 (meaning no expiration)
							if (rememberDurationInDays > 0) {
								window.localStorage.setItem(
									rememberExpirationKey,
									(
										new Date().getTime() +
										rememberDurationInDays * 24 * 60 * 60 * 1000
									).toString()
								);
							}
						}

						return {
							isSuccessful: true,
							hashedPassword,
						};
					}
					exports.handleDecryptionOfPage = handleDecryptionOfPage;

					/**
					 * Clear localstorage from staticrypt related values
					 */
					function clearLocalStorage() {
						const {
							clearLocalStorageCallback,
							rememberExpirationKey,
							rememberPassphraseKey,
						} = templateConfig;

						if (typeof clearLocalStorageCallback === 'function') {
							clearLocalStorageCallback();
						} else {
							localStorage.removeItem(rememberPassphraseKey);
							localStorage.removeItem(rememberExpirationKey);
						}
					}

					async function handleDecryptOnLoad() {
						let isSuccessful = await decryptOnLoadFromUrl();

						if (!isSuccessful) {
							isSuccessful = await decryptOnLoadFromRememberMe();
						}

						return { isSuccessful };
					}
					exports.handleDecryptOnLoad = handleDecryptOnLoad;

					/**
					 * Clear storage if we are logging out
					 *
					 * @returns {boolean} - whether we logged out
					 */
					function logoutIfNeeded() {
						const logoutKey = 'staticrypt_logout';

						// handle logout through query param
						const queryParams = new URLSearchParams(window.location.search);
						if (queryParams.has(logoutKey)) {
							clearLocalStorage();
							return true;
						}

						// handle logout through URL fragment
						const hash = window.location.hash.substring(1);
						if (hash.includes(logoutKey)) {
							clearLocalStorage();
							return true;
						}

						return false;
					}

					/**
					 * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
					 * try to do it if needed.
					 *
					 * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
					 */
					async function decryptOnLoadFromRememberMe() {
						const { rememberDurationInDays } = staticryptConfig;
						const { rememberExpirationKey, rememberPassphraseKey } =
							templateConfig;

						// if we are login out, terminate
						if (logoutIfNeeded()) {
							return false;
						}

						// if there is expiration configured, check if we're not beyond the expiration
						if (rememberDurationInDays && rememberDurationInDays > 0) {
							const expiration = localStorage.getItem(rememberExpirationKey),
								isExpired =
									expiration && new Date().getTime() > parseInt(expiration);

							if (isExpired) {
								clearLocalStorage();
								return false;
							}
						}

						const hashedPassword = localStorage.getItem(rememberPassphraseKey);

						if (hashedPassword) {
							// try to decrypt
							const isDecryptionSuccessful = await decryptAndReplaceHtml(
								hashedPassword
							);

							// if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
							// the user fill the password form again
							if (!isDecryptionSuccessful) {
								clearLocalStorage();
								return false;
							}

							return true;
						}

						return false;
					}

					function decryptOnLoadFromUrl() {
						const passwordKey = 'staticrypt_pwd';

						// get the password from the query param
						const queryParams = new URLSearchParams(window.location.search);
						const hashedPasswordQuery = queryParams.get(passwordKey);

						// get the password from the url fragment
						const hashRegexMatch = window.location.hash
							.substring(1)
							.match(new RegExp(passwordKey + '=(.*)'));
						const hashedPasswordFragment = hashRegexMatch
							? hashRegexMatch[1]
							: null;

						const hashedPassword =
							hashedPasswordFragment || hashedPasswordQuery;

						if (hashedPassword) {
							return decryptAndReplaceHtml(hashedPassword);
						}

						return false;
					}

					return exports;
				}
				exports.init = init;

				return exports;
			})();
			const templateError = 'template_error',
				isRememberEnabled = true,
				staticryptConfig = {
					staticryptEncryptedMsgUniqueVariableName:
						'c1fd7c356359bdd051358743898f92ca6fb78fff959280fa925a368749d141d886ba3f9c9934a308bd0bb342894cc8028a616e2d3e066d69c32c6f84aa61529bdc3ccde45de72f80649cb8819a40e27f1dfaef03b0251a31d198bdc592a806f52f8f45c178ecd513bb65a48f73ea2344224cf71bbf0d1835241722a126a6a1b02793a32e16a737178883ca55ba484dde70465e8f746270e7de6e45a54e232d46daf3213bb0e58d79ae2c34b6cefb382856bcb844fef0bc448f07ac3d0b5bdce0ab445864a72e84a16295933761edcd5c2d3ba0966834d2e22c5a6a02725ba6a2b5f1ca36471dc65e09fd599730b6c7880f15b2ead2c82f84bfe7a9185785dedaaac30e2dd66e18fb54e3468c87a181b40e1d20439d99d32fcb8ca3580e4b05492f8a5f377390ca8153aae87267638fd26e556591e48e72d761220bada2f524e616af78e4a31130e6f76c3fc6f59bb360666d3ba22345a1530b91e0dae67de3516eb6029124c568e41153220d4a054b96ebd3391a65b5288c202bb71c724b300cd7f7939c8988d65edf4dede1163b9f6bcbad75df7f4bfe322fae3c20a7dea5bb5b0ef33330908cc013fecd28049931073a6b3e2ef04680e7170e9b2772f2f65aa6fd74e379a90f7c7c1b0cb295005047ec4120f6e5c209f2df33a2d0dbc01f21fcc3e68b99fbc89149b6b340ce2bb8ef18732e4281243db5200e93d76b5580531c79e4b980ca3a3987e7842e36f373ac9954ca16c4ccda83469fc9a75a131eace6f10a09670a0757669c766f1016b95c0fb46b10edf2bfda18da3515dace7472d752923c5408eaf98638c4908511be03357ba48ca83088f00f32c800aa7a2f1daf7545215355b3318997af9cc373273b268399bef16bc8326315026cca245acc3738e31b45110425448b2c28ea2c15dd14c4ad3e9d641f52eea73b9ede8a3084bd9c10daed7b1ecad7e46eede4a9adea525e65dfe9c9061b0d077a8fca7b76e59eed7d8dc57f9a80263e166fe4f9e1ff0b30e37ecd9ca0cf8ebe3505b1e94bb18a9a0c3767d425f6e00489359b093133b09017dd1e62ddafbcd71a8540a0c68d02b68565ace1eb73603060d41181f18b04cf93e94dbfa223eaa9ed242eee916c1898a5fb34ac47396ab7d5417ceb05c0e0cb7df6640cf943a16d3965fc7a379d658e47a2d7481e4d0d518dd38d4a92998cf27fbd153de7ca461603aa6d2fd45f3195bd9a041d7eed8340f2d55385a52a58da38b177eb41543fd669892f5de77254888f7481933beed8fbe70b338466a956529c9484d2376dba9752e7af2436d87ef29393db3e9ad9cf1b2fe62dc4d078aa31d0aa17890a1489f90928b3f4665cf1865f05e8cd53e1f157743f1717a5d588ab964a519697f32789cbae707c2e14187c41af591635ec52675979a75ed9936778c1dba99c6c76598c9c9e4ff7a5e55a9e8be57f674511ee55d6aa380441268a60898cc8b4f7e82dd5efab0ecad44bb6fdec5a8676db7ba3b9fb8239e3dd021f7ba55052f1b402d4e3fd6e12ab293cd266daa3b83fece435ece26c9d6cd55a61cb96824d8facea3585460621cba672bdb1b5d75c8362d14e2efc5b6db71d6177f0f82df7785afc0e23355b94961711b692897a714f245f59e557cb68fdd2552e1099b181bcd4e80f36ebfdb43c44770cb1411d8196c8a0e312f81ef493d896308195394710c33f41a41801f00ecd4d275bf3682a4e7c9320c36456af6445d3235f07314320c36afef20e0c02f93ae520f45e69f2554aee952fc39271b6403280f39db8f0ad74a5c8ce0854436d2390c21b2fefb887e2d2eb1bb95e2df3ba1f81574f2c25644ac37eaaca9feac7031e80d618a9634b9f4892dfa2df91a405bc487700d99843193460cc3b99093957c0132591d9300c542c5b3232309c6a2435e52d2262c168042319dcc04cd7a730b2987a7a22dfebe4d007f81ea2ce0d1f709989d114db6b29f79b51649973ada85138f13947a7d67baacd4940e603899a012a1ce8e5a0564f76c6bab500159ffcc6c995de726b936014ecfbbbecf2b08cc853d5e1d2bc443bcb5877a7bb5c4c51d2175a95be705d5c03986c55229d43320ae45ddf7ea12dce7abac54455ff1f7186e22e0129abd040e6d0e997868e842e75b785074861fabb5398d7c824204e61cfe62fcee4cefa4d6e79230ee9122665ca59e66a2298bb96db669217d6d5779fbb91b0942321727e91170c3b05bec57f59cb20c044707817250ec18be2313e856e700d5bca2cf8d0f74aecd1822e76e3c42ec0cc62d37641ef91da80551d2f75fa60e7557e6df6fa1e06021255c697fd3ed106f2541d889520becdca8f7f19021554053ef4a55bcab76ad3248773ee047142f277ccef053e3be45fe80892214baa0522f76e27b1a58cb9431b4ba0faee0a18cbd114b392f3ffc8bf95d77d492d6c8b98bfd34adf5e94928c74b4b3718bb55c8314d1123019734ea3464760ad0adb19d28277b9ea944facaa9685c21a398e8d488c94a5782ea2a293ae551c216133a6bfb3f45f1844279df8d8c9ca8c2b75f83b6737e70c1addf787a35228020fc2b8f4e87021eecaf5fc3e4b4796c31170e8e8ccb41b8888f1ba6b67b9414606060f8561babba2a115ec43399ef224c2e89cea1c82a08f408c2d1d4e22dc2cf2882bd4a9314fd05d107349c6c56fe6e87721eda84e30169883aa3693b59a06d0ac0ba6d54d776d35c9fd1fe8231cbedc0ce13c917f50924f07afcaf32727858a36bcdb7bb73c68ab76a031f64a9b761ee4dffe4e1457a61a3c2ac0b2cdd35214c34ef61db490dae55ef8d1c69237f52a37ce6da048c165c1494ed4cdda629455bfbde523429e20613b566f3c88447eb65de10e1b9de696e023c4dc63f7ab3af7d507c3515ba148bc6991ecf169adb89923d5bdaaeef7b3617874208e3310a44e24491604a172cb0284142b37f4999e90b5efd74060d799edcaf4e3893721a5fc2ffcd29db992b0b09069da9a2b57fbea06ed4f5b9b1bd86d398d2be0f527fa51e3dfb1e12b201fafb07f37937c74caef548813601172352c27ed933fefa01689d4975a8584d010b9b9ae0b794bfdba28db7230150bf0eabbace12a1b2844e47a85ace7ecaa8d7a23cb8fd28c6e35dd72131f24863e501ed64cb75f86c8852befc1ab3a6743f7b1488a16275dd70ffda1568ff90711fc00ca8470ed85d8cff829fa5ae3b99af8ea2b9d8ea78ce19e6c7c39765b688491f72bcc16ccb00465a326dbbf0e58ece8d5417d41374cf4c46ba7f3416800f7be447bc0fc890b6bb071ba0d07e386c2157ea1939f5836fdd3d65c99265872f1ae3d48ac3b3dbc352177b41efd24b189850cd181d71649e9065b2a679e4ad05d03716f0ac4add98375adf984940213e3d9699fad30551061c2c087261e7e57825a071fc757f28ca7557d403a0e0d94ac40cd24aaee15f8f03401b6c215975f7c6553d1ccf7f4a8753ac4aca0f15260cf717b7ff6f69fbb06dcd492dbd17a3cac539c95360b3c18a3029593708fa9704ec74bb2ea51a38986d5d2d26b47b4af21c933b531643c20f03a3e860a0c4fbc63b2ba3d7549905235b9d8d7cbf3e91f766839b235f21e3351a5bff242249e680fadb4c5c255a4e5617ba6d3fafcd7abb4252d43b867d9a44718873d02b77ecd1387a3d369d8bc9079cc762b5edede9dc197cf7fe788976ba91c3023006fcca66b2553ee08500a970e2ecbe9ca5e90768a8e1a73a6ed3ffa2971d43d2e99efaa32ce82a3624575214a5d38efc3a5f604c9f9916c18be97157d5f6d92377400fef3c8b18e5fae4cf9f3aa419003273957606b918a4c8c6906e903393c0d02f93bc74bd3b8d2ec48ce03b8fc66d70fdaf006cf5b145da2729f24bb2c4ed82f9e36881332732d9f69c050f15be7c890ae4cc6372c1a0e742a21507496c782f3198e512d968a442108703ee31b2496d6855c96588604d559fb497481d309233eef64b262cfef1ebc587616976439340a1303c4b1c97c062e5eaf5574a0b1ca217afe2840af2681c9afa6dbdd397dd5f859a01d121d7d81f22c5a5a6eee58e36f4a3f0da0118017637ee1176bc54bf950e85c77c02caadb911b7c758b9813c135b721ced1bf7b001eca7633a156b748ed1d2dcab788adf465d8713d7b71b61fa75340e39e85ee9299b7d1cfd4ff073973567d766d416f116d712840f96040cd3151d2a0bbf3c6a3341d3df9fbb0bc791138942183a7760a81bd822ee0e2e64ebc1f3a6f81a24a78e685830cd0a203030e730bf0c97fb41ad1713ee5b32487d2927fdde6f803e9308dea1014e8dcb31e22bddb9534dd3060b34adc1e82b8d60e8a4bc2dc8ac065cd26134c2362362ab24cb793f074fb77859571fa3a9b808f2bfecbd7179ae73c5d49df5f48c53595c307a7a419c8587f130b02797644855b16e550cdb7aeaac1788f8d995eba2fd8e17dafcd5279badb6b74f54108195bcfaffbd166e880c027354bd5ce01a6ae68916501d6bf54137048b494d94d578b38c8f8cc69b85f840f1fbbfae59959f3d4e0cb9bb75b88c5cf8107e9b5b2a1b6410a452038e6e8c31fad75a973483c8fa0c40ea33b4bba54e10ad9a037f141bcc5d7b83364eb8ba5d73e570fdb709288d87b9b4aedd53dfdbe53b645c63dcb99ab37f813824c489fbd7b2090b9e3a9a7775a1efb862984bd014c425d3d6fe44c439e3e6afd748ef7671915c6c64c1fbd775242081112ea6609e4db59d5e734331e4baad3897a501b31e4236c579bce21eea25e21f5736c10d0ace0eca35b1f10d45f7fe5a0e0be12842c67350019b7ac80dc4e369f5451c426cb3d72cfa31f2dc8f2a228cc752941cd2f80d612f65eb5ac60ed37c724f0be194ea85a96e97a4e201fc6b1a093f099ad7a21e36497722a18d5e9a16e80ef5a30c17a8210d06ba551071f65e096af61eca2bdbc232664f1d2f2f9b3aca5821cba95f0c8d2dc27e37b0758f788048e38a8e7866d5c1d6d883b6799311e0e9ed4d8eb47fa8508af59b7c4f30bf5bbb941ce561e06476c15f78cec555422800c31a007fcd7c85b55241b5636f1d3c3f5301bf3bb1455de1eb5a1e7a1ee5395eae397f78c4e1fbdf9ed70968bde2d8643d80c006f0ae21ec52a68e2d2a3aa66f784604e54f255f33b7129109f578c5e959e89a7873ea5329d3ac6e68afbe7d4b41e5dc6ad3f908e4805513cf14c3cd211d44fd7e1456ea60f1dfa20ca57ff421f8c8c4456d8f4c7780c0e8982fcb462db8b09ff4806fa3e698a55ceaf8539c380f9691e8d9dfdd92aa12444ae564d7d14ea87e6b66aafbc5ee2e68480d63730bec60a0496c4a650310184cf688e208dc8463b089124a0237bc332bbdf65a3c239675da9922ffacb18b03806102da658251a8224ef1da24c10d9170f0443317a30efed872b11236584cbbb4868115dfd1b24823a9d27e89afbfd849dd80a16d65794854613f66db01357739dd2f1602864b8f5aecbc015f612fb566e039845e9ffb3cad8cd4aef8b407462e7903dbfe699845c87ed97b02b8c362e5b1c75392309476c12fd4a3c4e0ebbf507c5152c6d4bd070c15f8fc7124bd46bed2f748af2c314adab0e6bd9f9c096d7e97cb26b00ab4666bc97e7ee55a5d62fb16c9f76bcfc4df85754ceb50991a811482a611b2cae8b63fd3818fbf99b3089319fac7bfb25ff9582d31114f4c897f8fd7d6e0c1249dbcca3856f5e9d28fb36f1860f951fcaf1c05c5665228b6c1cc4025179e9e165f9be95b28c67011656e3f6aeb16dcdac4d13251633f85d7f9be3ff0eb2b3a4bedfa49a1cc7de8b08d006e241ed26ff598f38659115c5182b85b1d13bdfdfcf7b9224daccd990aa046016f0b9312d08d9d253a4d5eaca9daaae639aef23def8be6ff6bd3194d3dd0242501494e024564413c42ca8fd6bb2d2df9e52b81042e725f9ce4173935a8f8941295fe02820146658a5a964f2fde714605fed965a841f2b2455f3fdbad542abe8d75284f82b3fa5c220dc0a89c91f08768e590746c5f96691a04530611e16679776f45190ac49108b103f49d7f99fe8d7054e037239dcbc0e9dad4bd779f164cf2a87cc2eee4eeec8078ffe1070c8eaa0770954d3b4724f4dcf6d85e03606beeba2303673740590d0ddd81161ce903d326a15b5de4e9c7be4a94c78ce7162ea05efca180e80ef46791e517e3db9e5c59af136c0720f55f3e900c94153ea922f3e0f2d71bcf5e4b31b7e8798032e88f487505247aee91c0dccfeef242a830a77d87f22bbc7849bfa98269e176cc80727936b38971a33d81363f90ad10ff33b7840f9bf7c7f1208c3262788d10d92f2983900cec556a1148aef25abdcab72ac07e54efa5bbc952cfd4dad1be9d11b2c35927d0f83fd5d5eaed4967c60fba14a7b0a75b817d72e0de15b96aba656f3451003caf6bd7aa28f961b8333ce8261f39222a8330cc9690066a30201dd97d8b02a27dbc1461eef30595d1319cd7c2e714187f2238ede7c2db5a35637913056ea0a1b4c49434361dd5f92ebb28e4322aa18ed659bbd93b5871255e2c3b3fbb361f1783b3582b8badc05ed43bd79b787d38d46dd5de717d07c8b9cc4a0a061e327dace826d0b8db44e89666730401e467a6032b2f14fa78c898e1575febcf55928315b58bcf5b9f6b26a2f6643ce99142a3ed06ff0eae2ba66d49b302cea650b2b6a9dab5ebd1747ad48cfc15227096fd73b1c5e2dd6d7d3dbd4a437f1a5b379922f9ec1ad99257e1301e49cb1a3abda67afd4d91f8292e271aca1708da651536d399b62be958aba8067326a23afe8ba5d1dd1f72304311c6bd29e3b0e663c88312bf05075dbde3d7638839838c2d96203c12757dca0975f0061fe1330815b45d5ecbdf53c29f2669efde750a3271638f9243adf0ab182bbc4b14b1b9ce49d6f2fd92e5e0a7682ba802cc9ad06ef7af2eb71f218da01a13627ad98d285ac6cacb625b8482b79e6ba37b1252348810d176a461b62dd9e437b8bada656568b191291d0fe741ab5d8411ed71aaba1ed4c3b7ffdda1211faedf867b7a9bf4e083dcfb3562e1663a4aa2e7b682e536761a8f760d5469f33613ab98629c7b853064e37d6ca9d334148ae4f0d45ce9cd8586f3beda6a1f00d0d24c4a12c3a6ebf094f5a53156c0fdc2303d1134974b61e1cbeda083ad53288f91ca3ac6d5af289753aae56411024daaeb3800ae743f6876b39884c6c80ca9ab738cce6105da201b3302713e7cd3f13529f2a1370c05f4f7942797f81ad0ba2df087e6bfa009b57af5e33bd410ab3ad8687dd82dc4d2330945b2d74c56f353f7a734f917fda8b25cd371f9f99938142c3662768b8db4d0ef7cd8b003265cf87f7f4398cabab3e8ba9f705fb60d85f7dc3366bfa7dec89c93c5edfcb8d5efa0f5229b7d65f240281e516b6ba1d7606a701b9ceb0639af78db35493980a97b3d382089d01fa5b5d9fca4caa8f8ea6cf90c7fa85f692ff7ae2180065a6a2b07238a7911d37f15c0e27a7c8a4711f3638295b508208e290f5fa6e04962df94394898bd3b9f5eff933236e7ce0839cfd277ee083f71698ddaae7cfc59a9a57f6848ce61c5d802db799e6884b781c650a723141e726e38b9661a3de7b23270e6a060a4648f322bfbd760cf09029a6b264c7abf6ef6530f50ea16e16b2033d6dcc35cdc428c3ca9bd41545afc3580e1c2531132f049acf98dfc240bef12a2387ec80c35835421bfe6a12c64b95342eed51d26865ef87740d070fb22f51b03c5805d3ed57be55af46ab0ad8861b672eacf17fb43bcb80af6a49d57b25d85c1f38fe624bec0f8882ae4a0e40978405e247767878539ff1d15e8337f7a2c478f6a7e5481e98938e55a179fea39ca159f21c1ac297140f604e561b2049085c1d889bdcbf7ab5d351cc6e1db0eb470ff74e9eddb3e0ac5d301611ce120468aacd19208c8cea3a1afd439a76cdf96f62273282e8e034c4690a8cadd28ea73b9f98a7499316f16f999eada4be786ab42cf4ce298981de529ad7c268d2e2a55b9d8bcc086f74575ed3e21b81b1d54b6b7cbdd58714164b4f6cbbec5fdcf8552b2d316aefe4f59149ca26c07fd5585715cb0159a24db4038cd0cdd5f3dec8bfee2978816e00e23bb5c0f5115f32fe1bdca25bf69841ef4dd47d5b019b51c51afa824fb3d7180b9febbb9a71b08419a376f34aed3c49a69fa82ef30760d5d94ffda0d218a4e0e66bcc49ab5fa2e4098fd375dba2d0816a56aa307d9065dd24d4764cbf24664da49ffb092f5062ee2ed751e95d5488ef3a837d1e9966666f08831898f90ca81fde73d20b50268e159625841b3b22baeb29ad05272e4835e02b7fe656b2d93698a9ee85a6010031bcc8489dda2dcc8951789b1fa49bcc9da7baa1ae8c094c19274afc729dae597de3e71c5f6aa25d6727f796fcfdf501e3c965121967b55211ff7df8fac171586c645398f104bd5fd033026460738b627988bfda80d5d60e95ff400bb171bc9b80db2b548650887cd5909f1ad19b6062eef7852f31b6476c1dcfe8a1df1228c0d590ebf2e17ecf0e294640f527f75545e83b15bc3a257498e0da01a20a5174b4d9b09d63afa456e839e04f7dbbff6881d893ac931a73150113d458808a1a9278f353f43199995cf718e33b1cd182eb2ce38b013a91bcc7ee5ea8647196affd92901a992fec10952d0d87e1e4d364e5d1933f1a33e3c84c1907112461b1ddcb6823d97d6627ab5bd7e3f7059c0b96a73ccf40e37b344bf3b995199e16349cbc8c2a5179217c7bb3fceb03081072d7494b0186627994b0ceaf51e839aeb37342a134eed0ecfa20cf6ef2c5bce9763fe4d8a40ef18401a93a902614f50a14cd88b96ed36e32f4daf844241fed2bfd3957dc29ee38a3d19dc036fc04f517cc35883b646000029d4e0ea94a86afb9964cb48f196216430920febf632349eec0139bf4535f9ead51c3519b2d836d9b462e030bc15df2922956b0866c738f714adfd93328cac3a3d9fe59e347515200daf050c4f33334cabae83eee012b886c58820e62561fd23c0c0f5faca3565a1fbfd8ebaa1025ec804dbb04a2a156d14f84ef4e20add78c9b1476e4f726306a472ffd780960536ea9d6ff3a7a25f11690017d18a7fed8392481bb94a44e71b50425987b7c344a77e078366dd60a9b12dc9f53ef282058427706aeffced3f6eae3e6c05e68a1783b80319623343e5f0367f5459b82883b3f176be6c3181424a3223e0e98796917ae7c78b2f7de8c154c3fb334d78264062c05de83fef27b182bf3e44d001c7bd2aeb845e8daf7a8df7ee91dde769a8d59052d5c5c635139894fcd37bd68a272c7bd77eb76cff1e5461bb5864c5271e722d155189f938c7dde852a8c933094328bc249dc9b8da3040b90988a400065be3f67e1ef9a4a0bfd328b7b444eec7c7bfe290ae5916ccee5893a7eba53b1256ba581532b3c57833ca2fa622d84668a24b7f11fd2ed8873dd597e91479eb52f32430ba5bebad99c05cca0460a51b7a654f68bad87656ab64795f04e4338e592a7dcb1ebcbe3c5bcefd72b2ee5f74899f07889f0459e5c44be5210a167cc338fb28df36ac306c4e883cd7a3bd15fa259d363134cede6e934489f89339fd86e7a24b006840fc8186ae9d801df314d792ad0d189b4c70f0d9bf56b7d1a0ebf8720ab525258f04a1e14fc467327cda2ba75bcb6e9caf146fc2cf9e26670e2fdbc30290746dbd4dd3635b60f476ee3d17aa2284868455479fa684c68f144c9cec84c302f56ad490e5b3a13b40f32154ad73d3b6d88faf49cdaa163c70cbd77df6e08d25bcf9f3a3ea61bb769de0628232d863cb17fe893fbae650871b3ba62cb2c5703341459f81d007d08695b3863d8bbf4d8a6ae58b4be537a62ad58f76d98210400d648a4689a29758bd1538bc18650f12628cc1627694ca4b7acbab233a54eea2c8d1f6315c3911a2377c44467934871fa7c9a703f0d3d7cd5608c13d81aa4b8ddc4374b19d7dad4d34f5a7eb633d8c3658bed89da3fde26c1e3fc7b6e08529afaf1b69ad80710db5d0a1736f3fe19d6d3e3b4a848d34a33b6c406b1e6e46e2f638b9d6e0e470f196610c291c21affcfb565bb35a1830386515a37bf0cc36f728ac9671bf6d04e69cdb20de7dce9cfe972a3ca1ebcb9af733a5fe7a41d02d48e44dfb67f5a67173dfe4bcba7487983e34fa3ccd7ef67ae4914b2589a2a09153c8044f4667f1b21eb7c201974ba6d60c63f1b45aef63a8701453e4064dd745641bfa71b499e22d813ae81c4d906662340403a7703d6d05fd25f2360a5a0c403565c291b9f4f39d7a2cf1ec91992257eb17d00e2e68b643ea90ac40d868b99cd2e4bcdd944e907f1e8f739f0a878a5b68b12a73be26c661b50ff20d82b65d0a1fd84d62b3e4ffe52a3a42a352c0c1fa73b524372d9aea67dd78c0b19b71637af5d15854e562a27efebb76ea9344ebca3685ab437645be5c2ebf0675f9ca383329ba95dee4ba1689c2c896eeb7a588f88b18871d963ee4b58417eabc881d4f265b3c326afb810a55b0e3e83142a661fa3f679c05afa5d892ecf4c3f0f66a71d624c36af830a8ce6d2d53200423fbf4d45ae8cb44c9c9e17c2eb9fc862508bf6521c5a7f72384a5093f0e14e1781d5e83aee95fdca6b434e8826a39dd3766b2e524f02b8f3090e9a8569625da0a35d469982126a51406ebe366b3f9cb240fb40b306213816f9171a25f9a85061751c05b949b321b965b363aacd83d45def9c34fdf9760b0d1ee83b3bf6b4cccaaaee48514b6d7d1929b5f87d39c5554c6b3f5536a509b8727a824a939e2245ea6502274279aa0fe287fa5195e55164010d57a239d08cd8f7b46b2fce1cbb940f92f19f8236de64c301fc8eb0122504f5efbeb8aed2c773a1f091eab9127d490cc055db6d7ab23dd48259c7780c2636ebb36ddb6b834984b3254cdd689522427361c52f7a81684409b3c69a01e9512c5774dd144ad57ec56be1bef3d17d3e05ece46ef08adc85ce3cb5345c8c955dbf377142a7f1db3670800995e7a3ac9c9993f5981d03c465d7a18fa4b07f2136d0e16c5c3e0d2a29af6364c431ed80cf57b3ae5f266ca6ceae69870972bd97f1b7ec38b253c905c8c71b655b921ee4b44279627e732d84c912e22a9313d39c5ea9e31b18faadd370b9b321c87e869d6e42f0644ad95b9ef7198d06d343e38e4ffcb309d28ef87cf78b70abc5098ab32334e6b3883b970f49a0b2c0913fe2dfe54e00124f4be0f15a9a5790b5af69983264ebdb43d43b194ffa55bccf6ad4514944e46ca758dbd5a508b95bd75c8e856bc8c690b1e97b6dddc4b7ce4a946810d447b81298a2d9cf406659193aac48e8c442d6ab3d9cc0677f492a8f942b6c724b877303a3e57ac77cf2d769c3ab1acc39ee038fa4a831a05e228b47407a6731a7adc70cc0d9943b7cb78ddad4c62c3f564dba511405ac55bdb8c116f1950a69e53db5f2886b2824fa155b0b8d6a2cc373fa2701fe97cbcbcf489062ada98ca1d8dee3a33986c8602356664bad959aea3d9101ef155e5df4c88c9cd0099e3dbfdacc5866c5c61525a65a695935bc3ffb852a3ab6a78aab2046cd44e522496c034d15406d7ea121f54086db4bcad49140062a852c9abdbcc7249cb606f3154573329b345822800acd7ee88dda5d455562fe247c648eb57b5fef4d7b7df7f865928439cb3486a636faddc87a83ddd5e0a68d1c901b26cf8ae612a52e1d5558d0b97b35bcc01f26ef405efca6b059ee65a4dc5344815fb85d130f4cb6000509c15a51bb5ff7c4823274cdf75a7582dfad05c4980ad433019793986b125d7581d0f9db83a2a534d826b9b62a12448e4bf64f9d76696880294221abe5b8110dd0812cb92dac9f1964bbcdf084dc8e251d771a4b7a77bb21a291e2f35b0108bb2fce04613cece9736fabac7dcdcd1e5816c3bfb8a9d6bf74273c7cc7b2dc6ffd2a2299d0746d16ec821d6b059cfc10abeb6544cf8e2c943f2ef7671aadc8c329edc9e9300bf34c7245cdffa8da3ab7f4788592091b9f2d9f98a3af5c3cc5177805ae1cb98f745f74204e0382cda70a7ca779357769404539080d0aca746c2b09a872ce0da7fdda1d936a3a5718cada81295363a8d076ae835d6a08462e9ed2d5c674b6ddb597c557e4dbb929a425a48423d9ef2e3dd17d95f2ed97eaae92ba79eb1ca077900b4f2dfa32654f29e0aae95de23bc93aef394049e3746e97bb6557f9d3f71cce68cc4aecf8fd293799a177140f4e9318c8b6ebb26ea0eb0f9f8821e302bf46acb11274d8aeabb49de4c9dcec9fd0b2f52a2c711f3e4a55cc243508f66337828e330f6f245095c0eae7855e6fe7d11ac7598294ef7f803985c936cc533d20f4cd2d0a165fa10fa68aee5634fabcb732683e43c79386277a40b24de6f2643c697751d1f451c61381ca1346516fd61c498a8c80579bf085e2a9c1ad7ff82ddf8101d7315ea415577f1092dd539b6e3fe2cf61b53b5ecec0d6c1df8a511f2913b974adba1e96b38ebf8921a8ffa27c85d21ee40151c601f99291ea60a5d07e59ac5c55ef242d4d9bb73cb7f907e1a8fa1c52758e9ba21496faa9ce18dfd5f4251c880bb99e2018ff27af5dacbf1245c209f398bc0dc7eebb44ff5e2bf62eaa6f7b26a46fdc379e3c8d8675c67044271eb77987103ac45474ac06b2935817c280aba84bb7b4d9805cfef7a4579629453b4abc258f442623b01515c15cfe3380abaa4cb1b631b6236c92f599a77b1ae01b71f9e080cf15b35a127652769377288f17a4fe52bb5638479b9a89152cf29456c459e0ae61c6e0574d31b98df1a31b8b61ab8c17a59d7b820504ee98937f9f1f5693e7b1233e213f70361a732d05fcc8bcece3e1edf92ced59471ee3fcec1ca8133e024aa085185d10a1fbe79f9c04508e7220e5f15bf9fa0028008a73cf168194a942ba57733496390b56dbf14cc2a3c3dc75222b71307f6aed27efd573b39d1a0df232d578bb9f6122296b75cabbf83dd5b41260355035f167accf1d12c51c84d78d252457bfb353e486b6825c28c6109991b21aec20385aa671b47c73374377a95542d10a3a13afa5ad94d2ca553ebcdfcfd1e9713c7caeff06e8af0faa48a85445da6a07dca691aae791cdae6f85e0870bd90c30e5cbdf1fa797a257bf1c64bfa6bcc5b08cbf4f5619c6538adad8abac64ecbb3830c240b1be4e06682f9167c6fa74d9977f41901afd574c14e69630118edcce8ee7412a729b5c94b64c6711b0de69cd7bd1c46ef238fe9bceb509fcfbc382c0b0c29b8aeb6d963286ef12d615274a64435875716af332b6ac56af62bf9e1efdcd9b531988436b68ddebc5df3e12c5aa73066541f7460a96edecf40e26c3259c10c664e8377990746a24286d3fbc6c6d674242f0a4e8019f3974ea37317074d904709f1e9c9be9942aa3600994e57771ab13896e479f5c622af0131b810022f9d32cc3a0dab43faac0b78ab69fdbc9db8a6f19dea86ccbe6a5d2793059bc9c43786dcdf640f14ba5ffbb313fb76a4898345a3eaf1409d931a90405178f3e048456f02ad0efba4ebbfd5bf64e04e8c73350f98b64a780165d28d67fda754c82353f1244a1983230a72a5329d94e3e208d7d0d2f88715e8dee70530299af075a5ec436d7f9e4cb4ca2e586dbe5ee1cc89c6d7781a2a7e4d008b07dc351a9103366ec37dec9a42350f48a223c7803cc08b86804b0c79a6eb0da9e96577db11b00e1b61b2a956d0d9d6144f5f4843a00f30662554d08b21bf3e6b73c489cfdf9fdc7029dc9b78495d232fc8459b764abdc60ef8f38e62a67f4985da9cf3efcac84883249eb420f198a35ca92c719b1a7278e197b79ea45d81b31ca50d3a1c23efb2743c171325dd41020466a45327e877b178dfa641d7885971e51e1231dd0a2e4bd7560dbb95071d741a379b10bf58299034016e0458600faad7b2651b2952103e07e17a606b984006e5f2fa0c58c256c793e8b8484b6c3d4f79ec3e6b6f8b02cf1615c9af77ab0ee8f39dfc01250d491d4e0c2a04e6a5e8016297ce53a723567b72e6b6313135c46ccafeb83ecf33a3dc77c9fbb67f70117e0f2c94eb3b7fa6e6599beea849ccf14c9b88412f5e4bd23cd918e7ed8bc5854f1180202928291362172311868737eb09531733973e70ed396ad97981ed21a04767ef13e5319c3668f2f34627a604f54f03eafe8d214738c95924c536af8cc90fe884a132457002aa3a5427b4457102f8b6a0e0ca71fe89a350cbdad3361ca11db212a2c8d3e7d9b4927983a7e6528f05d093f75a9a9563510d63fa787657e53f95fdda52ff9814a6480e3f914aa0dc668e21c76ecffafdb8943020a199af72c6d85a3138aa088b69379932d2a056f48a60d9764589a1987a5d0479371b8f6bc6d6b6f7523fa7fcf484569e596837331a23437686139f50898cbcf41bb27d5890c1f3fb0dde086c8f66e556ce0026bd14871ebd527d484e73776efa16ad7eb2d556031dc0728cf89590862a17e8ecdb943bc66905a2a5b5a28badf99bd8cf0b33df8e6270c8b9b1fb7d5d12553611b0bcab4477c2eeefbacc3b1ad430f6a0e0490fc8d875b8514a56241a2895e967e7404c36d0f1707e4042e71cbeed02bedc72626485e78f7b534f8e6ea354c9c1b9f73f2a611b9a0ee21941d9442784c8ff719702a8bae784253e7df8a1f8a84e588a2a24959c3a5eb6fcb33c48f692781ca20b1b99ca8dd6d32b493e66019ebb7dd7040225553a03e78167cd0bba4aff6d94c3cf31b1834efcdf110c1b607bfc936c8167052959328bc1a76b679ccf3cd4ffde4291c4416a8cbfec240c876cb7073cba1ef238eb50675c9a3e8a7b1d98cb77faea2d5b92ade3ca73ab094a999c6117c1e9bc03d6fbacd25e7c332a14d978488622a2248ffb642c9452fe26552b965a326f9af58820b18d9226b58fe0c776d29b6cf9e57de5fedd36ba59124b80e8fc7f4b7aa0fc80db22b7bc4180360f093be696c401455dc76ecf7199e3f034dd3505c3affbddde0ed30a0f2ea3747cb2e52b3c853cff72c77ad2527bd7c863444bb15260b5556bbd4758dc5d95eeb7f954785fa850165a3055bd1c1613edbd8377666f1c1c0835903f5ec436aa0771043d540fc64c97889c1711d4210e1c00d9794ad478a62f06b5811a1a95c81251a4ebff0d9da82eede63593811417bb74a30748653227d3c4b22d760a9617fdd6120485cc9adeab28b5e536afcb30ccd43979ddb1abe968871c24207e4b3592b47098412c1911de83590c8a2bfa3199d10d1d2f8943e2751451d6d276616efe5ad3dd25f29df1bf7f64ec1c45a5dd43fcddbe56585cc481ebe99d4d895419fcf1292ac1cfd5202a797cc0bd570977310c2de845e89823ac409d33ef39a5e3ca9e932350e52263b1a1c7c394ef225b5dcf230db7685a038f522aeb445adbcffeb8e0572fcbce5d05f0b3685972c474031a891732333e54ff65cf39abafda6518bfb3bfdb225f910746161126a86944a63f158f831196157ddcb66f40363d0113741e873941aab6184809aebdb8b6ad3f39d6f4cf2dfee3777e073ac739c1d87c8b2615e152d592aae2d7108ae7c38a7485da0b5b3be9abac5391d6a470a2926e3caf0f1e08b428fc7f69560290bb27c096d6286d417fe93c4aa18e490d3393d7d123f72a1c96bec24135c33cc258d2b199a8b124201cb12158079c51df46931efb956bde1b670341f5ce973c78463c6212528bd86d1a283e6fba4de3b1df620661387b69447f6e42c06d7983f7f48829a56e58d6f611e1961a8fb242856e8dcc514f715880586dc7c1d6ba7fee56fc27966ea731368887765f047473fd5b97e8f8b22e0897e506b95997f05225ab67924f9618be161adbe5993ad7efc12be9d5021a9d9797c95f3c74bce606303bf9287992df569a5048e8c30a4ebdf0e579430d1cca6e0e554aa64c906af13a665cfb59e1f9d90ce46fbe6cf6e40c3f915a3d3e5d9550fd8d0effc52a853db3e0e23db7a105457dfa0febdaab85ddce7db377cc535902a2afb60761680b310c231b7bf81f7d3b07ca6411b8072bfed90a2d443b90f7558e5b139e2d4c497fb43e042b7f926d63096b862c96891767223f76a332172194bfc26be85beeadab1fe87c8d23509a1311aed8701f3cee8ffa6432b307b95483c9b7499ea880bb2f5fbbdc731b98f967dca9de5995749845a0fec7333d846febff15a2b31a3ea7aa9965759a53216a9e2a0ba917adfa5a127fb93744316daa5d3b1ebfa6c7589526398dd2518065bb2f33664799d5dac9c1b9aae950c1eb234b5d1b3694a57a5db340356f1020944ea2bca036f298e19dc4318c3428cde34dfe01745847bb814b804cf1fb62844e3da321f1ef1dfd4e20bbee83d04020049e5b639c5af55aefdadb017aa32c9d6d7f4721c8d87868f303154fb4fbfdecb0b09d057243dfad495828cd3ffe0bfdbd78c21b319ef11dfd4512569f764e04c5aafb91f01b2cc6838b5a87119179a09c731e830f859204e165549a6639c6f38f0c1731200db81d489b0e11c686e616bb3afde01b2358fe0a8ef84f3395fa6564ea7bb6d5e75e93ba76422ea7647c142e1c91e58ce452d58848a3414bbcac591052c13a2ed28d18296d93fa98a9580ba2b2a7138c0de8315b01b3466dd263656ff28371b6b2bde2c42ec2d22ccc305d78d402fae4357b9222be5ccecc189f77a486f94a401d58dff05708063ae479bd52eafe50aaa9788bba1f27608d29056043f35b3f2d24102bc8dcff8f19533af9ff68297dd335469223d9428114f61fe0b3637f25940c884bdcb3bcf42bac21c378ea30b26f8ba60046d7f04b3e194e22c161fa0460ab9a82d4227333267a80883427b618eb5e8604d83e11275175231004a67a4b5f52e49988445a401fd426d8d44787dbb347a82ed525e18cfeaa3013854024ce6071d2f6184af2b5d3c005466e7e6dfe7b2ee9573ca1aaba3a4af05375a70449a5c9ccfa46908f0b8983c79ea5c7ee47d624c5a44067543c1dc176d9d2f104d1e212e8464c3ac5955322d09bc9894573f4fdda08d34d62024f65b4dcbb58ab01b430cfa7c7b64af947375bfb9fa72314e966ff556696e7b439dd2b62ee151ae5a516655edcb7774f389b5299d66ea4d002525f84397f7eb43c2e750a1f5d5fda4b8ee409a27e10e7d987a4feaa8766c20ff0dcd589f6fb8a9e9e3032be16575c5203c0c7e1c042aa480270379bf69aec48c0e5e0b45b52ce755077aa7bc2e2d827269ac11ce765d5ab238bfeeda0b498e70637482aca8e94a0baed7bbdd848ef56ae694cdee56d290c463fdf83d38469af928d0b41c90f7a42c1f632e9e9dafc7696044c3ce4f3cd034b5cf13ba1f464475bb70673d927ffc78181f08171277b3c18436c1440af08e278217bcef2670135af18de9046f91d1681214c232564295430f19c00ccb7a83b81a33f1cbf5c402ed9c4161a09e90e226922268f91634698b607e03a2170bd196226e42bd321828092348d5b8152afce2786ca91a02bd99ca9eda367b5ac4a8b3382faf37f0b070ed8e5b8b09eb24bac715070b2a0e754767781665df4fe495a5d0839c949d034b02016f7722bcc5a8ac932841c6af0c699f4a8ad4fed02ed8e49054ed9e156592b2c87a986ca8ccc205f19fcae2cfc708ce2a79ea40d7bc3a7a11a00e69e358a921f9fbd45ee15ac4f3215d5efb1245d82b1ba7925de84f9e88f2db651577285b61866d27aea61aaaf0cf3368540ebe12d40570766f667515f96605faaef620914e42be6b79b8dd3769aa3b5dc0b75f37c0edf0d20c76ead6219a1cd11062dacb49f4cf66cbbdf20bc3ffbac44dde1e04a7ed91a1104b2e58701a71bd148c7fbba0188f5c39f1058aae5cbfa951ceaff81f0313d7fe08ad4e90977af0f8f4e00ad13d0490c79076415a1aa1bfec1f82a7f0b43f96c6cd2a53eebdb68a8db6bc90d1e18411bd177ab8c12f14ad8a0d4702f30014ae6658547fa7237d40ce4a1b6f86e6be87f384addf7d10cbbbbcee7987cab31a151e96f1625800fc99c9f47cbc7a3437061ce5a0403fe20b7f24d6ca7c1db716c0c6aa75e6bb72619756eac3ea70f972fd316256832eeeaaf069cd1432318bcff9519bf4eb83c9edfdbc3c748bdebb01df1f4f81afaa015b147bd4a52e9c3bf46d8ab75ffc6f0d876004558185e76ba36eb5e63f86e5b05043702e8f22ee2601786b70e2d50832e20ec2e3700107a21cf69aed497509c65d48e5741a44dbfdce09836bee63412b1d28d96c96390fb7af2044762ed101001a2b4c953a380fce0a8fa1b45f04d1b23a4f4bab7f8819a8927e4a3b316267e617fc0be69fdd5e230dc16e91c8438d791ed08c8fcc5c5afcd97e9e3b5bc77adbc7fc0137e896a895d622d7a0a808443dc6aaad8fea289c75a049e6f81f2cbcc33da0e607be5e136edd33d64304f12b205b28624e5426503c8725b8661e2b1d489b5a5cf22465b6bcbaea48cde45701087bd778a0a8221589b8864cd38423555999b9705ea0eaec2e9597ed760342d36c65e1a21ec43979ae470a9a32b46d3df3a330beb4c1299440c7ed4191f7aa96ccdb3885198d0f52016ee8fe9641bdf1c5c49fcbdc45cb7fc25116cd0737a42bc9910b512361686619ba0e413efff5ce65caecf6de3dae19f100066ea1964bd296894a937200841a3570356699690c503a8ad31000a357fa951d6b7a09585317cf08870bc549a6fafa10cd3a7a8cb3459b98124f708ad8fd513e7cb2dd87a15f2b4d9fc75b570b212879138f3b8eb42eb31036a0ef53b4d564497b3817836e9ba07e0085baebc5f6fcf1522e7eeec1fbc097a06bb54cb79aff6fc44e8fc319baa175026a9f7632a4c4e523292febb69e13a8e55b219ef2223c8228aa563e8821f4adb827dbf3958628fe53f07e407f32b2498fd6721a3f06b7543d38dd62cea8cf9a326ba71ce8d4b337cc6b0ad1936a25ea6b3652531057535acd1bda2f4ba6345f4f9e0ddc52875f7121536f87bb4037580eb9dfd67675503579d2738c6906d4e1cffb231bbbbc3e8a15e5ccf7cf1dc9cc935afcd88e22370d931065c9e47feff275ff9a14f7085cb65aa542c8d748d4405b81c31ecb85365e953d6e88ec0c22ce310c6533cd98fbba67b6491d3c8e8ecafddd47f21bf6e206854c3f682fddd1f384665afe497617677b0e6ee8440e8dac0dee5422dd7e426723e0286c3587c0816ccd4509b93cac8f9b919e1a803fce98e3f1de3d709918042a565e6cafa80805dd371af5b3142bdf74d9a3c99403cb75d2011ac1cd671c52c2ebb63fd09937629448de62f520f5d43718',
					isRememberEnabled: true,
					rememberDurationInDays: '10',
					staticryptSaltUniqueVariableName: '6b58228660664135054657dcf552224c',
				};

			// you can edit these values to customize some of the behavior of StatiCrypt
			const templateConfig = {
				rememberExpirationKey: 'staticrypt_expiration',
				rememberPassphraseKey: 'staticrypt_passphrase',
				replaceHtmlCallback: null,
				clearLocalStorageCallback: null,
			};

			// init the staticrypt engine
			const staticrypt = staticryptInitiator.init(
				staticryptConfig,
				templateConfig
			);

			// try to automatically decrypt on load if there is a saved password
			window.onload = async function () {
				const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

				// if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
				// replaced, no need to do anything
				if (!isSuccessful) {
					// hide loading screen
					document.getElementById('staticrypt_loading').classList.add('hidden');
					document
						.getElementById('staticrypt_content')
						.classList.remove('hidden');
					document.getElementById('staticrypt-password').focus();

					// show the remember me checkbox
					if (isRememberEnabled) {
						document
							.getElementById('staticrypt-remember-label')
							.classList.remove('hidden');
					}
				}
			};

			// handle password form submission
			document
				.getElementById('staticrypt-form')
				.addEventListener('submit', async function (e) {
					e.preventDefault();

					const password = document.getElementById('staticrypt-password').value,
						isRememberChecked = document.getElementById(
							'staticrypt-remember'
						).checked;

					const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
						password,
						isRememberChecked
					);

					if (!isSuccessful) {
						alert(templateError);
					}
				});
		</script>
	</body>
</html>
