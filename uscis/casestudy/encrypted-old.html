<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>ðŸ”’</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
			.staticrypt-hr {
				margin-top: 20px;
				margin-bottom: 20px;
				border: 0;
				border-top: 1px solid #eee;
			}

			.staticrypt-page {
				width: 360px;
				padding: 8% 0 0;
				margin: auto;
				box-sizing: border-box;
			}

			.staticrypt-form {
				position: relative;
				z-index: 1;
				background: #ffffff;
				max-width: 360px;
				margin: 0 auto 100px;
				padding: 45px;
				text-align: center;
				border-radius: 3px;
				box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.12),
					0 5px 5px 0 rgba(0, 0, 0, 0.12);
			}

			.staticrypt-form input[type='password'] {
				outline: 0;
				background: #f2f2f2;
				width: 100%;
				border: 0;
				margin: 0 0 4px;
				padding: 15px;
				box-sizing: border-box;
				font-size: 14px;
			}

			.staticrypt-form .staticrypt-decrypt-button {
				outline: 0;
				background: #212b36;
				width: 100%;
				border: 0;
				padding: 15px;
				color: #ffffff;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px;
				margin-top: 24px;
			}

			.staticrypt-form .staticrypt-decrypt-button:hover,
			.staticrypt-form .staticrypt-decrypt-button:active,
			.staticrypt-form .staticrypt-decrypt-button:focus {
				background: #212b36;
				filter: brightness(92%);
			}

			.staticrypt-html {
				height: 100%;
			}

			.staticrypt-body {
				height: 100%;
				margin: 0;
			}

			.staticrypt-content {
				height: 100%;
				margin-bottom: 1em;
				background: #212b36;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',
					Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue',
					sans-serif;
				-webkit-font-smoothing: antialiased;
				-moz-osx-font-smoothing: grayscale;
			}

			.staticrypt-instructions {
				margin-top: -1em;
				margin-bottom: 1em;
			}

			.staticrypt-title {
				font-size: 1.5em;
			}

			label.staticrypt-remember {
				display: flex;
				align-items: center;
				margin-bottom: 1em;
				font-size: 12px;
			}

			.staticrypt-remember input[type='checkbox'] {
				transform: scale(1.2);
				margin-right: 1em;
			}

			.hidden {
				display: none !important;
			}

			.staticrypt-spinner-container {
				height: 100%;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.staticrypt-spinner {
				display: inline-block;
				width: 2rem;
				height: 2rem;
				vertical-align: text-bottom;
				border: 0.25em solid gray;
				border-right-color: transparent;
				border-radius: 50%;
				-webkit-animation: spinner-border 0.75s linear infinite;
				animation: spinner-border 0.75s linear infinite;
				animation-duration: 0.75s;
				animation-timing-function: linear;
				animation-delay: 0s;
				animation-iteration-count: infinite;
				animation-direction: normal;
				animation-fill-mode: none;
				animation-play-state: running;
				animation-name: spinner-border;
			}

			@keyframes spinner-border {
				100% {
					transform: rotate(360deg);
				}
			}
		</style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">ðŸ”’</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"294342f7d5af15b7c4141890dff5de09534f42db622860c9d96a019aefa73ee6ebece261a3994f2ef72e71adb901b9097103476b1b119ddad2cca219d2fe1094bfb94d12b5c04b028920556c11486653e2148c16a7693b26a0ab6320d9a63ced7a364792f509248c3aaf2027929f5abc1cc90aacc4c1a875ed01a0e976317a44452a93695e8768f96bde5973c4b9b0fca8b2c1fade647eb4df0311014272433e5117d11cc60762e0d6a5881ea5e482d5e670e526fe7eaf1f29cab2b8c66c90e6b28e4a25d9e610b433c75d45078f20a2a8513d7700000455bda4043c1eb162478a5b278f0182fd72c02492a22eee5b975ab275810c8a00d2fbc32cb6bba977422d09833f6b224f0c2a59029bd4d330ed09b121733e1cdf42ad885ca81d5384f4e0375a7a28c565f4caf6c00d69fbdc464f448258779c8d35f6717867e7241423494c90410cdb53af5a89aa3397700e6f78b1f29f87f061863f8f55c99ad6e3f7c5e59de9de7bf7edbec2494e32403f03a75fe1af7259ca549971b410a439ad385d9779871830a974ff40376e1496fef6e36ca3d1d2b6658f9b3b3948285e6e81ce9bfdcf2596a0e02f699e0224fde678d28932adad20c3d5a3f41bb1addcdf9b66e0d6639eae6aef8989368aecee18d29e072bf8514348868b452503cbdecce51854032d9d9499c978254cc60f341fae07360290ac656d73caeae5c513ab4399267a155f3759c7c44eaa0df48f4405100e64683f72c94ef6f635060f897238376be92079e6bad0dd4cba0976ed006084647696b6167bcf8a71e7f8facb81fbfa340574873775b9a7d3f4d8cef0f9ac7c70d1ccaafc2f382527391e632233bdb8ef81fe2647ca0fa4dfbfa2d0a17551215a50b790c7f77c958a9139ce2d17319491a8f2679e65c714cf9215d083fd7885759f1175e8afccfe023fa099e01bfc663daf0cd66412a9e7199533581d7105472084f6db9239dd6147c5ac5fc39ec99ca7befde72866a103fdbfaa73eb153e684c3a04506d98f9baea74d83236bbf3421d0ae7dac721976f0a6ea891a0049161944f01b601aedea47720e72f82d74853f737fb1fecc4ec368bdeca230ea11441a579a6ca90016237888fce05edcc1444c5a5f29cf01418b26e0eea9f967089c42204325bcb781e53613152f461dd281fcac4919cec6c1076f49f513bfd4e4076e8530e40f4d656b8cf7852effbb82b149af0d71f27b613a16f4604313a01945debb9c9a74f4db8a74644b3ea7b9ebebb63602f6accb91f42a05f7f3b12fb64cd40457273eda3fd90db2eabea458014f910351d05f2d0b821b6d245483012ea9754f2abd84f6dd06287cb6ca26f030a0e0ec50309f47dd05b49adfa8980e87531edcdf482bfe48eda4f1f94013ee5d37496840e3f74b10c1f14eae55bc10650b9ed29d2df87cbf4d306cd156e0ce3d98ded45548e2fd24359a3d7716795d59ef5ab63aeb1b5c8375f9cb57be1dd3a1ab3dafb4c47d960505ba7bc0c9628d6f850132390faa7fdf85cf2e2a72532ba65224a52d3b49e43a62aba88ba931ec0adfd459413e46282b77b7fff9a8dbe88bad8cbe421584fc0b5deb6d1f35d7e7520d3a2d8416490116282555944c2896e901ed99531185e0a9179f5c5dedf89f2361155b570b19febd279dd50d710148f6425a4436f0f52f2c52e41c3fa505cac073c5b960036e72516e9297cc68435a7c3446aa6f6605985ec9eacd322a85db501fd3bdf12ae4de848ea56b541321e7c562162afae7ae1dcb347931b8795a7ec7a1e7bac52f0948b39d5f33c1a4046094dd8808c1a2c17947c73bd88559e91c15b9432697109ae050fef25905b1c25a0c59a1fee272df1c78ce8507903d8dad65c616801f6378aa9a17e85820f5dd40ec515ad126243175d169736b156bbd27c9e9fdfd4965d1bf6390bd076533cad337eb8a9db41942b9f6945d1f331eea14440231265b5fa0b9a11e62c0aae6b96b21a4a72c0b42bd33d3c2199fa77dea8a6726dd77211c5f9ee32ee52fe2d72c97417a77fddb50314b761ba884998c843ecda1751128d9cb31841d6ebf8f651e04ec13078b74d1c59cf1ec17e0d2792970dcae3c523084d9cc5724775a01fef85f1c92f17caf5a8b307983c4896d9489f6f4fb22a695f60c5be149981626dad107b0786b3e7bfa5b1a1458cb918d221080f6fc6ad82d0d8c92fa9d27700f39228e55e49ca528b59a054c4fb4b81c0c60266313136ebaf78b04e3540794565bc2585626cb0dd55680a713b3ee20cae1923c450b6139471a44049b71e53828457acd6b3b84ce45c2fe919bb41aaa2b65c4f66d6b7d89bf4699180c0e5f45c185273650c32397a47b6b364e986df2c74909ed6d2ce2c8ef3bb930d9de035ee2b1e04068030bfac4f269839d3cf9c1079cba047b60e7cb5e7c79444f91cd4261958a5077f584720bb0719f0ae3b121eb4ee0bed65dbe9e860ae6cf1172904642167de9b9d52ca630ba33bd4704c0b3c38bf3849349e89b1d2e00bc8fc979f1c0ecd1dcdf80ff09789a291f31cde26004e5fca18143b815a4ee6c1f227b074ac19c818da11ad2495c20435b6e5603a92123e14db53567cad71412adac16b75db7ac546c29a8664b877fd538b4d4ed1aecfc11963bda4d0d026f5c6cbc46ee84338c79ec82f1c265028b6af140453c87169eac8fb5c10b542ee12286b1b05e1888b079b06868e78b12c99d21aa4e587e5426a617c121168bc6db070a5089d0748cf4f13ed8a66c53e50fc91b7315fe9b0d26d2e97d36d9a10e74e7748ea7d9962a166efde968734c06b75318f420541882baa19c0b486fba0c6052f1459341926508144c359d915c1606a90b640ac9263c071e3fc31e41547d7c3620e53c96345dc976b0699e9f2f013950b55d020d1d0812538f33e71034630a2ce8591df369e171a8007b9a91278819afe62b60c08fc67b648da85f88a6db056feaf2ea9d11c1c5ba040cc13c8957e4b92d22f8d0039a9ca8e44c7eb422ea146ad52ccd461cf03ddbe82de5f7b7883170be3e83c5c35036d53a3ddda6f893d8b4e5a6dfa9be0fee86ecf2b10635360940e8aa0fad46b3df9eda4afe5e6de3730b5b94ffb095f4214c5b1c528b44ff1312d8ab7c7e5d6a5051737f55ab2eceeed9ca3a3c9295bb129a152279dd6545b5a52c52615efb067b9edad53a1fe453bf167eddd48d7387ac60f57fd4fdae05654fea72c79bbb49d67e4e77f914f8c51548760bd768f41274c6dbf03af2a4f64ce7342b1f97264b5cca454382bc78bd9571a4f0d2117f3001d148d509da0ef2fcf33bf9a61181537784113db550d3c22f8d5b34763f079418f3ade40b6c0adf3de0e1e9acdc0ec13fa99ee69362abf4a7860bb88b007c2ff5e3598f5de51fcb14ca6c78f1cea1bcad96b51a29bc52ec25d0f3e4aac7fe5d8938f2cd9f108edbd9a59c267dd0776f6f409601353b922b78654c0c6695d1c65b8d0b8505077071947557d609108548e7711faaff2b6107c061ed292fd2279cc0e335da0dbaa5e61176fa75d8150231b26cd9e2bfaef8e25f640a2fbb45ad3933f9a53a77e376d3eabf713c1284ea8b5def04f90eb1b66df6d60f8c5f931f2394e00e527acab781d0501318f8099493f7922f91e79eed9a605cb5059239b086a6835a2b686ad0329ea4e8f8b23c2df88d8042b874ffc1aaf64ea77c5976f3cc2e2018ace9a382fd7be931f74dba5d64d332b4d7e3766dab55b8a5cc20af3492406762d3bc38875396dee5bc31edc5d28214d23310e490ac3bad9178f3023314312fcbf6e631f86399088a72aaa79ff2ef75434075a8cfd178355dc62b5bdaedb18f4a15301e2b498f29633de5e9b22d4ab1a39afe4341be1a59de8ecc80bbb696763f0a5a43e6d8ab1d7facd043b6863d45f379306fa3f3b5d3b89f23051bb97250088fe365c7292f35760da80714304ae1f1355897bf7c639d1f79fa13fc577bc4ef1f23075447d85f6449d828d9cb4787f1a2d227a8c4a46bca1ad6c4507f1de1f8e3b5597514f5d30a7e7ec01009fa89ab124397c0c414c980a6ea236f739e85e278f97b7086e5d062eb501bd795057bf9b5aad1eeda4d1d7c72a1a95b84c88f2e43701a6d8f5bfd94c5067154558b97f047efa31672aeb1d532e862a3bd94daa3f2e7084e56b4a0a5e085f0454604be3c1f8ddc3cf8006462581cfd3cc3c833d9371f87d8d9b7d2330588358363eb4c4d106d4c3d1a4c8f2a5684c71b5c36710d4fe0fc63168f6b5c0b25f2eaec3cf2eaa47015538d8ef7f9bb8269516ec1bbb9a8293429a21392d442367b8ab5b013d108a6bfd20970f07b81a5652a5a7fc629b875de841c2d75865f396996ae3293fcb845f26519b21d702608859c6c84558b68e671759c4daa14d880772557d3c17d6d275b4dd09a9ba87a3c1d165e376107a2fcdba96b61da6cde6259a4a8473b23bfaf9a1a90ba4bc831b31565500b05e9b9bb5b3be3d6aeec51174cf51313254275378078e23b2cae1c9cb3a762f2921541000afa9f43e2acc011db45b0c7c1bc6be3aeece62685fbc40f0ad5aabe73237381f5604c5916d1387e1c383129b1357e4d4bf7bda24c7d6e8e97a1a95117b5f7ea09b0d71a626e14ba3e4f103278405507271bbcdd6c4f04c8cdadd6a9e8bcae1e5a96599f3de9ab4f5cf4bb2b81de67b5e27c8d91a8ad7ef513a96993bc69c0c5e02c9097de4be2ccce1f83ad304c50eb101de12082b909273ab6fd230b82551f67b9f4d864c8b08fbc5d5e587a55623272c4db389062d445c772353cb83d429aaddb2a3542de9e0fc13faf83ca082f27c448eeadb1230366dc5c50748f3e7712697dd9443d1ebcc45462c5691e84aa22925aadb598bc7c587c84458350c56b5f55a97f8d0d2a8cbdfa42b95d0045d2e3669187364bcec25e9b4ef52b64ef905732c0513c2cc5ca5f0b6c814bde6e79b96b0d01514db4e15fcaf958094b672c9b23043bd6b0912f321a207acb962e82b271d16231678a6430855b1f0b0dac129889a73a706ce2f6fc7e851a60683ca39b7069c9dd4c56b22914dcd5a0c367d679d37a86b66cc786e251f9e7ede8caa4d408ca30f6d9af95010cad5b68d439b55ff4d00c8a4eb3e72ea24a6fcd95f12f120a268c979002debbe40f4930c3149932bac2a575000374b396aa2f9cac7953095024b1f187750b04634853168235e5053c342ff592336fb350bb8bf56c1cf470dbe2ff939f77bbebcd8d751ee9649febe4ad1c4928d8a5b9136c7ece4d08d0c2b6336e2f0e9e858145dfff8572c04f6f0124c98fe59d93bbf840ee2eaed0fbe737b9a8d2215ce2daebeab2f47404f92c2dab4a6af86598c6675c0c8aaea4b35ac804aa54edc5c2d616f8d8257e6f2062e85318c40d64d79d4fa4a0e32dd67d2073148654d610364173e0b5fca409ca0393d1695d024d282ecab4e7cb8609fb43204f71df671de7fabbf24a44c832713f6efe5252fcdbe60d3f53b66a719aa5cd228ba3c7e2956ccd57d3352527f288f69b7d5d2eba8d94f1609bb14712c61dbf3bcba83fca32a2cd886b37bc3aa5060fa3e168ff27f0af8e71b82a7a8c10e905cf00f3ce27e21bb90ceda36ee4451f4295d1da3270098b1580ab5554556edbf80349f966374dc49df2fe85939d9a2a9ef57c61486f97ca5b830041634f17f53266bf8d5ff952d85a30c97b8c8d4559ea74966a971f78029ba28350a59104cc1ff8aec1270426c4ad79a6ab30f212fe1d6072a38ab397428d46906024f92d6d7bf3545544129bdd95f3fdc65de420767497f0107e0f3e1bc018f69c1f809bbcfe72d57fd70c6e37c52a5ed20bf19ee9fa90036de387146d55af4c65676f549e0f034a913851d5acfcace49d36ae01bcb98b42709c6930d0174e7d54fc1e687985d4e04d03c27ea78bbfaae83cf1da7c0c505c1945413faaf23635a8575e68d30fc482d3a50036602176bf785726e7b7ab89bf400ad04376e376548ac99d9268c1ab6c4db985801456430e982fcbe2296f4ddf5eedf6b5fcfa364f6792df771020e9588985a25e6e2f6f615209a2fd61c80b2e6884a655291de93db5e82a079587f4812e52e6cbaab2d0f7540df80e6c4d566279857e0b9beba771b953d27b0e0d9078933527bc786efa56bc09f4a1d8e8d95d35f7a0bb71e93972dbc68f7251ae6aa2662bd0ff326724ff593ba4869b7fbabf638323a7750dbac84496089a56f6b41c9865922292b43e8e98dcbb20199f3d11cde4a166c7cb2d763fdca762a38e5ef5f0ef20ede5b6a14e8ad67a0abbb71e5d7f940db6551d27c45ac8c9db9d9e9febad7d5398f33c1c29d6ec7081602ed76ec96b4a82f43983ed7d01065e515cfad13fff4458882818f6f5fd42b0c8ed4778c139eaf017ae99180ef7220a59a867bbdcfa112d831706081cc246417e6efd8a5037318ed940177943f1cbed0888b06b6c1f7bf6de52d00b2291009d5b6cf56dcb9b5aa67bf83db58cc3c7ca73068941b07bfefe9a88c38c8545df60219f95e17210d30be2f4bcb9893069cf9be9f6052a65ee21f8ae9982645180f99a71cca06a92bd6603a38d4dc5eaa7d685b205117c2ec6e60fa20ac79cd31537bdb6d0270bbcbb6cbb195eb94f36ee4fce436e33174853169526587fd8d226bb8781f07ad185993de85aa21144f4c4a1cc9eb4517ac9074c25dab89459b8d2f72d52f319ff7dee87435694b66277efe3bfc199dd9750aee4eaca6f62e43f439775e2b764a40cbd8416e327d56f99703489c13fe5e238cac46681f116438ea470ea439793eb834a118618f8fa36738576e836f36a72ad71c1dce3281f09319aca6e3c1337b9cf2e8bf487ed7236595e5c945410dfc0ec35bd736a638893f4320afda468c8fae3158a8d7ccd9b8dd9b1c097e05928a6315a22e2ff84d344dc451afc331451da05434191461495b174d0a728b653bf2040e85f43d1f56504c621d1267361dbf1cb0eeb97fa7e77c9d234764a3c39cc3581f55c060864c695f6db757383cf538eec9c43f08f096b411fea015c195f6880c1d9597c010a725d8450328dc63e326a2f2438047045567f5e433016d0814b93d89fafa3f52d36c696a5b550daf72cf4d0ef7c31329147c64298c363456b1a880c667e6485b0d4e5522978cf6ff7b3595087381bf44c020c3acab3ffbab5e3a9c6a74d3611f5bb09bddcf9afbb18699c59a0d2be87cddaece09c15c91ebebad215df402efd8d8aa5217bfe7469d2d8f2f88064ee2f04b9d4c1497cd9e324de3702cf387e8b219f4f1d9ecea5ac0a90bef43a55c4223e88e36d40ff22619c049287268d35418d9cc57585ba4b25ef5a51e494669a06116d48437778d41bf110b1987f711ef6f45a015a81ff28cbd89b24342624eb3d191f1823aa231faf5f09c84fb3da79d559743f50dccf3be083e6be6426d5685b34f53e4bd856b37fa6a3c7d7c202a000ff845c81552d11909c0e1a8312972aa1ccbff8023bb14f42a499dd8569e369131c354725dd635b74692b78f1eae3f2c4b7d162fbab8e2a5a6f35b0128be3c967bd48201421494aa514d2de0bf7e78536e6200d58af3f175f56e482183975716cb0d7f2845073ca82de5cfd41c73df3bb6de46c666f3523becdb4d71333a7161665c2da2e36ab2202cbe8d4f2db80a982df663e007ebce104c619e8a13b64dde5429e0f95f9db8136eff42a8b7b23dd945cccab6e6596e058989ff400e69769be494b6bf25f5beac710a079ff4ab948cf61dcac7017eb780ce92b214101a2e3768b2c43ae79ba76484a0e1f8896f7531abd524ff6ebc5e0452da5ec1ff1018c99b67b276d30b4a7529b9fd0363080c68ffc1d5a92e85392853fe65e17260b4a7370ded1388cc4fc788e10af75b77cb7e1a9ed664d1d669b226b2e76fa99e5fb95d4234555f693f13ef1277a27b9113de90c6beb76d3eb4532a655df700455d302a4fcdb5a2b033b91d663cc2f71dbeb2850f7466d277d8416a13fc45fd31c0d2891b4a96c0fcdfada5c917c966575cdacb7983581758de9abcddccb38cac0f8f12e97ed1c4b7a4d8254c0d9b05917052210ea6648dc7e31c3052c35f2b1aa1d2ee272007fd9a5b5ecf932d7b5564bc2a0df6c01990c26dacf20e508db6534f1491d4ba6053479c5549a7d3f3e16fab8bf073e59ce6a3bae27e55fc2ce929eeeaa9ecdc8c02f144639ab76d66ca9461f44787f105c096503ec7c18ee8a546f7e3b5042b559b650da347522daf2e975237e857fbddf7ee310a784c0d2accd746c5008d2347262cabad95d3a33db3c5159c7fdfeb52fd0910c9374f5997f20266f0a95ca9ed23b55885cd9d5dd1ed2f8c947b7ac4d6da31a9f682c6d042612bfd1dfb6be6f316f9a3e46758cc495f676443a517833678b14bc3fb142e6ed89c9d2dc1b4dfa3c759a0234dc9f048dacb05869855d11273e6ab1c1d4d7b2d075702f843d0dc826d6c3055e29ee01d6c6e29ae2acf48f1b5bef212c453e7a064e6538b832b9b54e5624c6b425d2634ff24fc928874daba7b1c817992dde58ab04f55b10bd0a30d7ee0943b1aeebe004e99b13038e70807072dcc2287823496b1fa0da14e1b2dfa42a6a4a6b817439c29d3296115d9f3ac4cac88726b38b013da011ba63e5ad9012be03d8a2bc99f195297af86f8443c16a3cbeaa2b78eafcea93350ad41b77418900f8b7e542d2a0d51cbd8a22420ead96c15021ddf6a386387e69d713dc2607f715dd9c403b8a3989accd9064295ecaa9e2bf5a847aa08b7930b73b57db3255d99992574abbf83ec4a275e228e520816a5c258b51d4528373d42dbbe85274aaccc3f6055e69e4b77ca4231d2546f71466ab279489f03b3f0d083c1101ab4319a748bf02eb780d220f084f4ca54c6ca4194f28a061085c86182dac0f80149974386ed1f7b5a68e18ea714b087ba6615874dcf5712876b91d2192105aa8265b23fe817f8d4f36b155c1524dc891faa5cb4c2dd36d531816a734b50c0727fd2d14ff2ae194f59cbac15e65654885b9213af07c63fbff5d0991ced61a6a911167a0e85815b1985f6e91b6d550b5640bd896fec332637770cb1caa35ac42e24ffd258ef32506fd6ea3c0f07f2ad1330ee5a93e016e3036b5e1407d530fe0dae4982c4369b3610b8d1e4928a10555f50a8c9fbd7e447cba49729e9ceb1fe54b20886eed1ff59300a6f9196d0c9d8621f9abf9081bae32d97b72670d41d2e57b6910b7fc94781dc20f3a036e982924fe89e8a94818c9d06144c341c7c7dac705a162739acefd066dce057f7bdfe7aa7b0002d1337ff6247791bd8f1e194e5bc91e9f2946d12a3cedc181068ec4215a1728038688542631c42599c231e44fb84463334c8623a6c26aaaf92dbdcf1d056caa20e1a5d802091b57fde72c88afc19c999e921f1025c558d9f46817f06c14605e9efd4310871ca8682fdd49a2a495257edc6895cbd465aecb37408474178415e7a072d4efcacd0f28ad0fcad698456ff69a1401f60ca34b1fd6b1a94a72e24281a03713a08738eba71eaf19a473039a6fa6d7dd6713b7b2fdafee350e6df46749f05cb265df68ddffce32be05274f9b28df7570068d5d26fa6271de2319b8f6ac1bc9ff82826c1377d71298183c4f9136f50f178a0fc4599b1daec45b507d7d306885b09c44bdae8381164e86a689c68a3f181ac553e1ffba2521cf1d8326decb06d0c9ddaa76c00fba2d0b145f89aa9df35b64d12cddd5216b85e5abe71294553408ae4e0f3248f6a3869d6717fd8c50efc40d64f468141d8be0dc1ac568e9206e2631d867c239280a4ee48db5645c715d53c4d18a2fca89daaa4948144e2857160ad59655518c50e84e6e8af792ef1649b2a79a936d851edde12b0f492da39291064d02d873419cfd9dbc554946b5e03ddc201f39c805a3d7ee8c6195a2e2a22e53dc489979a5c4d72c08d5ce3d4457b6b2675873f64f06b7bfc87ec2620f7c93d689e5c5dc91b3b74ffe7e158eed506b5463bb6e58b501651a1ec59d7e311af546ae6de2683b5e60f3bd954f5bf52ac66467f055903613bee357e8e74ac24cf69d2cbdf88b297498f9fd4862f287e6d69fbc937c05707e0d7cdfbd6f80c616c143763ebe5178650ed8486a4a0ce1e256f1338272bc78a2163f81c0a0e95843b75df3dd7217b2559304b67372e9eb5694ad70d7af59971a74cef8b35f32a1a76c31a6856e12791ed7360d15b6a341a5094fdaa7d625d4fd90a062cf928ad5716e60373ed78679119255f93b7fd107680c2cda52fe007abd657521774c09a09293bcff1b58c3eacfc87c59f548e489881e8e311a8cc8aefe3ed820f63b8ffc497cad532a1b922d405c73181635738cc10307544a0fa57ac7381a18a68930333fb3cfdd0d830f4b5af92c0cd4564a0e4ac7a15412910cd2b4b81dcaffc10f85c1830e72373d7128131548ad444ce159b9ac4b74d6172a6df88957754c0c2ab2936f6f09540d2d376dbc48598190304e88723fcadfe59e09c461c4ba58f30b90e23f64fecb671bda323ec99754a1c9856625963da08aeae9d03c6481116e79b10d910fa8b9df1ea81757e1617b6bac7409974f403206149d9c31947801398e8b2e2f9b5700e3ba323e802c0444068ab2d847beadb7db95dc5960a3e46f85d2a49d2134def11d78ecd42fd54469664b13036669ef325976bd6e8d06837d19199dfdf0edb2dcefab767d5d75486d4b4d7c998054a3f8176360220ecd83438a32fa7ddffc0285216600035786f01c16546b42900096d9a80f1175cbe07379ec536de3c5e8d60cb041ee3d0940ae6649094a18717c764da764b91497857a10e60c8a5b9e27ea57851235d455ca1f59953f8d2c45ec25dc071eb97e83d2af0dfc4c90a1ea3ddc7550bc5b8780bc3e83739d5ed27b78f9e04c926500b9c43defbf5bf75e93107aaec2d40bfe8a9a8f15039b448433a8af570b10eb4c3a388f74ce2b45d116355fde369f800d7e0d3c84c986c4876e0367366a4de1109b16e11745baa4b57fedf152b527b96c8446c87ce520e8282317c3f6b2952476febfc8ac79d03548d103accab22c18a8b90ea25bbb4b4ca79bdd2263e7a49cad0dd065f7ae81fb70f7fc9454be666df3b79e74c0d41cf77fc98fe4359d2d882c97addb8f1f91337039fe15dadb1762a6f37e2ef1b00e94807d7da376aad265715496764443cc876d67501b61ba4b69d991ef0e605d6c3d80dd74b8db33bc1c798a69639a58f6b3dbee0469d8d51ac8f342a276900cc879ae1527adcc484e5d8467f0690bccd525ad66170b658976c0641140120b182d014df4ece07ad46666df043b76ea8a62eb09f15ded306bbc06a45e99abad2282826c412bd6c8c51315d0d3d0cbbc1a6e837ca2cf2c097bbbd4b46aaf34babfe541ba7cfcff2b1426f9844f2c8b58735a76d27d2c2cdcc533ec58143518b54287db9da0b3fa032fe31bd0c0662d21fc2e7a5fc95c54a7b60906ea13c5ef57c0f431915dc95786f62deb84b9a040e772c38c23acbb978319e8239e7d69015a9876c496bfb5df2fd93363d40d180c0a3df71c6b3466eb508064ffc24d6e711460f6e64ca0a51c4d09ef03646f9697ad8aff712c5b39d7070a1cc8a4af685952604449895936af75aa406bf289453e15208a62f6ebcf68661de4891de78304e9978bf7895cab21f2063fdd45b501478ad445223793deff11a17f4e397a928eba84dfc66eec46b3c6dc1d758d2d08e6a4b99a2c03679cf09794831501d6ce200900ad2c1b1ce664a79f1f501e05ec3c3884a309851f714739b1230b3e4324ab3c83dd6b2f331df91ff52e0b6f39d94ff10328c33b1383e0d93c04f81123a4e65df26ac567cedd4f2dadd0d46eeda8f3b4c3eb6d3b40136e4304ee4d8fede1df71b22a4ff6b746d72896b8d112bcea3174e49027d7c898dd7eb1dc0e7d9fba5adddb57528ca0f2a0a0750826ef6d0eafeaf048890d88ea8abb232ad94d9286df2058d7d3b31fc8e0e116827af93e14ea7c2fb6c96c11de2c05f67d0d140332aa37f4d16f1c4d3a73654f8d5d37ee2d04b780860d5ad3d31f8ef5a61a465ed4864986b0d77328f90f7f1c1d1429d860a9701babb8ff955d9be4d19b890973420313e8ef4b6622ac93f09a13fa1114b3723481a92e51884120e1a6dae33076905c1a5762d2a983dc15c4daf4a0b05473ce68d9023c92d37646e39d46874a7f8f0a259a771367b3b86aff72a112b2ac36fb3d9bb53629548a7aa60e7d53565cfb32ca872b19e6ea787fdac22f392bb97fbd16edacee850510d9bca71e9c45a0339cb24968afd2235d9ecfaa490fd1c3f104b0da46ea5d13daf7266e18a3442bdcd810d51755aa16e4e1f55182bdc6d67528d350e85aa14a0c43b709cf4589403f894d4d24646bd199d01adef5bd6582443d39715668efd04e53be1641d571806cd185eb9f2ec6cc8e54b881ecf8bc612c5c2b399642f4a793b1b7eb6f7d1aee97b5545d052572aa8454bb3a1e0baeff379716f3645e7ae2ff81eda1cbd8554c487ce87b9a56d0291164b11d0993e7f4307b9528a73478b035ffd66c3ddc43adc90a28112b94ecf31c9f8bde39e728dba60cc298824054b81f6ffbe113c5c7bc6ca553d45d376384032b74075985a4f83d48685ac93c055412411f0185488d431abc5e0497ebc0738a6e87b58fbe5004b22ac39fdd99fbd424a882471380e285304f8a93960fdaf345bbf6dfafc37963abf4d265cbb5d4e5c6c9bbb574bca09f10ef0f1f97deaed30afcf7e17ea3eca7e007208147ae34a326a4057115425d899de29569b5bd00b1f1e20977b3e4be314f677c63304c5efa71acdc9298a599a600be6463274a60144ceb84f658c9982bf943710057c27bf944ddbde89c20409c50bc8fb0e9810df7be389d3cba262d7ae0d12f9f80937ccb504ba606185358306bcfef4a869e18ba3d556892b0ea8ce498d9589f9f077112575bf761a789c999e3ab92d56b63fa9a3c0b22c26a266802bed620262b0e401f1f87e80fcf50a6189dcd360f8421cf57e81f842f3de125ddf7aa4589e479048735c85254a6301f997cb346333ba76c5dec49bfc98cb18c5a9327038dd5a4cb2216a1f2490445a6620304a4159e5312295ebe85f37fbcc3df5eccd558be7e848fd73a179484163ad1fcb62a8bf7b58760eee4e6b9430f670e9bbb93aab94f485a47770936c3515bdd7dcac46e81a4b4e3f635a705bf0f980c3b2496eb2e217a1c8001442a15abdf864d1ee5bb5dd9825dbe5673e8bc597cba4aaed0c7f84ff6a8221d62125fe6352ca3cbe63b0d3fcc3e4c6a6eadf13d1ca872f19b6d45ce6fc50f1f4077f48e56b50a17579182113f8c3f4eb90becbd19f0d979cac7efa00a87a3820430f12621cc4246c176a0d861f69f66dbe4943541adefbfce91a1aac0ed5452f198f871856ae5367e654aaf46adc7bf9ff86f0b69615048574fb85951d55b132559e17bb32df2a35a4e368f6c3cd84e06d31f1dcd5fec92b3caf12fe88dd2300800ac52a484d1560233c42636ba66b468d1edafc92bc4564ac7290c49162a631142738d212ab931de940785544597e6f929134bccd1d07ebe64660a82bad8059e8d28bb83e5539e75624a514eb22b62479be325dbe7f1ea964afb0f8db74b4ff353b143c015bc8814b127dde055401e01729c7ec1d467dc1875c2f125bdbc104dd4eea09d802f4b11070815df5553250c74e2a59a3d36b748d25f4435597e20c660004461bb43e6b70e626b190b1963303e7b4844e022eb2c146cf18f9c42be144b9bc94e22aabd689297f503ee02cf347334328b0a68251e44af5ed391446d8345a1b09c7b8a4f63bfd950f08b49b335709264dd148119a8c3bb266d13837f8d8ef494e00840dca5dd56e7f7ddf846231ef962cc93475b584490b144076e8de452b72ab96cad478ba4841172e828fe6dab997a516940e18ad36b187323fea4ead4c2c600a645cccb0f6474d24d88bba3b4459601367e5476f54437c15c796ffa2af8556994910ef32eca7c2949b3ce85e382042d54776c62e4355dcc3d8ed265ab1530ef903a3acccf3287dd24c4218c66bd221fc4b681ca8a58092b5c74ec2e3f9c014c43a944fbb4c2d5177b1895a2288449cad4b104c91a1707cbd263557368d26040db6b16b33af7af55759a9acdfaa77ff41cb4e677d42caead507e08be6e0052380466442e3530e993fdeb08ee0f7ffdc6b6836402f68ee6ac9db63787e571275af907a81664cb3641e5137ecde63efe70b6286146d087887819dcf1f31025c36525a787fa1f7b80d0b2189777e5d515bdebb353366fdcad7bb7709d92b1241a3409b0bb2fc2cffff70dd3b021521f9c986bf1ec01d1eaa359f78e192d7e9aa14df6b18e936f1c5b0983479ffee7292155720985eedbfb58c68528fe0ba998c0f0655f7598daf1914eb2bd6186bd0b4be52fce63f4c21f4dc46597337b36e72e4e733cec7fbc19e9f6579da2ab86627532e85929fc5f28dd06b8db30eb658a0a939d0e1ccc025f268178f8e25e470bc8543f6411b40da8d49bb657c63eed5c0bb8fe5f762f5f190cda8887037aa75fed7d1bda4d9de78e4f3dd641d73b5489b13fa8b39eb69680d8e549b4ef0fad4f41b33766f19aad02ea79a0506e347ad35427caad797616dec2d581dbd1100d27150182be34a7390650ce708b36f3e738bf531e25e67c1693b87ec3098a5561ab00a053d6fde0ca57a8ad6ca8706c60eb0de2fdfb34bd7bf373527bc6b2737dc5503ab53cdadeacf529e15517ee48cdbffa06a7305dc57408432073e39326ee8b1f2f295189ef62998ad3cf94a2d12dac41c01155dd295770fdb19d79eb59ad6351c53d0d5ba1ad2d1bc607a35e1e9a63551c487d1ed917ac0b3f4fe7c5c141421154513e40cc4063f1b5372056731941504024e93af63d93f9f5465c7438436aecbb83e929ea204fbfd9b546a0540c74d69518e68522d69cfd1c6e2a0918294f7e78c710b647ce2d027c3607812c63a8b9105f8cf28ebdd1e224a6ae338c13867a67bf4f999e9531a759f7aca0fc0621048f13bbb99869eacdd76b5e827eb72d71371dae3740a53e0762c4c1cf9c39e523f2e773c00ffbb4108ea179e37476faa32e50283a71b6ee2ea1ed3c9c00b4720dc16b00f561b6a699c37804966c829d1399ad85d5410872c9282b399b33e3dd1b1aee14d0eb6514fc2b53d0a75b96372c4203c005a6cc4024713d7d484bffcce7ea456deafa08e203342b9b25ae2337e9b6ee83862abc6c564e02d351972050fcfba22bcfd55407a136ba42fd4a53dec0180d30f166e356f69e1629f7525445c2c4a7f8b0fb741d73255632fc8d45d4d0d20c52aa75e29b0772b3d44ee46fca43a4f95c035ec00573077846043534a5bf7864933221db4526403a00346522803f6cf70ec02a9060bc215971c96415241abdf93c27198bf3a25d302d45072e89d009db3e94db03c40199c21b04c77017a9b460c8d971fc77f9297faaeeec78544f2702e28ef9060696400d02d6768d9e00170c92c661772fb996821f8adae4caa368d8b59a51c62a8347f022de37c5b2c79899de6ce50f8651bcf940611c477020abcccf4dac7744cf4fa6e63f583d51844b0882a9285019d020daf9593553d4e1617b1957b83fc581ee89b58cf29ca0c3e83686d204662c32e3b0cc7afd53bff6b375ab595c5bd9cdb9e82b441a7a01d96b70fcbce22dc5ad6277c0c7033863cd2fe190318e1e580ff6be9e2c75772fc044dc65d2f32ffbea78e439395ba0c7acaff94c9accd47a838105d02cfec549bb1a9f7a4f9209c5b7c2e5520fb898a942900fa2c2c076ebd3a626023bc408faec69d3d2e7bf7bcbe97722b3d4b6d7a14512c8edfd1db83adc43ed0661d3e1a33f33cad3f5f230476bafe58ef83f32a24656b4b21357f1a4b393c5e9bb350326e219dac1b3eb10ae4128f1a04c73094bf12fb97ec216d6ff116164435507bb157f77ce8dfed55757f6822a9149e9601bc36ee6930a2d7b08025e0d1d586f634f0f30360382959070898237a591f2a0953e778b1a3d70f9054bb2bcc86a011ba359b225aeee2a76d978339126f7eee6e39391233fb42f5f764bb7b028c29734bec5f887c646f613b46e4ed6f24bf5cf08299a36f0bbfbf62e804fec7bfb8e0ce4e960f43dff84ddf2dc9c2960fe5688454dede5f1e7b849e8852cd55fd38259f9ef14a6cb6701e5b9b418d631dedab41a4ffbf0cb25b85d4c48b8b8577d4cd9e03b052c3f7b0c3783202b0618106b4329f22d212b4f500c3dccc966d97ca5186f5f43629289d089bf8f7fa506de560634ba041e4086bbba38f2f5aa3a68dfbd3d3ee8daec05d270dbeb3e940b4c9c4173aa66b7c2b88c15dd7b639bafc1e149d366b2f37b6613b2e79a63ab8534a18297ae5f59e188e124cc698d5e3193426c6e5f45219fbdf246154a41123deb3dde4206fd69d6aaa38a6066380e51b2d28a5d368a73dae6b861ab9f05c3a8f62ea842bb490e7b8e524b75614ffd838d86aa18066052eda65d7bb5d46aa285ded87ea814a8cf963c5460f24530f8ae90abc75307e102162e4cab507689e5c542cd19acd152baf125670b49aad165960c79493219ff0937f96dd7cf10e94f92b5d607b18956653f30a2e11654bb58c369ba1c80df37ba73d42a94fe316d1eda5f54f980142f265df1a3f8b1232215c6779e77b359fdeb09dc67287c4e9dd419328ca942db3e4588e12429d5b54842ae040e28fe09e6d3e99bc48184a5cbf2d69e28948c75a540765fda3c83c5e4e31ec45c52d515c746121c035afe055bdcb465ced8c8ef66ad5ef9473330e9a5a4690e83aedbd883b2d429ca9ebae4f0a6172ed3ed86c0ee1a67ff58df2b289b89217ef46a16f7f72ababe9d097b78533234fe821f5b4750e020d6fbd2f4372bb4c84c050edea3ebb71e07fed7daa219047cd742f224b1de50fc1c4db2358d75bcceae80c18b0588910ebf079931fe2b933685bbc79dc86493ae7629654598dc0571b0234865880d69e0f95461ba680bcad92d7356734fe046825db549e262a42227620ce5f18136fc99e35597a2b62482e1003a1fdbc4f3417170e18885ee3d42c8f8b371bee0a45123d9ee31fc7c53c60adc1164ce403ebbe933f3a620f1931ca9205e3d87c13686a07dfc0851d0c014a70073dfb35d95cc1adcb4b6b380cbbdaab66ef2a5cfd364998c5dd6d661151da16660772f93ba551e64870fc3db65c2f775eef202916e56818270875c2bc7ead388d57c9fe22b1d23725a5bfec2b54cf52ed47fb86cf15b8077885e3b5f7256af08474df4ecc4be9f5bcac17335bf3e8b05761a86ac8bf2677fe02f9bab3bc6d32361f8af34d056d9467eb72938f74fbb3eaf9a4a7fc30e7b0a04e9ccef3917a74df53752499aa76c41a5d493f5a46e56ee0bf017c8037774949a758b37f454cade7f8ebce891837919bd6ef8f43bd8d7beebd3456bfb1a54220ae10c73c26a73c0344a7ac87cc945bd95346a6ad913e50d3a5e2ffb3f94a552905c395d1f862fd1b333d30b2a93487fb72a69a5de76463c7a338afde56a37b634dbc0f56babe8246422f13c67576c8b34d973da7f10a94560aed583c1dc5ab35539aad822ad8e9b0f2e745749670f7362deb87a5ab1f91f4f71e0a6b44226bcae762ecba509af5837f3ca36fc781699c06668fd3f4d1018245e7ad019a340ac5030c9e1b43e95ae746649e7bef2ac91c19793d6de4efd420275d4c280fe008dcd2ef793cce18b12edf47a7306855b6988dea01a236aea7b6cd5b4bfc6155c83fea1a30a221e093bcdec790c136a54524caf9d031e6a4fa659bf50b65b9bf82a987359b53c3c8b67c69f36e35b871b26611ad303b5347a1c9790606cea7486a66ce0b1888c20084cd6820d8d3eb9b77f6eecc806d0d94d4472c35b81528258ce692bb9431f1b4e524aa8c80d74dba96b9ed960e09e4970dbb4798df6122177791ae5674b42ba3110bc7291f81d42811a69210cd2d9d82763dca3ac7e42dcab37dbf7f1c93004670ac7fc19c5fb34a7b6525c56e8a0e6e4c7e8f27bf8d91847ede7ca7bc4abe6b20a25b4e51dd57f7e7cb1850698126166b61d77b0708ea83b11973f59a6f903b18240c8374e4ff84d3f0c729024c9f1e423bc013609c5646a63a3cde3ca4d4eba7a2dc7f84b73e24d938c87ef5dfb3815b47dd3ce5c8197959d65b1dfd95017f0d8f9511aaa1b89de0d567f7bd6440051732ac555b7fca3c9e93086e47654bf904632f5c33523699c1310c3e80829d5a4a1f8deacdd4d265b56fac86100d06ac2cbac9da85d3096c5e06811a7cdc7c3bb1a89eabad644ae9e11d2be9695e777598a39c5ee64b275c33bbc72d8493b8c209aee4b9ec39f009e8f3a607bf4c777718bc08ab2504f6816c8cbbabeab673e514947a5ba85e21e8d502ac94aec47a57a9eefecbfb8fed64600c62f823d6d6bf5b89286b07b2b55b2f5cd1abd47fa32b6e92f6a6068df0fb1e2430f52b874c4938098b9e7ab4d5599a205b7c3f77a2b2e1ceb0ba118671f7d2039b420b607949d90ac0f4b1f2b868f2bb276e705f89546393afa6e5110443aa6b7f289f42a509b06e8a9b84bfb32a9b0a1813c0d90477dd9ed169e37a773d943a7f9a0f8af824de699963b673f64245650f856478dacb07caef1c885aa7e08e202d2a6c4ac917cebbe8f383e874418790c0d96179edc2fc6ee932079bc0f758c073227a6c9b0467c5170f4bf82ec88cdde2d9070b6637db7d87bc1b81d95e8bf2639b3c65fc8fc188bf33639852961aee21e935bfd22722e10eb2ec4777e0021d5fbcd5f6651453e80e77d96fbaacdf0cbe64a166f5da245d292f0eda60f672516b47986dc433496d39b6284934db00ef24e2965c46601e4f352281e9fd4eb0787e4dfc7d0a76513bd1c3b2b13f939376aa6d5ad158f66afa636658544008fc46825c292ca96d2c164ec7a0a5c1c7225a96f49b19bd0fe245494aeee1f64ecb2ccf47a735fe0e3d0d4f10233a7ad7e2dd4b8ff08b75fca6e61631b922c01ccb000dba88cb723d49265982e86f1f97957b5d20dd9de4353b153a1f8b8e75244d7f7afa3a9938f0b2e6d7b5bc3bc2074352f467dae784e27de38c7cd78bcfa15b7ec072b2099260bf2efd888e5ef91039823094d69048b4d6210c4a59c3ec75d4b5682fe78a78c5ba19be46581bfcbd99d30624001af29492be56096b1ba7dc37a9704a97c7fd25e530bf1d0c91e4fb5905c0d3b5560c1b93995303d3fef6410a4913e6d65dbeeb5f538053d414b43691301e4f88d6eda937b34bdf54640012278d9509e983a07f9a9059a611aa35fe47c7aae6917d29d1bfed3657b9aecfb946c346edbd1a56bde4403568094fb35a4d2463b6e53c1801e2a223e8c3a694befab84cbf79795852f90d8b5dd3b7994ccdd96d184561ac4e0b41f75357b5a58d88cf8fb80ee3d5c86b1cae3c89899733191c66a6f43c6aaa46f0941c2998c619dcca52fc4108bae2e2d12176297fa50d4dcc695ac228245e11d9d15f7699cf5c15ca85c493766ad45d124f8556a085e6c019b23cdab73b96f3732ef175e9af2d10b04346cc985d1aea74cf4c6affd830cb5aa243cb9bed42f4238af9aa890e8c4fbde521535dfa141d4e42d9d07c6fdea5d93d912c6c2dcc12b0820da688b5e4f4f5e8ca37ecbdf4811e7d02a73022e2da4aaa5ca06389448be29bb5aeeba7af03e39ad4fd9ca7b801ab80308b3ae00c6b3e6ebe222d6a89709342ea6b22241887d5a12d3c78d3ad8655466d5b24173b9b2925b3c4edb5f9fe0ae6338e08a4624ece7a762c4898433de119bc20035ff016fef4f23f010f1300e194cd0be6bb47b3105f1006f77731ab995dda654e6c65820a2a6ab14b085116ec62d0919e0a189dc06aecfdd26f4e84c0f37e587f7c19a3bc81410d11bfea7d3e49907f39","isRememberEnabled":true,"rememberDurationInDays":"10","staticryptSaltUniqueVariableName":"6b2ba8e67b65e63df2dede4fd524dcf5"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
